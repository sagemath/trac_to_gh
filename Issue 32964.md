# Issue 32964: Fix "referenced before assignment" warnings in matrices

archive/issues_032964.json:
```json
{
    "body": "\n```\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:283:19: local variable 'd' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:285:18: local variable 'd' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:289:11: local variable 'd' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:297:14: local variable 'one' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:298:14: local variable 'zero' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:305:58: local variable 'one' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:306:65: local variable 'zero' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:309:57: local variable 'one' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:310:65: local variable 'zero' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:323:11: local variable 'one' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:324:11: local variable 'zero' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:328:30: local variable 'one' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:329:15: local variable 'zero' referenced before assignment\n[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:283:19: local variable 'd' referenced before assignment\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/33201\n\n",
    "created_at": "2022-01-17T20:01:15Z",
    "labels": [
        "build",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Fix \"referenced before assignment\" warnings in matrices",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/32964",
    "user": "mjo"
}
```

```
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:283:19: local variable 'd' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:285:18: local variable 'd' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:289:11: local variable 'd' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:297:14: local variable 'one' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:298:14: local variable 'zero' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:305:58: local variable 'one' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:306:65: local variable 'zero' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:309:57: local variable 'one' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:310:65: local variable 'zero' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:323:11: local variable 'one' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:324:11: local variable 'zero' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:328:30: local variable 'one' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:329:15: local variable 'zero' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:283:19: local variable 'd' referenced before assignment
```


Issue created by migration from https://trac.sagemath.org/ticket/33201





---

archive/issue_comments_470102.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2022-01-17T20:07:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32964",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32964#issuecomment-470102",
    "user": "mjo"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_470103.json:
```json
{
    "body": "New commits:",
    "created_at": "2022-01-17T20:07:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32964",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32964#issuecomment-470103",
    "user": "mjo"
}
```

New commits:



---

archive/issue_comments_470104.json:
```json
{
    "body": "Normally, one does not write sub-optimal code just to satisfy a compiler. There had better be a very convincing reason! In this case I am even less convinced that a fix on our side is required, since there is an issue open in cython pertaining this: https://github.com/cython/cython/issues/1269\n\nThe \"proper\" solution would be a cython indicator that the first use site actually is an initialization. A little less precise, but perhaps a little easier to implement in cython: some indicator in the declaration that marks the variable as \"don't check initialization-before-reference\"; probably implemented as \"treat this as initialized\" (without generating actual initialization code).\n\nUnless the cython issue is resolved satisfactorily, these examples show the application of a feature like that, and the cython folk may well be willing to implement it.",
    "created_at": "2022-01-17T21:45:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32964",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32964#issuecomment-470104",
    "user": "nbruin"
}
```

Normally, one does not write sub-optimal code just to satisfy a compiler. There had better be a very convincing reason! In this case I am even less convinced that a fix on our side is required, since there is an issue open in cython pertaining this: https://github.com/cython/cython/issues/1269

The "proper" solution would be a cython indicator that the first use site actually is an initialization. A little less precise, but perhaps a little easier to implement in cython: some indicator in the declaration that marks the variable as "don't check initialization-before-reference"; probably implemented as "treat this as initialized" (without generating actual initialization code).

Unless the cython issue is resolved satisfactorily, these examples show the application of a feature like that, and the cython folk may well be willing to implement it.



---

archive/issue_comments_470105.json:
```json
{
    "body": "Replying to [comment:2 nbruin]:\n> Normally, one does not write sub-optimal code just to satisfy a compiler. There had better be a very convincing reason! In this case I am even less convinced that a fix on our side is required, since there is an issue open in cython pertaining this: https://github.com/cython/cython/issues/1269\n\n...open for a decade, whose last comment is \"Seems really not easy to fix.\"\n\nBut I disagree in principle: to satisfy a compiler is one of the best and most-common reasons to write sub-optimal code. There are several important warnings being thrown, but no one has noticed them because they're drowned out by this noise. We're talking about initializing a couple floats to zero. If that's the cost to make our cython output meaningful again, it's worth it.\n\n> The \"proper\" solution would be a cython indicator that the first use site actually is an initialization. A little less precise, but perhaps a little easier to implement in cython: some indicator in the declaration that marks the variable as \"don't check initialization-before-reference\"; probably implemented as \"treat this as initialized\" (without generating actual initialization code).\n\nThis just moves the problem up one level to \"does the cython comment still agree with the code it was written for?\"",
    "created_at": "2022-01-17T22:04:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32964",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32964#issuecomment-470105",
    "user": "mjo"
}
```

Replying to [comment:2 nbruin]:
> Normally, one does not write sub-optimal code just to satisfy a compiler. There had better be a very convincing reason! In this case I am even less convinced that a fix on our side is required, since there is an issue open in cython pertaining this: https://github.com/cython/cython/issues/1269

...open for a decade, whose last comment is "Seems really not easy to fix."

But I disagree in principle: to satisfy a compiler is one of the best and most-common reasons to write sub-optimal code. There are several important warnings being thrown, but no one has noticed them because they're drowned out by this noise. We're talking about initializing a couple floats to zero. If that's the cost to make our cython output meaningful again, it's worth it.

> The "proper" solution would be a cython indicator that the first use site actually is an initialization. A little less precise, but perhaps a little easier to implement in cython: some indicator in the declaration that marks the variable as "don't check initialization-before-reference"; probably implemented as "treat this as initialized" (without generating actual initialization code).

This just moves the problem up one level to "does the cython comment still agree with the code it was written for?"



---

archive/issue_comments_470106.json:
```json
{
    "body": "I've tried to measure the impact of initialization but it seems not easy on a modern linux system. There are so many security features involved, it looks like I'm always getting zero pages from the kernel and that GCC is happy to take advantage of this. For trivial test programs, it's generating the same assembly with/without zero-initialization.\n\nI'm sure it can be done but I really expect the performance penalty to be unmeasurable on any system capable of running sage. And in exchange it will be really nice to have the list of outstanding warnings be readable and actionable.",
    "created_at": "2022-01-18T00:48:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32964",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32964#issuecomment-470106",
    "user": "mjo"
}
```

I've tried to measure the impact of initialization but it seems not easy on a modern linux system. There are so many security features involved, it looks like I'm always getting zero pages from the kernel and that GCC is happy to take advantage of this. For trivial test programs, it's generating the same assembly with/without zero-initialization.

I'm sure it can be done but I really expect the performance penalty to be unmeasurable on any system capable of running sage. And in exchange it will be really nice to have the list of outstanding warnings be readable and actionable.



---

archive/issue_comments_470107.json:
```json
{
    "body": "I would expect this initialization to get eliminated during compilation: The `F.init()` calls should get inlined, so the compiler can see that the value gets written to again immediately after (without ever being read from), which means the assignment can be omitted.\n\nI don't think this has to do with zero pages (the compiler can't assume much about what happened to the stack before we got called).",
    "created_at": "2022-01-19T02:54:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32964",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32964#issuecomment-470107",
    "user": "lorenz"
}
```

I would expect this initialization to get eliminated during compilation: The `F.init()` calls should get inlined, so the compiler can see that the value gets written to again immediately after (without ever being read from), which means the assignment can be omitted.

I don't think this has to do with zero pages (the compiler can't assume much about what happened to the stack before we got called).



---

archive/issue_comments_470108.json:
```json
{
    "body": "Replying to [comment:5 lorenz]:\n> I would expect this initialization to get eliminated during compilation: The `F.init()` calls should get inlined, so the compiler can see that the value gets written to again immediately after (without ever being read from), which means the assignment can be omitted.\n\nYou're right. The following example is complicated enough that the (gcc-11) assembly differs at `-O0` and `-O1`, but is identical at `-O2`:\n\n\n```C++\n#include <iostream>\n#include <givaro/modular-floating.h>\n\nusing namespace std;\n\ntypedef Givaro::Modular<double> Modular_double;\n\nint main(int argc, char** argv) {\n  double zero, one;\n  //double zero = 0, one = 0;\n  long modulus = 2;\n  Modular_double F(modulus);\n  F.init(zero, (int)0);\n  F.init(one, (int)1);\n\n  cout << \"zero: \" << zero << \"\\n\" << \"one: \" << one << \"\\n\";\n  return 0;\n}",
    "created_at": "2022-01-19T16:14:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32964",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32964#issuecomment-470108",
    "user": "mjo"
}
```

Replying to [comment:5 lorenz]:
> I would expect this initialization to get eliminated during compilation: The `F.init()` calls should get inlined, so the compiler can see that the value gets written to again immediately after (without ever being read from), which means the assignment can be omitted.

You're right. The following example is complicated enough that the (gcc-11) assembly differs at `-O0` and `-O1`, but is identical at `-O2`:


```C++
#include <iostream>
#include <givaro/modular-floating.h>

using namespace std;

typedef Givaro::Modular<double> Modular_double;

int main(int argc, char** argv) {
  double zero, one;
  //double zero = 0, one = 0;
  long modulus = 2;
  Modular_double F(modulus);
  F.init(zero, (int)0);
  F.init(one, (int)1);

  cout << "zero: " << zero << "\n" << "one: " << one << "\n";
  return 0;
}



---

archive/issue_comments_470109.json:
```json
{
    "body": "(And the `init` method is marked \"inline\", so this should happen reliably.)",
    "created_at": "2022-01-19T16:15:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32964",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32964#issuecomment-470109",
    "user": "mjo"
}
```

(And the `init` method is marked "inline", so this should happen reliably.)
