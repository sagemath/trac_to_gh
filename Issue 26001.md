# Issue 26001: Repetitive doctests in sage.structure.coerce_dict

Issue created by migration from Trac.

Original creator: embray

Original creation time: 2018-09-11 09:42:23

The `sage.structure.coerce_dict` has many examples of the problem I've seen before where entire doctests are documented verbatim, or sometimes almost verbatim, in order to satisfy the poorly-worded "all def statements must have an examples block in their docstring" rule.

Some of these are not even useful in the spirit of that rule, because they are written as "indirect doctests" that don't actually usefully demonstrate how the class is used internally.  This is especially true for the examples in `MonoDictEraser` and `TripleDictEraser`.  These could use better tests/examples.  Or none at all if it's not practical to do so.


---

Comment by embray created at 2018-09-11 10:09:30

There's also a lot of repetition between the _implementations_ of `MonoDict` and `TripleDict`.  Some of this may be unavoidable, but I suspect much of it isn't.  There are obvious cases of copy-and-paste in docstrings, e.g. one which refers to "MonoDict" where it should read "TripleDict".

For the most part all that separates these classes is the number of elements in the key.  The question is can this be generalized a bit more without sacrificing performance.  I suspect yes but it's low priority for me to try.


---

Comment by embray created at 2018-09-11 10:19:54

It's also too bad this is kind of buried as `sage.structure.coerce_dict`. I was aware this module existed but this is the first time I looked closely at it.  I thought it might be _very_ particular to the Sage coercion model in some way, but not necessarily.  It seems like it might have use cases beyond that.  I wonder if some more generalized version of it would be useful to make available as a stand-alone module.


---

Comment by embray created at 2018-12-28 14:10:15

Retargeting some of my tickets (somewhat optimistically for now).


---

Comment by nbruin created at 2019-01-02 08:13:47

Replying to [comment:1 embray]:

> For the most part all that separates these classes is the number of elements in the key.  The question is can this be generalized a bit more without sacrificing performance.  I suspect yes but it's low priority for me to try.

Yes, it can be generalized, but it's not clear there's an application for it. The code presently has unrolled loops in the hope that we get optimal performance that way. It would seem natural that a general version would be a bit slower. My guess would be that it would still be worth keeping the MonoDict (also because that's a lot closer to a normal dictionary), and since a TripleDict is the only other instance we'd use, there seems to be no gain in generalizing. That was my intuition when it was written.


---

Comment by jdemeyer created at 2019-01-02 08:53:42

Replying to [comment:1 embray]:
> The question is can this be generalized a bit more without sacrificing performance.

By making it more general, you will always sacrifice performance a bit.

Since `TripleDict` plays an extremely important role in the coercion model, it affects every single arithmetic operation between different parents. So performance matters a lot.


---

Comment by jdemeyer created at 2019-01-02 09:00:38

One solution to reduce code duplication without losing any performance would be to use a templating language on the source code (say `jinja2` since Sage ships with that or maybe even C++ templates). We could deal with `MonoDict` as a special `n==1` case where needed.


---

Comment by embray created at 2019-01-02 16:50:54

Yes, I had thought of either trying to cobble together something with C preprocessor macros, or with C++.  I agree with Nils that it doesn't make sense to instantiate more versions of this than we need; I just meant that the code could probably be generalized in some way that requires less duplication of code.


---

Comment by jdemeyer created at 2019-01-02 16:56:05

The question is... is it worth doing that?


---

Comment by nbruin created at 2019-01-02 17:03:45

Replying to [comment:8 embray]:
>  I just meant that the code could probably be generalized in some way that requires less duplication of code.

The use of any templating makes the code harder to understand, at least because it requires the reader to understand the templating in addition to cython and the inner workings of Python. It also makes it harder to spot places where optimizations can be made.

So I'd say there's a significant cost to using a less direct way of generating the code. You'd have to show a significant benefit to justify it. In this case it would be "maintainability". I'm not so sure you really improve that. There is indeed some repetition of code, but it's very straightforward code and the total body of code is not that bad either. So I'd think there's no room to recoup the cost of templating.

The doctests on the other hand: yes some of those are only there to cover the coverage metric. There would probably be room for improving the tests. The actual coverage of the functionality is pretty good with some of the more centralized tests, though, so I'm not sure you'll find bugs or improve the code by improving the doctests.

Concering the doctest coverage metric: I think that metric has the advantage of being very simple and has a net positive effect, so I'd be in favour of keeping the metric.


---

Comment by embray created at 2019-01-03 19:01:39

Fair enough; I don't disagree I was just wondering out loud.  In this ticket I'm more concerned about the poor and/or repetitive testing.


---

Comment by embray created at 2019-03-25 10:44:36

Removing most of the rest of my open tickets out of the 8.7 milestone, which should be closed.
