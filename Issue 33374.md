# Issue 33374: Improve edges/ridges for simple/simplicical polytopes

Issue created by migration from https://trac.sagemath.org/ticket/33611

Original creator: @kliem

Original creation time: 2022-03-31 11:01:00

CC:  tscrim yzh

In #30040 we have improved the face iterator for simple/simplicial polytopes, but have not applied this to our heuristic, whether we should find edges/ridges in dual/non-dual mode.


---

Comment by @kliem created at 2022-03-31 11:26:34

Changing status from new to needs_review.


---

Comment by @kliem created at 2022-03-31 11:32:31

New commits:


---

Comment by yzh created at 2022-03-31 18:32:58

Maybe irrelevant to this ticket, but are there better criteria than n_Vrepresentation > (n_facets)<sup>2</sup>  (or n_Vrepresentation<sup>2</sup> < n_facets) in which cases one knows that the primal (or the dual) algorithm is faster?

"Wild estimates" plus special treatment for simple/simplicial polytopes does not seem optimal to me. 

If we don't know a better criterion, does it make sense to leave the choice to the user, as an optional input?


---

Comment by tscrim created at 2022-04-01 06:25:32

I also think it would be good to answer that question and +1 for adding an option for the user to select. However, that can be left to another ticket.

For the change in this ticket. LGTM modulo the order of the checks. How expensive is the `is_simple()` compared to the other and how frequently do you expect it to get to that test? This is quite a micro-optimization, so if you don't want to be bothered with it, you can set a positive review.


---

Comment by @kliem created at 2022-04-01 11:09:18

I think it is a good idea to expose the primal/dual or automatic options. I really don't know, when the algorithm is faster which way. Like I know for fixed polyhedra, but I have no clue in general. It is surprising how the primal algorithm even to generate edges is much better than the dual algorithm in many cases.

What do you think is better:
- a keyword `algorithm`, with options `'primal'`, `'dual'` or `None` or
- a kewword `dual` with options `True`, `False` and `None`?

At the moment the `Polyhedron_base` method `face_generator` already exposes the keyword dual. But if this is not intuitive we should maybe switch to `algorithm=` instead.


---

Comment by @kliem created at 2022-04-01 11:09:34

Changing status from needs_review to needs_info.


---

Comment by @kliem created at 2022-04-01 11:44:04

`is_simple()` is not cached (but could be). It has complexity of the incidence matrix, which is worse than the other checks, which are pretty much constant at this stuff needs to be computed anyway.

Maybe it makes sense to cache `is_simple`:


```
sage: C = polytopes.hypercube(12).combinatorial_polyhedron()
sage: %timeit C.is_simple()
24.5 µs ± 1.72 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
sage: %time C.f_vector()
CPU times: user 253 ms, sys: 11.7 ms, total: 265 ms
Wall time: 187 ms
(1, 4096, 24576, 67584, 112640, 126720, 101376, 59136, 25344, 7920, 1760, 264, 24, 1)
```


As for the complexity of the primal and dual algorithm (for edges):

- The dual algorithm takes about `n_Vrepresentation ** 3 * n_facets`.
- The primal algorithm in in the non-simple case takes `sum(f_vector) * n_facets ** 2 * n_Vrepresentation`.
- The primal algorithm in in the simple case takes `sum(f_vector) * n_facets * n_Vrepresentation`.

To estimate `sum(f_vector)` one can use the upper bound theorem. I came up with something in the complexity of `dimension * binomial(min(n_facets, n_Vrepresentation), dimension // 2)`.

One could use those things to get a better estimate, but I don't know if this would be any good. Exposing the algorithm might be the better choice here.


---

Comment by yzh created at 2022-04-01 14:35:42

Thank you for providing the complexity details! The formulas look very neat. I think it would be nice to use them in the code, especially when `_f_vector` was cached, because otherwise the users are unlikely to know such things.

I like the keyword `dual` with options `True`, `False` and `None`.  

+1 for caching `is_simple` and `is_simplicial`.

+1 for "This is quite a micro-optimization, so if you don't want to be bothered with it, you can set a positive review."


---

Comment by tscrim created at 2022-04-04 00:28:10

comment:7: I would use `algorithm` as it is more flexible for the future.

comment:9: Thank you. I agree with Yuan that they should be cached. From what you're saying, I agree that they should be last in the checking order. Could there be a typo in your formulas? I don't understand what `***` is. Perhaps this is my naïvity, but aren't facets in bijection with a minimal number of hyperplanes defining the polytope? Then I would expect the dual algorithm to almost always be the faster algorithm since squares grow much slow than binomials (after dividing by common factors). Unless the `sum(f_vector)` grows much slower than the upper bound theorem implies. (Sorry if these are more basic facts you need to explain to me; it's been a little while since I have done anything nontrivial in this area).


---

Comment by @kliem created at 2022-04-05 08:05:45

Replying to [comment:11 tscrim]:
> comment:7: I would use `algorithm` as it is more flexible for the future.

I also think this is a better name, but it involves deprecation. But well, that's life I guess.
> 
> comment:9: Thank you. I agree with Yuan that they should be cached. From what you're saying, I agree that they should be last in the checking order. Could there be a typo in your formulas?

> I don't understand what `***` is.

A typo, fixed now. Also the simple/simplical complexity had a typo.

> Perhaps this is my naïvity, but aren't facets in bijection with a minimal number of hyperplanes defining the polytope? Then I would expect the dual algorithm to almost always be the faster algorithm since squares grow much slow than binomials (after dividing by common factors). Unless the `sum(f_vector)` grows much slower than the upper bound theorem implies. (Sorry if these are more basic facts you need to explain to me; it's been a little while since I have done anything nontrivial in this area).

A couple of simple/simplicial examples:


```
sage: C = polytopes.hypercube(10).combinatorial_polyhedron()
sage: C.f_vector()
(1, 1024, 5120, 11520, 15360, 13440, 8064, 3360, 960, 180, 20, 1)
sage: %time sum(1 for _ in C.face_iter(1, dual=True))
CPU times: user 175 ms, sys: 0 ns, total: 175 ms
Wall time: 175 ms
5120
sage: %time sum(1 for _ in C.face_iter(1, dual=False))
CPU times: user 3.71 ms, sys: 0 ns, total: 3.71 ms
Wall time: 3.71 ms
5120
sage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual
21474836480
sage: sum(C.f_vector()) * C.n_facets() * C.n_vertices()  # complexity primal
1209344000
```



```
sage: C = polytopes.hypercube(12).combinatorial_polyhedron()
sage: C.f_vector()
(1, 4096, 24576, 67584, 112640, 126720, 101376, 59136, 25344, 7920, 1760, 264, 24, 1)
sage: %time sum(1 for _ in C.face_iter(1, dual=True))
CPU times: user 9.89 s, sys: 154 µs, total: 9.89 s
Wall time: 9.89 s
24576
sage: %time sum(1 for _ in C.face_iter(1, dual=False))
CPU times: user 36.7 ms, sys: 0 ns, total: 36.7 ms
Wall time: 36.3 ms
24576
sage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual
1649267441664
sage: sum(C.f_vector()) * C.n_facets() * C.n_vertices()  # complexity primal
52242874368
```



```
sage: C = polytopes.cyclic_polytope(10, 20).combinatorial_polyhedron()
sage: C = C.polar()
sage: C.f_vector()
(1, 4004, 20020, 42315, 49140, 34470, 15504, 4845, 1140, 190, 20, 1)
sage: %time sum(1 for _ in C.face_iter(1, dual=True))
CPU times: user 9.55 s, sys: 18 µs, total: 9.55 s
Wall time: 9.55 s
20020
sage: %time sum(1 for _ in C.face_iter(1, dual=False))
CPU times: user 19.9 ms, sys: 0 ns, total: 19.9 ms
Wall time: 19.8 ms
20020
sage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual
1283843841280
sage: sum(C.f_vector()) * C.n_facets() * C.n_vertices()  # complexity primal
13745732000
```


A non-simple and non-simplicial case:


```
sage: P = polytopes.permutahedron(7) 
sage: P1 = P.stack(next(P.face_generator(1)))
sage: C = CombinatorialPolyhedron(P1)
sage: %time C.f_vector()
CPU times: user 184 ms, sys: 0 ns, total: 184 ms
Wall time: 28.9 ms
(1, 5041, 16251, 19761, 11144, 2860, 267, 1)
sage: %time sum(1 for _ in C.face_iter(1, dual=True))
CPU times: user 20.1 s, sys: 0 ns, total: 20.1 s
Wall time: 20.1 s
16251
sage: %time sum(1 for _ in C.face_iter(1, dual=False))
CPU times: user 28.1 ms, sys: 0 ns, total: 28.1 ms
Wall time: 27.9 ms
16251
sage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual
34202775806907
sage: sum(C.f_vector()) * C.n_facets() ** 2 * C.n_vertices()  # complexity primal
19882385613774
```


Note that the primal algorithm appears to be much better than our estimate. The reason is that the farther we go into the tree, the better the actual runtime will differ from the worst case scenario.

I also find the runtimes quite counter-intuitive. It seems that obtaining the f-vector of a simple/simplicial polytope with this iterator is much better than using the h-vector method.


---

Comment by tscrim created at 2022-04-05 09:04:06

On the internal function, having it be an `int` is much faster than a `string` for checking cases. You can also change that without any deprecation.

Thank you for the timings. I don't really have any intuition for what should be faster. So I won't be much help and will simply defer to your (and Yuan's) judgement.


---

Comment by @kliem created at 2022-04-05 10:10:24

Replying to [comment:14 tscrim]:
> On the internal function, having it be an `int` is much faster than a `string` for checking cases. You can also change that without any deprecation.
> 
> Thank you for the timings. I don't really have any intuition for what should be faster. So I won't be much help and will simply defer to your (and Yuan's) judgement.

In #33646 I propose to use the keyword `algorithm` and `face_generator` over `face_iter`, but without deprecation.

The problem with exponential size is the following: Given a polytope as finite intersection of closed halfspaces. The number of vertices can be expected to be exponential with respect to the number of facets.

However, if you have a non-simple and non-simplicial polytope things might be a lot different. Those polytopes are less-generic but certainly more interesting.


---

Comment by @kliem created at 2022-04-07 15:33:33

New commits:


---

Comment by @kliem created at 2022-04-07 15:33:33

Changing status from needs_info to needs_review.


---

Comment by yzh created at 2022-04-07 18:04:24

In docstring of `facet_graph`, incidences --> indices

``` 
If ``names`` is ``False``, the ``vertices`` of the graph  will
         be the incidences of the facets in the Hrepresentation.
```



---

Comment by yzh created at 2022-04-07 18:13:15

In the docstring of `def edges(self, names=True, algorithm=None):`,
` ``names`` -- boolean (default: ``True``); if ``True``, ...` --> if False ?


---

Comment by git created at 2022-04-07 18:23:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by yzh created at 2022-04-07 18:30:36

Maybe change all `face iterator` in the docstrings to `face generator` as well?


---

Comment by git created at 2022-04-07 18:33:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-04-07 18:34:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by yzh created at 2022-04-07 18:43:31

Regarding

```
     sage: C.edges()[:2]
-    ((A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)),
-     (A vertex at (-1, 1, -1, -1), A vertex at (-1, -1, -1, -1)))
+    ((A vertex at (1, -1, -1, -1), A vertex at (-1, -1, -1, -1)),
+     (A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)))
     sage: C.edges(names=False)[:2]
-    ((14, 15), (10, 15))
+    ((6, 15), (14, 15))
```

Are the vertices and facets of a `CombinatorialPolyhedron` always stored in a fixed order? 
I vaguely recall that there was an ordering problem for the representations of a `Polyhedron` with different backends. I'm not sure if this is relevant here.
----
New commits:


---

Comment by @kliem created at 2022-04-07 18:47:17

Replying to [comment:24 yzh]:
> Regarding
> {{{
>      sage: C.edges()[:2]
> -    ((A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)),
> -     (A vertex at (-1, 1, -1, -1), A vertex at (-1, -1, -1, -1)))
> +    ((A vertex at (1, -1, -1, -1), A vertex at (-1, -1, -1, -1)),
> +     (A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)))
>      sage: C.edges(names=False)[:2]
> -    ((14, 15), (10, 15))
> +    ((6, 15), (14, 15))
> }}}
> Are the vertices and facets of a `CombinatorialPolyhedron` always stored in a fixed order? 
> I vaguely recall that there was an ordering problem for the representations of a `Polyhedron` with different backends. I'm not sure if this is relevant here.
> ----
> New commits:
> ||[f986979](https://git.sagemath.org/sage.git/commit?id=f986979ad764084fcf43050bb4fa5e8a9ebb1807)||`use "face generator" in the documentation`||
> ||[3bccc27](https://git.sagemath.org/sage.git/commit?id=3bccc276294a25ef8106156cabfb9e1df0bdd864)||`fix documentation error`||

The order of Vrepresentation and Hrepresentation is taken from the input and is then fixed.
What is happening here is that the default algorithm for the edges changed and then this changed the order edges.


---

Comment by yzh created at 2022-04-07 18:55:11

Thank you very much! All looks good to me. 

`@`tscrim: Would you mind taking a look at the Patchbot failing? (I don't understand it.)


---

Comment by @kliem created at 2022-04-07 19:36:01

At the moment there is only one failure and looks like a `mathematica` time out, so unrelated.


---

Comment by yzh created at 2022-04-07 23:20:17

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-04-08 00:05:38

Indeed, it is unrelated. The latest patchbot run also came back morally green as well.


---

Comment by @kliem created at 2022-04-08 04:46:33

Thank you.


---

Comment by vbraun created at 2022-05-20 22:27:06

Resolution: fixed
