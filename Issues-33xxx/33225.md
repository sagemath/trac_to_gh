# Issue 33225: Lazy transition maps

archive/issues_032988.json:
```json
{
    "body": "As discussed in #31249, a lazy implementation of charts or transition maps comes in handy in some situations as the number of transition maps explodes very easily.\n\nIn this ticket, we introduce a lazy implementation of transition maps that only initializes most attributes, especially the associated `MultiCoordFunction` and the inverse, if necessary.\n\n**CC:**  @tscrim @egourgoulhon @tobiasdiez @trevorkarn\n\n**Keywords:** lazy, charts\n\nIssue created by migration from https://trac.sagemath.org/ticket/33225\n\n",
    "created_at": "2022-01-24T10:48:59Z",
    "labels": [
        "component: manifolds",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.8",
    "title": "Lazy transition maps",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/33225",
    "user": "https://github.com/mjungmath"
}
```
As discussed in #31249, a lazy implementation of charts or transition maps comes in handy in some situations as the number of transition maps explodes very easily.

In this ticket, we introduce a lazy implementation of transition maps that only initializes most attributes, especially the associated `MultiCoordFunction` and the inverse, if necessary.

**CC:**  @tscrim @egourgoulhon @tobiasdiez @trevorkarn

**Keywords:** lazy, charts

Issue created by migration from https://trac.sagemath.org/ticket/33225





---

archive/issue_comments_539720.json:
```json
{
    "body": "<a id='comment:1'></a>\nWe could try to speed up initialization by using [__slots__](https://docs.python.org/3/reference/datamodel.html#slots). In my opinion, this is something we should use more frequently in `manifolds` anyway.",
    "created_at": "2022-01-24T10:56:08Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539720",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:1'></a>
We could try to speed up initialization by using [__slots__](https://docs.python.org/3/reference/datamodel.html#slots). In my opinion, this is something we should use more frequently in `manifolds` anyway.



---

archive/issue_comments_539721.json:
```json
{
    "body": "<a id='comment:2'></a>\nThis seems like a good partial measure to do and is much smaller in scope than broad lazy objects. I also support the more targeted focus on the most computationally intensive part.\n\nI would worry about doing `__slots__` on a later ticket unless it is both easy and simple to do for this.",
    "created_at": "2022-01-25T00:05:00Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539721",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>
This seems like a good partial measure to do and is much smaller in scope than broad lazy objects. I also support the more targeted focus on the most computationally intensive part.

I would worry about doing `__slots__` on a later ticket unless it is both easy and simple to do for this.



---

archive/issue_events_297957.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2022-01-25T00:05:16Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "label": "enhancement",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33225#event-297957"
}
```



---

archive/issue_comments_539722.json:
```json
{
    "body": "<a id='comment:4'></a>\nAre there any good examples of lazy objects in the existing codebase which we could use for inspiration?",
    "created_at": "2022-02-02T15:18:54Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539722",
    "user": "https://github.com/trevorkarn"
}
```

<a id='comment:4'></a>
Are there any good examples of lazy objects in the existing codebase which we could use for inspiration?



---

archive/issue_comments_539723.json:
```json
{
    "body": "<a id='comment:5'></a>\nTo name a few:\n- [Lazy Attributes](https://doc.sagemath.org/html/en/reference/misc/sage/misc/lazy_attribute.html)\n- [Lazy Lists](https://doc.sagemath.org/html/en/reference/misc/sage/misc/lazy_list.html)\n- [Lazy Power Series](https://doc.sagemath.org/html/en/reference/combinat/sage/combinat/species/series.html)",
    "created_at": "2022-02-02T22:17:56Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539723",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:5'></a>
To name a few:
- [Lazy Attributes](https://doc.sagemath.org/html/en/reference/misc/sage/misc/lazy_attribute.html)
- [Lazy Lists](https://doc.sagemath.org/html/en/reference/misc/sage/misc/lazy_list.html)
- [Lazy Power Series](https://doc.sagemath.org/html/en/reference/combinat/sage/combinat/species/series.html)



---

archive/issue_comments_539724.json:
```json
{
    "body": "<a id='comment:6'></a>\nReplying to [tscrim](#comment%3A2):\n> I would worry about doing `__slots__` on a later ticket unless it is both easy and simple to do for this. \n\n\nIt shouldn't be very difficult. Actually it's quite straightforward. You only add a `__slots__` attribute. Done. Keep in mind that the corresponding class has no `__dict__` attribute then.",
    "created_at": "2022-02-02T22:20:19Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539724",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:6'></a>
Replying to [tscrim](#comment%3A2):
> I would worry about doing `__slots__` on a later ticket unless it is both easy and simple to do for this. 


It shouldn't be very difficult. Actually it's quite straightforward. You only add a `__slots__` attribute. Done. Keep in mind that the corresponding class has no `__dict__` attribute then.



---

archive/issue_comments_539725.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [gh-mjungmath](#comment%3A6):\n> Replying to [tscrim](#comment%3A2):\n> > I would worry about doing `__slots__` on a later ticket unless it is both easy and simple to do for this. \n\n> \n> It shouldn't be very difficult. Actually it's quite straightforward. You only add a `__slots__` attribute. Done. Keep in mind that the corresponding class has no `__dict__` attribute then.\n\n\nThat is not a trivial thing as it can have very far-reaching effects because you cannot free add attributes and it doesn't work well with `@cached_method` IIRC. It puts the class much more in the C++ realm (not necessarily a bad thing, but it can mean a lot of boilerplate code).",
    "created_at": "2022-02-03T01:29:46Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539725",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:7'></a>
Replying to [gh-mjungmath](#comment%3A6):
> Replying to [tscrim](#comment%3A2):
> > I would worry about doing `__slots__` on a later ticket unless it is both easy and simple to do for this. 

> 
> It shouldn't be very difficult. Actually it's quite straightforward. You only add a `__slots__` attribute. Done. Keep in mind that the corresponding class has no `__dict__` attribute then.


That is not a trivial thing as it can have very far-reaching effects because you cannot free add attributes and it doesn't work well with `@cached_method` IIRC. It puts the class much more in the C++ realm (not necessarily a bad thing, but it can mean a lot of boilerplate code).



---

archive/issue_comments_539726.json:
```json
{
    "body": "<a id='comment:8'></a>\nReplying to [tkarn](#comment%3A4):\n> Are there any good examples of lazy objects in the existing codebase which we could use for inspiration?\n\n\nTwo basic implementation ideas would be you either use an `@lazy_attribute` decorator for the relevant attribute(s) or you set it to `None` on `__init__` and compute it when called for. (IMO, the first option is much better for Python both in terms of code maintenance, readability, and efficiency.) However, each individual implementation might require some variations.",
    "created_at": "2022-02-03T01:32:45Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539726",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>
Replying to [tkarn](#comment%3A4):
> Are there any good examples of lazy objects in the existing codebase which we could use for inspiration?


Two basic implementation ideas would be you either use an `@lazy_attribute` decorator for the relevant attribute(s) or you set it to `None` on `__init__` and compute it when called for. (IMO, the first option is much better for Python both in terms of code maintenance, readability, and efficiency.) However, each individual implementation might require some variations.



---

archive/issue_comments_539727.json:
```json
{
    "body": "<a id='comment:9'></a>\nReplying to [tscrim](#comment%3A8):\n> Replying to [tkarn](#comment%3A4):\n> > Are there any good examples of lazy objects in the existing codebase which we could use for inspiration?\n\n> \n> Two basic implementation ideas would be you either use an `@lazy_attribute` decorator for the relevant attribute(s) or you set it to `None` on `__init__` and compute it when called for. (IMO, the first option is much better for Python both in terms of code maintenance, readability, and efficiency.) However, each individual implementation might require some variations.\n\n\nThanks so much!\n\nThinking about the original motivation for this, the Grassmannian, the problem we are looking to solve is the large overhead created by the creation of many charts. Looking at each individual chart and transition map it doesn't appear to me to have too much overhead. Are we looking to create something that is more of a \"lazy atlas\" or is a lazy transition map really what we want?",
    "created_at": "2022-02-06T17:06:54Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539727",
    "user": "https://github.com/trevorkarn"
}
```

<a id='comment:9'></a>
Replying to [tscrim](#comment%3A8):
> Replying to [tkarn](#comment%3A4):
> > Are there any good examples of lazy objects in the existing codebase which we could use for inspiration?

> 
> Two basic implementation ideas would be you either use an `@lazy_attribute` decorator for the relevant attribute(s) or you set it to `None` on `__init__` and compute it when called for. (IMO, the first option is much better for Python both in terms of code maintenance, readability, and efficiency.) However, each individual implementation might require some variations.


Thanks so much!

Thinking about the original motivation for this, the Grassmannian, the problem we are looking to solve is the large overhead created by the creation of many charts. Looking at each individual chart and transition map it doesn't appear to me to have too much overhead. Are we looking to create something that is more of a "lazy atlas" or is a lazy transition map really what we want?



---

archive/issue_comments_539728.json:
```json
{
    "body": "<a id='comment:10'></a>\nReplying to [tkarn](#comment%3A9):\n> Thinking about the original motivation for this, the Grassmannian, the problem we are looking to solve is the large overhead created by the creation of many charts. Looking at each individual chart and transition map it doesn't appear to me to have too much overhead. Are we looking to create something that is more of a \"lazy atlas\" or is a lazy transition map really what we want?\n\n\nI don't know for sure. My suggestion is to make a prun test on high-dimensional projective spaces and see what the culprits are.\n\nNotice that one transition map is always accompanied by a `MultiCoordFunction` object, and another transition map, namely its inverse, again with a `MultiCoordFunction` object. However, there is no need to initialize the inverse on the fly when the formulas are known. My hope is that this leads to some speed-up.\n\nImplementing `__slots__` for charts might also help a little (speeds up initialization and access).",
    "created_at": "2022-02-06T17:35:36Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539728",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:10'></a>
Replying to [tkarn](#comment%3A9):
> Thinking about the original motivation for this, the Grassmannian, the problem we are looking to solve is the large overhead created by the creation of many charts. Looking at each individual chart and transition map it doesn't appear to me to have too much overhead. Are we looking to create something that is more of a "lazy atlas" or is a lazy transition map really what we want?


I don't know for sure. My suggestion is to make a prun test on high-dimensional projective spaces and see what the culprits are.

Notice that one transition map is always accompanied by a `MultiCoordFunction` object, and another transition map, namely its inverse, again with a `MultiCoordFunction` object. However, there is no need to initialize the inverse on the fly when the formulas are known. My hope is that this leads to some speed-up.

Implementing `__slots__` for charts might also help a little (speeds up initialization and access).



---

archive/issue_comments_539729.json:
```json
{
    "body": "<a id='comment:11'></a>\nI would look at the sphere with perhaps stereographic and spherical coordinates. Really any manifold that has more complicated change of coordinates by default. (One way to get some speed might be to turn off checks; IDK if this is done already or not.) Please avoid doing slots on this ticket; that should be it's own ticket if we decide to do that.",
    "created_at": "2022-02-06T22:08:23Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539729",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:11'></a>
I would look at the sphere with perhaps stereographic and spherical coordinates. Really any manifold that has more complicated change of coordinates by default. (One way to get some speed might be to turn off checks; IDK if this is done already or not.) Please avoid doing slots on this ticket; that should be it's own ticket if we decide to do that.



---

archive/issue_comments_539730.json:
```json
{
    "body": "<a id='comment:12'></a>\nReplying to [gh-mjungmath](#comment%3A10):\n> Replying to [tkarn](#comment%3A9):\n> > Thinking about the original motivation for this, the Grassmannian, the problem we are looking to solve is the large overhead created by the creation of many charts. Looking at each individual chart and transition map it doesn't appear to me to have too much overhead. Are we looking to create something that is more of a \"lazy atlas\" or is a lazy transition map really what we want?\n\n> \n> I don't know for sure. My suggestion is to make a prun test on high-dimensional projective spaces and see what the culprits are.\n\n\n+1",
    "created_at": "2022-02-07T17:25:10Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539730",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:12'></a>
Replying to [gh-mjungmath](#comment%3A10):
> Replying to [tkarn](#comment%3A9):
> > Thinking about the original motivation for this, the Grassmannian, the problem we are looking to solve is the large overhead created by the creation of many charts. Looking at each individual chart and transition map it doesn't appear to me to have too much overhead. Are we looking to create something that is more of a "lazy atlas" or is a lazy transition map really what we want?

> 
> I don't know for sure. My suggestion is to make a prun test on high-dimensional projective spaces and see what the culprits are.


+1



---

archive/issue_comments_539731.json:
```json
{
    "body": "<a id='comment:13'></a>\nReplying to [tscrim](#comment%3A11):\n> I would look at the sphere with perhaps stereographic and spherical coordinates. Really any manifold that has more complicated change of coordinates by default. (One way to get some speed might be to turn off checks; IDK if this is done already or not.) \n\n\nThis is done already for spheres, cf. line 1029 of `sage/manifolds/differentiable/examples/sphere.py`:\n\n```\nspher_to_stereoN.set_inverse(*coordfunc, check=False)\n```\n\n>Please avoid doing slots on this ticket; that should be it's own ticket if we decide to do that.\n\n\n+1",
    "created_at": "2022-02-07T17:28:53Z",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33225#issuecomment-539731",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:13'></a>
Replying to [tscrim](#comment%3A11):
> I would look at the sphere with perhaps stereographic and spherical coordinates. Really any manifold that has more complicated change of coordinates by default. (One way to get some speed might be to turn off checks; IDK if this is done already or not.) 


This is done already for spheres, cf. line 1029 of `sage/manifolds/differentiable/examples/sphere.py`:

```
spher_to_stereoN.set_inverse(*coordfunc, check=False)
```

>Please avoid doing slots on this ticket; that should be it's own ticket if we decide to do that.


+1



---

archive/issue_events_297958.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-05T01:55:27Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33225#event-297958"
}
```



---

archive/issue_events_297959.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-05T01:55:27Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33225#event-297959"
}
```



---

archive/issue_events_297960.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T02:51:13Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33225#event-297960"
}
```



---

archive/issue_events_297961.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T02:51:13Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/33225",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33225#event-297961"
}
```
