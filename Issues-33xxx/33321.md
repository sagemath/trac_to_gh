# Issue 33321: Implement GradedModulesWithBasis(R).Subobjects() and FilteredModulesWithBasis(R).Subobjects()

archive/issues_033084.json:
```json
{
    "assignees": [],
    "body": "<div id=\"comment:0\"></div>\n\nCurrently, graded submodules do not inherit grading from its ambient:\n\n```\nsage: M = ModulesWithBasis(QQ).Graded().example()\nsage: M(Partition((4,2,1,1,1,1))).degree()\n10\nsage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ).Subobjects())\nsage: n = N.basis()\nsage: n[0].degree()\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n...\nAttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'\n```\nWe implement this by fulfilling the regressive category construction requirement for the `GradedModules().Subobjects()` category. We also do this for filtered modules (every submodule of a filtered module has a natural filtration inherited from the ambient module).\n\n\nWant: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `graded_submodule`. For example,\n\n```\nsage: M = ModulesWithBasis(QQ).Graded().example()\nsage: N = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),\n      M(Partition((5,3)))])\nsage: n = N.basis()\nsage: (n[0].lift(), n[1].lift())\n(P[4, 2, 1, 1, 1, 1], P[5,3])\nsage: (n[0].degree(), n[1].degree())\n(10, 8)\nsage: K = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),\n      M(Partition((5,3)) - M(Partition((4,3)))])\nTraceback (most recent call last):\n...\nValueError: element is not homogeneous\n```\n\n\nCC:  @mkoeppe @tscrim @jhpalmieri\n\nComponent: **categories**\n\nKeywords: **submodule**\n\nAuthor: **Louis Ng, Travis Scrimshaw**\n\nBranch/Commit: **[`e5901b5`](https://github.com/sagemath/sagetrac-mirror/commit/e5901b5a8e651e555418dfe96f357af960b33acc)**\n\nReviewer: **Matthias Koeppe**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/33321_\n\n",
    "closed_at": "2022-03-12T15:11:08Z",
    "created_at": "2022-02-10T18:29:38Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20categories",
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.6",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Implement GradedModulesWithBasis(R).Subobjects() and FilteredModulesWithBasis(R).Subobjects()",
    "type": "issue",
    "updated_at": "2022-03-12T15:11:08Z",
    "url": "https://github.com/sagemath/sage/issues/33321",
    "user": "https://github.com/louisng114"
}
```
<div id="comment:0"></div>

Currently, graded submodules do not inherit grading from its ambient:

```
sage: M = ModulesWithBasis(QQ).Graded().example()
sage: M(Partition((4,2,1,1,1,1))).degree()
10
sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ).Subobjects())
sage: n = N.basis()
sage: n[0].degree()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
...
AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'
```
We implement this by fulfilling the regressive category construction requirement for the `GradedModules().Subobjects()` category. We also do this for filtered modules (every submodule of a filtered module has a natural filtration inherited from the ambient module).


Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `graded_submodule`. For example,

```
sage: M = ModulesWithBasis(QQ).Graded().example()
sage: N = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),
      M(Partition((5,3)))])
sage: n = N.basis()
sage: (n[0].lift(), n[1].lift())
(P[4, 2, 1, 1, 1, 1], P[5,3])
sage: (n[0].degree(), n[1].degree())
(10, 8)
sage: K = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),
      M(Partition((5,3)) - M(Partition((4,3)))])
Traceback (most recent call last):
...
ValueError: element is not homogeneous
```


CC:  @mkoeppe @tscrim @jhpalmieri

Component: **categories**

Keywords: **submodule**

Author: **Louis Ng, Travis Scrimshaw**

Branch/Commit: **[`e5901b5`](https://github.com/sagemath/sagetrac-mirror/commit/e5901b5a8e651e555418dfe96f357af960b33acc)**

Reviewer: **Matthias Koeppe**

_Issue created by migration from https://trac.sagemath.org/ticket/33321_





---

archive/issue_events_454884.json:
```json
{
    "actor": "https://github.com/louisng114",
    "created_at": "2022-02-10T18:29:38Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454884"
}
```



---

archive/issue_events_454885.json:
```json
{
    "actor": "https://github.com/louisng114",
    "created_at": "2022-02-10T18:29:38Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20categories",
    "label_color": "0000ff",
    "label_name": "c: categories",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454885"
}
```



---

archive/issue_events_454886.json:
```json
{
    "actor": "https://github.com/louisng114",
    "created_at": "2022-02-10T18:29:38Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454886"
}
```



---

archive/issue_events_454887.json:
```json
{
    "actor": "https://github.com/louisng114",
    "created_at": "2022-02-10T18:29:38Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454887"
}
```



---

archive/issue_comments_538607.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nCan you please add some examples that illustrate what you would like to happen? \nShould submodules of graded modules always/sometimes/never be graded by default?",
    "created_at": "2022-02-10T21:23:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538607",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:2" align="right">comment:2</div>

Can you please add some examples that illustrate what you would like to happen? 
Should submodules of graded modules always/sometimes/never be graded by default?



---

archive/issue_comments_538608.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nThe current behavior is correct because there is no guarantee that an *arbitrary* submodule is spanned by homogeneous elements. For a simple example, take the submodule spanned by `f = 1 + x` in the polynomial ring with the natural degree grading. (There are more pathological examples for the counterarguments I can see for this.)\n\nNow we could do something where we check to see if the spanning elements are homogeneous and then use the ambient grading. This then likely has a solution at the category level by creating the category of subobjects of graded modules with basis and graded modules (with basis). (Note as I argue above, this is a strict subcategory of subobjects of graded modules with basis.) This might be slightly subtle as, in principle, by saying an object is graded, you are suppose to specify what graded structure you want. Thus doing it automatically is perhaps not quite mathematically valid.\n\nPerhaps the better solution would be to provide a `graded_submodule` method that returns a specially implemented `GradedSubmoduleWithBasis` class (as a subclass of `SubmoduleWithBasis`) that does all of this. This has the advantage of being explicit about the grading structure you want (the inherited one), not having to be very careful about adding the new category, and will likely be faster. It also means we don't have to add checks for homogeneity when someone might not want/need it.\n\nFor your immediate computational purposes, you can monkey patch in a degree by\n\n```python\ndef degree(self):\n    return self.lift().degree()\n```\nNote, as mentioned above, you have told the object that it is a graded module without specifying what the graded structure is. So this is a reasonable hack until a more long-term solution is implemented.\n\nThe situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.",
    "created_at": "2022-02-11T00:15:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538608",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:3" align="right">comment:3</div>

The current behavior is correct because there is no guarantee that an *arbitrary* submodule is spanned by homogeneous elements. For a simple example, take the submodule spanned by `f = 1 + x` in the polynomial ring with the natural degree grading. (There are more pathological examples for the counterarguments I can see for this.)

Now we could do something where we check to see if the spanning elements are homogeneous and then use the ambient grading. This then likely has a solution at the category level by creating the category of subobjects of graded modules with basis and graded modules (with basis). (Note as I argue above, this is a strict subcategory of subobjects of graded modules with basis.) This might be slightly subtle as, in principle, by saying an object is graded, you are suppose to specify what graded structure you want. Thus doing it automatically is perhaps not quite mathematically valid.

Perhaps the better solution would be to provide a `graded_submodule` method that returns a specially implemented `GradedSubmoduleWithBasis` class (as a subclass of `SubmoduleWithBasis`) that does all of this. This has the advantage of being explicit about the grading structure you want (the inherited one), not having to be very careful about adding the new category, and will likely be faster. It also means we don't have to add checks for homogeneity when someone might not want/need it.

For your immediate computational purposes, you can monkey patch in a degree by

```python
def degree(self):
    return self.lift().degree()
```
Note, as mentioned above, you have told the object that it is a graded module without specifying what the graded structure is. So this is a reasonable hack until a more long-term solution is implemented.

The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.



---

archive/issue_comments_538609.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\n+1 on developing it both for filtered and for graded modules",
    "created_at": "2022-02-11T02:13:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538609",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:4" align="right">comment:4</div>

+1 on developing it both for filtered and for graded modules



---

archive/issue_comments_538610.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nReplying to [@tscrim](#comment%3A3):\n> The current behavior is correct because there is no guarantee that an *arbitrary* submodule is spanned by homogeneous elements. For a simple example, take the submodule spanned by `f = 1 + x` in the polynomial ring with the natural degree grading. (There are more pathological examples for the counterarguments I can see for this.)\n> \n> Now we could do something where we check to see if the spanning elements are homogeneous and then use the ambient grading. This then likely has a solution at the category level by creating the category of subobjects of graded modules with basis and graded modules (with basis). (Note as I argue above, this is a strict subcategory of subobjects of graded modules with basis.) This might be slightly subtle as, in principle, by saying an object is graded, you are suppose to specify what graded structure you want. Thus doing it automatically is perhaps not quite mathematically valid.\n> \n> Perhaps the better solution would be to provide a `graded_submodule` method that returns a specially implemented `GradedSubmoduleWithBasis` class (as a subclass of `SubmoduleWithBasis`) that does all of this. This has the advantage of being explicit about the grading structure you want (the inherited one), not having to be very careful about adding the new category, and will likely be faster. It also means we don't have to add checks for homogeneity when someone might not want/need it.\n> \n> For your immediate computational purposes, you can monkey patch in a degree by\n> \n> ```python\n> def degree(self):\n>     return self.lift().degree()\n> ```\n> Note, as mentioned above, you have told the object that it is a graded module without specifying what the graded structure is. So this is a reasonable hack until a more long-term solution is implemented.\n> \n> The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.\n\n\nWould it make sense to use 'maximal_degree' for the grading for the submodule by default?",
    "created_at": "2022-02-12T01:47:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538610",
    "user": "https://github.com/louisng114"
}
```

<div id="comment:5" align="right">comment:5</div>

Replying to [@tscrim](#comment%3A3):
> The current behavior is correct because there is no guarantee that an *arbitrary* submodule is spanned by homogeneous elements. For a simple example, take the submodule spanned by `f = 1 + x` in the polynomial ring with the natural degree grading. (There are more pathological examples for the counterarguments I can see for this.)
> 
> Now we could do something where we check to see if the spanning elements are homogeneous and then use the ambient grading. This then likely has a solution at the category level by creating the category of subobjects of graded modules with basis and graded modules (with basis). (Note as I argue above, this is a strict subcategory of subobjects of graded modules with basis.) This might be slightly subtle as, in principle, by saying an object is graded, you are suppose to specify what graded structure you want. Thus doing it automatically is perhaps not quite mathematically valid.
> 
> Perhaps the better solution would be to provide a `graded_submodule` method that returns a specially implemented `GradedSubmoduleWithBasis` class (as a subclass of `SubmoduleWithBasis`) that does all of this. This has the advantage of being explicit about the grading structure you want (the inherited one), not having to be very careful about adding the new category, and will likely be faster. It also means we don't have to add checks for homogeneity when someone might not want/need it.
> 
> For your immediate computational purposes, you can monkey patch in a degree by
> 
> ```python
> def degree(self):
>     return self.lift().degree()
> ```
> Note, as mentioned above, you have told the object that it is a graded module without specifying what the graded structure is. So this is a reasonable hack until a more long-term solution is implemented.
> 
> The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.


Would it make sense to use 'maximal_degree' for the grading for the submodule by default?



---

archive/issue_comments_538611.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -13,4 +13,20 @@\n AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'\n ```\n \n-Ideally, the enhancement works for 'degree' and 'maximal degree'. It should also work for arbitrary layers of submoduling.\n+Ideally, a submodule of a filtered module/graded module should inherit degrees from its ambient by referencing 'maximal_degree' of its lifted image. The implementation should also work for arbitrary layers of submoduling. For example,\n+\n+```\n+sage: M = ModulesWithBasis(QQ).Graded().example()\n+sage: M(Partition((4,2,1,1,1,1))).degree()\n+10\n+sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))), M(Partition((4,2,1,1,1,1))) - M(Partition((4,3)))], category=GradedModulesWithBasis(QQ))\n+sage: n = N.basis()\n+sage: (n[0].degree(), n[1].degree())\n+(10, 10)\n+sage: f = n[0] - n[1]; f.degree()\n+8\n+sage: K = N.submodule([n[0]], category=GradedModulesWithBasis(QQ))\n+sage: k = K.basis()\n+sage: k[0].degree()\n+10\n+```\n``````\n",
    "created_at": "2022-02-12T02:23:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538611",
    "user": "https://github.com/louisng114"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -13,4 +13,20 @@
 AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'
 ```
 
-Ideally, the enhancement works for 'degree' and 'maximal degree'. It should also work for arbitrary layers of submoduling.
+Ideally, a submodule of a filtered module/graded module should inherit degrees from its ambient by referencing 'maximal_degree' of its lifted image. The implementation should also work for arbitrary layers of submoduling. For example,
+
+```
+sage: M = ModulesWithBasis(QQ).Graded().example()
+sage: M(Partition((4,2,1,1,1,1))).degree()
+10
+sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))), M(Partition((4,2,1,1,1,1))) - M(Partition((4,3)))], category=GradedModulesWithBasis(QQ))
+sage: n = N.basis()
+sage: (n[0].degree(), n[1].degree())
+(10, 10)
+sage: f = n[0] - n[1]; f.degree()
+8
+sage: K = N.submodule([n[0]], category=GradedModulesWithBasis(QQ))
+sage: k = K.basis()
+sage: k[0].degree()
+10
+```
``````




---

archive/issue_comments_538612.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nReplying to [@louisng114](#comment%3A5):\n> Replying to [@tscrim](#comment%3A3):\n> > The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.\n> \n> \n> \n> Would it make sense to use 'maximal_degree' for the grading for the submodule by default?\n\nNot for graded modules: take `1 / (1 - x)` in the ring of formal power series considered as a graded module by degree. There is no reasonable way to do this mathematically I believe.",
    "created_at": "2022-02-12T03:30:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538612",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:7" align="right">comment:7</div>

Replying to [@louisng114](#comment%3A5):
> Replying to [@tscrim](#comment%3A3):
> > The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.
> 
> 
> 
> Would it make sense to use 'maximal_degree' for the grading for the submodule by default?

Not for graded modules: take `1 / (1 - x)` in the ring of formal power series considered as a graded module by degree. There is no reasonable way to do this mathematically I believe.



---

archive/issue_comments_538613.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -13,20 +13,41 @@\n AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'\n ```\n \n-Ideally, a submodule of a filtered module/graded module should inherit degrees from its ambient by referencing 'maximal_degree' of its lifted image. The implementation should also work for arbitrary layers of submoduling. For example,\n+Want: In the case of the generators of the submodule being homogeneous in the original module, a submodule of a filtered module/graded module inherits degrees from its ambient. For example,\n \n ```\n sage: M = ModulesWithBasis(QQ).Graded().example()\n-sage: M(Partition((4,2,1,1,1,1))).degree()\n-10\n-sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))), M(Partition((4,2,1,1,1,1))) - M(Partition((4,3)))], category=GradedModulesWithBasis(QQ))\n+sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ))\n sage: n = N.basis()\n-sage: (n[0].degree(), n[1].degree())\n-(10, 10)\n-sage: f = n[0] - n[1]; f.degree()\n-8\n-sage: K = N.submodule([n[0]], category=GradedModulesWithBasis(QQ))\n-sage: k = K.basis()\n-sage: k[0].degree()\n+sage: n[0].degree()\n 10\n ```\n+\n+Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. For example,\n+\n+```\n+sage: M = ModulesWithBasis(QQ).Graded().example()\n+sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),\n+      M(Partition((5,3)))], category=GradedModulesWithBasis(QQ))\n+sage: n = N.basis()\n+sage: n[1].degree()\n+8\n+sage: n[0].degree()\n+Traceback (most recent call last):\n+...\n+ValueError: element is not homogeneous\n+sage: N(Partition((4,2,1,1,1,1))).degree()\n+10\n+```\n+\n+Want: If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `.submodule` and specifying a graded category. For example,\n+\n+```\n+sage: M = ModulesWithBasis(QQ).Graded().example()\n+sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),\n+      M(Partition((5,3)) - M(Partition((4,3)))], category=GradedModulesWithBasis(QQ))\n+Traceback (most recent call last):\n+...\n+ValueError: element is not homogeneous\n+```\n+\n``````\n",
    "created_at": "2022-02-12T22:20:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538613",
    "user": "https://github.com/louisng114"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -13,20 +13,41 @@
 AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'
 ```
 
-Ideally, a submodule of a filtered module/graded module should inherit degrees from its ambient by referencing 'maximal_degree' of its lifted image. The implementation should also work for arbitrary layers of submoduling. For example,
+Want: In the case of the generators of the submodule being homogeneous in the original module, a submodule of a filtered module/graded module inherits degrees from its ambient. For example,
 
 ```
 sage: M = ModulesWithBasis(QQ).Graded().example()
-sage: M(Partition((4,2,1,1,1,1))).degree()
-10
-sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))), M(Partition((4,2,1,1,1,1))) - M(Partition((4,3)))], category=GradedModulesWithBasis(QQ))
+sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ))
 sage: n = N.basis()
-sage: (n[0].degree(), n[1].degree())
-(10, 10)
-sage: f = n[0] - n[1]; f.degree()
-8
-sage: K = N.submodule([n[0]], category=GradedModulesWithBasis(QQ))
-sage: k = K.basis()
-sage: k[0].degree()
+sage: n[0].degree()
 10
 ```
+
+Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. For example,
+
+```
+sage: M = ModulesWithBasis(QQ).Graded().example()
+sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),
+      M(Partition((5,3)))], category=GradedModulesWithBasis(QQ))
+sage: n = N.basis()
+sage: n[1].degree()
+8
+sage: n[0].degree()
+Traceback (most recent call last):
+...
+ValueError: element is not homogeneous
+sage: N(Partition((4,2,1,1,1,1))).degree()
+10
+```
+
+Want: If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `.submodule` and specifying a graded category. For example,
+
+```
+sage: M = ModulesWithBasis(QQ).Graded().example()
+sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),
+      M(Partition((5,3)) - M(Partition((4,3)))], category=GradedModulesWithBasis(QQ))
+Traceback (most recent call last):
+...
+ValueError: element is not homogeneous
+```
+
``````




---

archive/issue_comments_538614.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nI am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.",
    "created_at": "2022-02-12T23:42:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538614",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:9" align="right">comment:9</div>

I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.



---

archive/issue_comments_538615.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nReplying to [@tscrim](#comment%3A9):\n> I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.\n\nBut this is only for when we specify the category of the submodule to be graded.",
    "created_at": "2022-02-13T18:08:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538615",
    "user": "https://github.com/louisng114"
}
```

<div id="comment:10" align="right">comment:10</div>

Replying to [@tscrim](#comment%3A9):
> I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.

But this is only for when we specify the category of the submodule to be graded.



---

archive/issue_comments_538616.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nReplying to [@louisng114](#comment%3A10):\n> Replying to [@tscrim](#comment%3A9):\n> > I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.\n> \n> \n> But this is only for when we specify the category of the submodule to be graded.\n\nStill -1 because passing that category means I am promising to provide a grading, not have it inherited. Basically I could not create a submodue of nonhomogeneous elements that I provide a different grading to. Again, it does not make sense mathematically to do this. Thinking about how it would be coded further reinforces that to me. It also makes it easier to construct the object you want as you don't have to pass the category.\n\nFor free modules over a graded algebra, we also have different constructions if we want the module to be graded or not (although this was very recently merged #32505 and should appear in the next beta).",
    "created_at": "2022-02-13T23:24:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538616",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:11" align="right">comment:11</div>

Replying to [@louisng114](#comment%3A10):
> Replying to [@tscrim](#comment%3A9):
> > I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.
> 
> 
> But this is only for when we specify the category of the submodule to be graded.

Still -1 because passing that category means I am promising to provide a grading, not have it inherited. Basically I could not create a submodue of nonhomogeneous elements that I provide a different grading to. Again, it does not make sense mathematically to do this. Thinking about how it would be coded further reinforces that to me. It also makes it easier to construct the object you want as you don't have to pass the category.

For free modules over a graded algebra, we also have different constructions if we want the module to be graded or not (although this was very recently merged #32505 and should appear in the next beta).



---

archive/issue_comments_538617.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -13,41 +13,36 @@\n AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'\n ```\n \n-Want: In the case of the generators of the submodule being homogeneous in the original module, a submodule of a filtered module/graded module inherits degrees from its ambient. For example,\n+With the new methods `graded_submodule`, `graded_quotient_module`, `filtered_submodule`, and `filtered_quotient_module` in the branch, the user can create a submodule of a filtered module/graded module that inherits degrees from its ambient, given that each generator is homogeneous in the original module. For example,\n \n ```\n sage: M = ModulesWithBasis(QQ).Graded().example()\n-sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ))\n-sage: n = N.basis()\n+sage: N = M.graded_submodule([M(Partition((5,3))), M(Partition((4,2,1,1,1,1)))])\n+sage: n = N.basis(); n[0].lift()\n+P[4, 2, 1, 1, 1, 1]\n sage: n[0].degree()\n 10\n-```\n-\n-Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. For example,\n-\n-```\n-sage: M = ModulesWithBasis(QQ).Graded().example()\n-sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),\n-      M(Partition((5,3)))], category=GradedModulesWithBasis(QQ))\n-sage: n = N.basis()\n-sage: n[1].degree()\n-8\n-sage: n[0].degree()\n-Traceback (most recent call last):\n-...\n-ValueError: element is not homogeneous\n-sage: N(Partition((4,2,1,1,1,1))).degree()\n-10\n-```\n-\n-Want: If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `.submodule` and specifying a graded category. For example,\n-\n-```\n-sage: M = ModulesWithBasis(QQ).Graded().example()\n-sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),\n-      M(Partition((5,3)) - M(Partition((4,3)))], category=GradedModulesWithBasis(QQ))\n+sage: K = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3)))])\n Traceback (most recent call last):\n ...\n ValueError: element is not homogeneous\n ```\n \n+Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `graded_submodule`. For example,\n+\n+```\n+sage: M = ModulesWithBasis(QQ).Graded().example()\n+sage: N = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),\n+      M(Partition((5,3)))])\n+sage: n = N.basis()\n+sage: (n[0].lift(), n[1].lift())\n+(P[4, 2, 1, 1, 1, 1], P[5,3])\n+sage: (n[0].degree(), n[1].degree())\n+(10, 8)\n+sage: K = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),\n+      M(Partition((5,3)) - M(Partition((4,3)))])\n+Traceback (most recent call last):\n+...\n+ValueError: element is not homogeneous\n+```\n+\n``````\n",
    "created_at": "2022-02-26T19:29:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538617",
    "user": "https://github.com/louisng114"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -13,41 +13,36 @@
 AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'
 ```
 
-Want: In the case of the generators of the submodule being homogeneous in the original module, a submodule of a filtered module/graded module inherits degrees from its ambient. For example,
+With the new methods `graded_submodule`, `graded_quotient_module`, `filtered_submodule`, and `filtered_quotient_module` in the branch, the user can create a submodule of a filtered module/graded module that inherits degrees from its ambient, given that each generator is homogeneous in the original module. For example,
 
 ```
 sage: M = ModulesWithBasis(QQ).Graded().example()
-sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ))
-sage: n = N.basis()
+sage: N = M.graded_submodule([M(Partition((5,3))), M(Partition((4,2,1,1,1,1)))])
+sage: n = N.basis(); n[0].lift()
+P[4, 2, 1, 1, 1, 1]
 sage: n[0].degree()
 10
-```
-
-Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. For example,
-
-```
-sage: M = ModulesWithBasis(QQ).Graded().example()
-sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),
-      M(Partition((5,3)))], category=GradedModulesWithBasis(QQ))
-sage: n = N.basis()
-sage: n[1].degree()
-8
-sage: n[0].degree()
-Traceback (most recent call last):
-...
-ValueError: element is not homogeneous
-sage: N(Partition((4,2,1,1,1,1))).degree()
-10
-```
-
-Want: If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `.submodule` and specifying a graded category. For example,
-
-```
-sage: M = ModulesWithBasis(QQ).Graded().example()
-sage: N = M.submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),
-      M(Partition((5,3)) - M(Partition((4,3)))], category=GradedModulesWithBasis(QQ))
+sage: K = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3)))])
 Traceback (most recent call last):
 ...
 ValueError: element is not homogeneous
 ```
 
+Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `graded_submodule`. For example,
+
+```
+sage: M = ModulesWithBasis(QQ).Graded().example()
+sage: N = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),
+      M(Partition((5,3)))])
+sage: n = N.basis()
+sage: (n[0].lift(), n[1].lift())
+(P[4, 2, 1, 1, 1, 1], P[5,3])
+sage: (n[0].degree(), n[1].degree())
+(10, 8)
+sage: K = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),
+      M(Partition((5,3)) - M(Partition((4,3)))])
+Traceback (most recent call last):
+...
+ValueError: element is not homogeneous
+```
+
``````




---

archive/issue_comments_538618.json:
```json
{
    "body": "Branch: **[public/33321](https://github.com/sagemath/sagetrac-mirror/tree/public/33321)**",
    "created_at": "2022-02-26T19:29:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538618",
    "user": "https://github.com/louisng114"
}
```

Branch: **[public/33321](https://github.com/sagemath/sagetrac-mirror/tree/public/33321)**



---

archive/issue_comments_538619.json:
```json
{
    "body": "<div id=\"comment:12\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/cf788b3dca90accbe0c58c3d427e13f06c542441\"><code>cf788b3</code></a></td><td><code>removing unintentionally added method from another branch</code></td></tr></table>\n",
    "created_at": "2022-02-26T19:29:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538619",
    "user": "https://github.com/louisng114"
}
```

<div id="comment:12"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/cf788b3dca90accbe0c58c3d427e13f06c542441"><code>cf788b3</code></a></td><td><code>removing unintentionally added method from another branch</code></td></tr></table>




---

archive/issue_comments_538620.json:
```json
{
    "body": "Commit: **[`cf788b3`](https://github.com/sagemath/sagetrac-mirror/commit/cf788b3dca90accbe0c58c3d427e13f06c542441)**",
    "created_at": "2022-02-26T19:29:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538620",
    "user": "https://github.com/louisng114"
}
```

Commit: **[`cf788b3`](https://github.com/sagemath/sagetrac-mirror/commit/cf788b3dca90accbe0c58c3d427e13f06c542441)**



---

archive/issue_comments_538621.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nIn this docstring (and the next):\n\n```\n+        def filtered_submodule(self, gens):\n+            r\"\"\"\n+            Create a graded submodule by referencing the grading of\n+            ``self``. The generators have to be each homogeneous.\n```\nit should say \"filtered\". Is the condition of being homogeneous needed in this case?",
    "created_at": "2022-02-26T20:36:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538621",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:13" align="right">comment:13</div>

In this docstring (and the next):

```
+        def filtered_submodule(self, gens):
+            r"""
+            Create a graded submodule by referencing the grading of
+            ``self``. The generators have to be each homogeneous.
```
it should say "filtered". Is the condition of being homogeneous needed in this case?



---

archive/issue_comments_538622.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -13,7 +13,7 @@\n AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'\n ```\n \n-With the new methods `graded_submodule`, `graded_quotient_module`, `filtered_submodule`, and `filtered_quotient_module` in the branch, the user can create a submodule of a filtered module/graded module that inherits degrees from its ambient, given that each generator is homogeneous in the original module. For example,\n+With the new methods `graded_submodule` and `graded_quotient_module` in the branch, the user can create a submodule of a graded module that inherits degrees from its ambient, given that each generator is homogeneous in the original module through a new class. For example,\n \n ```\n sage: M = ModulesWithBasis(QQ).Graded().example()\n@@ -27,6 +27,8 @@\n ...\n ValueError: element is not homogeneous\n ```\n+\n+We will also let submodules of filtered modules know they are naturally filtered from the ambient module.\n \n Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `graded_submodule`. For example,\n \n``````\n",
    "created_at": "2022-02-27T00:22:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538622",
    "user": "https://github.com/tscrim"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -13,7 +13,7 @@
 AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'
 ```
 
-With the new methods `graded_submodule`, `graded_quotient_module`, `filtered_submodule`, and `filtered_quotient_module` in the branch, the user can create a submodule of a filtered module/graded module that inherits degrees from its ambient, given that each generator is homogeneous in the original module. For example,
+With the new methods `graded_submodule` and `graded_quotient_module` in the branch, the user can create a submodule of a graded module that inherits degrees from its ambient, given that each generator is homogeneous in the original module through a new class. For example,
 
 ```
 sage: M = ModulesWithBasis(QQ).Graded().example()
@@ -27,6 +27,8 @@
 ...
 ValueError: element is not homogeneous
 ```
+
+We will also let submodules of filtered modules know they are naturally filtered from the ambient module.
 
 Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `graded_submodule`. For example,
 
``````




---

archive/issue_comments_538623.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nYou have a contradiction: the category has a default grading and a special method saying inherit the grading. This is telling you that the category should *not* have the default grading. Let me again say that you need to create a separate *class* for the graded module and for filtered modules you can do this at the category level.\n\nHowever, I was thinking a bit more, and there is a subtle issue with my example in [comment:7](#comment%3A7). That is in the direct *product*, but the standard graded module is a direct *sum*. So there is a way to define a grading by the minimal or maximal degree of any element. However, because there are two incompatible ways of doing it, we should not do it in general for the graded case. A particular class/method is different than at the category level because you are explicitly saying \"I want this specific object in the category.\"\n\nNote that formal power series is still a *filtered* module. For filtered modules, there is a unique way to do this because for any `x` there is a *unique* minimal (or maximal for a descending filteration) index `i` such that `x \\in S_i`. Contrast this with the graded case.",
    "created_at": "2022-02-27T00:22:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538623",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:14" align="right">comment:14</div>

You have a contradiction: the category has a default grading and a special method saying inherit the grading. This is telling you that the category should *not* have the default grading. Let me again say that you need to create a separate *class* for the graded module and for filtered modules you can do this at the category level.

However, I was thinking a bit more, and there is a subtle issue with my example in [comment:7](#comment%3A7). That is in the direct *product*, but the standard graded module is a direct *sum*. So there is a way to define a grading by the minimal or maximal degree of any element. However, because there are two incompatible ways of doing it, we should not do it in general for the graded case. A particular class/method is different than at the category level because you are explicitly saying "I want this specific object in the category."

Note that formal power series is still a *filtered* module. For filtered modules, there is a unique way to do this because for any `x` there is a *unique* minimal (or maximal for a descending filteration) index `i` such that `x \in S_i`. Contrast this with the graded case.



---

archive/issue_events_454888.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2022-02-27T00:22:44Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "title_is": "Add class for graded submodules of a graded module",
    "title_was": "Compatibility of submodules and degree_on_basis",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454888"
}
```



---

archive/issue_comments_538624.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nReplying to [@tscrim](#comment%3A14):\n> You have a contradiction: the category has a default grading and a special method saying inherit the grading. This is telling you that the category should *not* have the default grading.\n\nYou are saying that a parent in the category of subobjects of graded modules is not necessarily graded as it is in Louis' code?",
    "created_at": "2022-02-27T01:04:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538624",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:15" align="right">comment:15</div>

Replying to [@tscrim](#comment%3A14):
> You have a contradiction: the category has a default grading and a special method saying inherit the grading. This is telling you that the category should *not* have the default grading.

You are saying that a parent in the category of subobjects of graded modules is not necessarily graded as it is in Louis' code?



---

archive/issue_comments_538625.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nIn the generic case, that is correct. Restricting to the homogeneously generated case, it is, but that is an additional restriction that would need an additional category. Although it is such a special case that IMO it is easier to understand and maintain as a particular parent class in the categories we already have.",
    "created_at": "2022-02-27T04:25:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538625",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:16" align="right">comment:16</div>

In the generic case, that is correct. Restricting to the homogeneously generated case, it is, but that is an additional restriction that would need an additional category. Although it is such a special case that IMO it is easier to understand and maintain as a particular parent class in the categories we already have.



---

archive/issue_comments_538626.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nWell, more precisely it is graded (since it is a direct sum), but not in a canonical way.",
    "created_at": "2022-02-27T04:26:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538626",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:17" align="right">comment:17</div>

Well, more precisely it is graded (since it is a direct sum), but not in a canonical way.



---

archive/issue_comments_538627.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nIsn't it the very definition of a graded submodule that the elements of the submodule have the same degree as upstairs?",
    "created_at": "2022-02-27T04:27:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538627",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:18" align="right">comment:18</div>

Isn't it the very definition of a graded submodule that the elements of the submodule have the same degree as upstairs?



---

archive/issue_comments_538628.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nI also don't know what you mean by \"generic\".",
    "created_at": "2022-02-27T04:27:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538628",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:19" align="right">comment:19</div>

I also don't know what you mean by "generic".



---

archive/issue_comments_538629.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nIn fact, I don't think there's such a thing as a graded submodule that cannot be generated by homogeneous generators.",
    "created_at": "2022-02-27T04:33:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538629",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:20" align="right">comment:20</div>

In fact, I don't think there's such a thing as a graded submodule that cannot be generated by homogeneous generators.



---

archive/issue_comments_538630.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nAs a concrete example, take a polynomial ring as a graded module over its ground ring. Then take the submodule spanned by 1 + x. This is a submodule that has 2 natural gradings (that also extends to rings), one where it has degree 0 (min deg) and the other has degree 1 (max deg). This is a graded submodule in the sense that it is a submodule and it is graded, but not one that respects the ambient space grading. This is a natural submodule to construct IMO and needs to be supported.\n\nHowever, I see the point you are making, and there seems to be an ambiguity in the definition. We need to be very precise about what category we are in. We need to allow the construction above, and so I would not want the subobjects of a graded category to have to respect the ambient grading. I think we should have an explicit hook when we want to have something that respects the ambient grading.",
    "created_at": "2022-02-27T04:55:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538630",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:21" align="right">comment:21</div>

As a concrete example, take a polynomial ring as a graded module over its ground ring. Then take the submodule spanned by 1 + x. This is a submodule that has 2 natural gradings (that also extends to rings), one where it has degree 0 (min deg) and the other has degree 1 (max deg). This is a graded submodule in the sense that it is a submodule and it is graded, but not one that respects the ambient space grading. This is a natural submodule to construct IMO and needs to be supported.

However, I see the point you are making, and there seems to be an ambiguity in the definition. We need to be very precise about what category we are in. We need to allow the construction above, and so I would not want the subobjects of a graded category to have to respect the ambient grading. I think we should have an explicit hook when we want to have something that respects the ambient grading.



---

archive/issue_comments_538631.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nReplying to [@tscrim](#comment%3A21):\n> [...] This is a graded submodule in the sense that it is a submodule and it is graded, but not one that respects the ambient space grading. This is a natural submodule to construct IMO \n\nYes, but it is in the join category of \"subobjects of modules with basis\" and \"graded modules\", not in the category that we're talking about.",
    "created_at": "2022-02-27T04:57:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538631",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:22" align="right">comment:22</div>

Replying to [@tscrim](#comment%3A21):
> [...] This is a graded submodule in the sense that it is a submodule and it is graded, but not one that respects the ambient space grading. This is a natural submodule to construct IMO 

Yes, but it is in the join category of "subobjects of modules with basis" and "graded modules", not in the category that we're talking about.



---

archive/issue_comments_538632.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nSo you are saying it is different than the subobjects of graded modules? This would be a very subtle point and not what I would expect by a submodule of a graded module.",
    "created_at": "2022-02-27T05:11:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538632",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:23" align="right">comment:23</div>

So you are saying it is different than the subobjects of graded modules? This would be a very subtle point and not what I would expect by a submodule of a graded module.



---

archive/issue_comments_538633.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nYes, your \"natural submodule\" is not a graded submodule. It is submodule that also happens to have a grading.",
    "created_at": "2022-02-27T05:18:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538633",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:24" align="right">comment:24</div>

Yes, your "natural submodule" is not a graded submodule. It is submodule that also happens to have a grading.



---

archive/issue_comments_538634.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nI am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods. Actually, it is sufficient to implement this for filtered modules.\n\nFor checking the homogeneity (after converted to an echelon basis), we can either trust the user is creating something that satisfies the conditions (which keeps the code very simple) or we override the `submodule` to also do this check when the category is a subcategory of `self.category().Subobjects()`.\n\nI think we should also override the `submodule` implementation for `FilteredModulesWithBasis` to make the category filtered by default since this is unambiguous.",
    "created_at": "2022-02-27T07:47:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538634",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:25" align="right">comment:25</div>

I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods. Actually, it is sufficient to implement this for filtered modules.

For checking the homogeneity (after converted to an echelon basis), we can either trust the user is creating something that satisfies the conditions (which keeps the code very simple) or we override the `submodule` to also do this check when the category is a subcategory of `self.category().Subobjects()`.

I think we should also override the `submodule` implementation for `FilteredModulesWithBasis` to make the category filtered by default since this is unambiguous.



---

archive/issue_comments_538635.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,10 +1,10 @@\n-Currently, submodules do not inherit grading from its ambient.\n+Currently, graded submodules do not inherit grading from its ambient:\n \n ```\n sage: M = ModulesWithBasis(QQ).Graded().example()\n sage: M(Partition((4,2,1,1,1,1))).degree()\n 10\n-sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ))\n+sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ).Subobjects())\n sage: n = N.basis()\n sage: n[0].degree()\n ---------------------------------------------------------------------------\n@@ -12,23 +12,8 @@\n ...\n AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'\n ```\n+We implement this by fulfilling the regressive category construction requirement for the `GradedModules().Subobjects()` category. We also do this for filtered modules (every submodule of a filtered module has a natural filtration inherited from the ambient module).\n \n-With the new methods `graded_submodule` and `graded_quotient_module` in the branch, the user can create a submodule of a graded module that inherits degrees from its ambient, given that each generator is homogeneous in the original module through a new class. For example,\n-\n-```\n-sage: M = ModulesWithBasis(QQ).Graded().example()\n-sage: N = M.graded_submodule([M(Partition((5,3))), M(Partition((4,2,1,1,1,1)))])\n-sage: n = N.basis(); n[0].lift()\n-P[4, 2, 1, 1, 1, 1]\n-sage: n[0].degree()\n-10\n-sage: K = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3)))])\n-Traceback (most recent call last):\n-...\n-ValueError: element is not homogeneous\n-```\n-\n-We will also let submodules of filtered modules know they are naturally filtered from the ambient module.\n \n Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `graded_submodule`. For example,\n \n``````\n",
    "created_at": "2022-02-27T07:47:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538635",
    "user": "https://github.com/tscrim"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,10 +1,10 @@
-Currently, submodules do not inherit grading from its ambient.
+Currently, graded submodules do not inherit grading from its ambient:
 
 ```
 sage: M = ModulesWithBasis(QQ).Graded().example()
 sage: M(Partition((4,2,1,1,1,1))).degree()
 10
-sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ))
+sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ).Subobjects())
 sage: n = N.basis()
 sage: n[0].degree()
 ---------------------------------------------------------------------------
@@ -12,23 +12,8 @@
 ...
 AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'
 ```
+We implement this by fulfilling the regressive category construction requirement for the `GradedModules().Subobjects()` category. We also do this for filtered modules (every submodule of a filtered module has a natural filtration inherited from the ambient module).
 
-With the new methods `graded_submodule` and `graded_quotient_module` in the branch, the user can create a submodule of a graded module that inherits degrees from its ambient, given that each generator is homogeneous in the original module through a new class. For example,
-
-```
-sage: M = ModulesWithBasis(QQ).Graded().example()
-sage: N = M.graded_submodule([M(Partition((5,3))), M(Partition((4,2,1,1,1,1)))])
-sage: n = N.basis(); n[0].lift()
-P[4, 2, 1, 1, 1, 1]
-sage: n[0].degree()
-10
-sage: K = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3)))])
-Traceback (most recent call last):
-...
-ValueError: element is not homogeneous
-```
-
-We will also let submodules of filtered modules know they are naturally filtered from the ambient module.
 
 Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `graded_submodule`. For example,
 
``````




---

archive/issue_comments_538636.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nWe should also document the definition of a subobject of a graded module is a graded module whose grading agrees with its ambient module.",
    "created_at": "2022-02-27T07:50:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538636",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:26" align="right">comment:26</div>

We should also document the definition of a subobject of a graded module is a graded module whose grading agrees with its ambient module.



---

archive/issue_comments_538637.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nReplying to [@tscrim](#comment%3A25):\n> I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. \n\nYes.\n\n> So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.\n\nI don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?\n\nAnd don't we still (I believe this was your earlier point) want to allow users to construct plain (non-graded) submodules of a module that happens to be graded?",
    "created_at": "2022-02-27T18:03:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538637",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:27" align="right">comment:27</div>

Replying to [@tscrim](#comment%3A25):
> I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. 

Yes.

> So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.

I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?

And don't we still (I believe this was your earlier point) want to allow users to construct plain (non-graded) submodules of a module that happens to be graded?



---

archive/issue_comments_538638.json:
```json
{
    "body": "<div id=\"comment:28\" align=\"right\">comment:28</div>\n\nReplying to [@mkoeppe](#comment%3A27):\n> Replying to [@tscrim](#comment%3A25):\n> > I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. \n> \n> \n> Yes.\n> \n> > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.\n> \n> \n> I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?\n\nYou can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Suobjects()`. These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves (or at least those where the generic implementations are sufficient). So I am being a bit more cautious here to clutter not the namespace so much.\n\n> And don't we still (I believe this was your earlier point) want to allow users to construct plain (non-graded) submodules of a module that happens to be graded?\n\nAs long as there is either no homogeneity enforced when the category is not `GradedModulesWithBasis(R).Subobjects()`, then this shouldn't be a problem. In fact, if we do override `GradedModulesWithBasis(R).submodule()`, we can return the filtered category when given inhomogeneous elements.",
    "created_at": "2022-02-28T00:21:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538638",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:28" align="right">comment:28</div>

Replying to [@mkoeppe](#comment%3A27):
> Replying to [@tscrim](#comment%3A25):
> > I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. 
> 
> 
> Yes.
> 
> > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.
> 
> 
> I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?

You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Suobjects()`. These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves (or at least those where the generic implementations are sufficient). So I am being a bit more cautious here to clutter not the namespace so much.

> And don't we still (I believe this was your earlier point) want to allow users to construct plain (non-graded) submodules of a module that happens to be graded?

As long as there is either no homogeneity enforced when the category is not `GradedModulesWithBasis(R).Subobjects()`, then this shouldn't be a problem. In fact, if we do override `GradedModulesWithBasis(R).submodule()`, we can return the filtered category when given inhomogeneous elements.



---

archive/issue_comments_538639.json:
```json
{
    "body": "<div id=\"comment:29\" align=\"right\">comment:29</div>\n\nAre there already examples of methods where a `category` argument can make the default category less specific, rather than more specific?",
    "created_at": "2022-02-28T02:38:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538639",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:29" align="right">comment:29</div>

Are there already examples of methods where a `category` argument can make the default category less specific, rather than more specific?



---

archive/issue_comments_538640.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nI am sure there are depending on how explicit you want. `Hom` would be an essential case, other examples could be the `radical` of a Hopf algebra (it looses the Hopf part, there are others like this) or `invariant_module` (loses the ring structure if the action is not by automorphisms), and `submodule` has always allowed this:\n\n```\nsage: SGA = SymmetricGroupAlgebra(QQ,3)\nsage: SGA.submodule([SGA.an_element()])\nFree module generated by {0} over Rational Field\nsage: _.category()\nJoin of Category of finite dimensional modules with basis over Rational Field\n and Category of vector spaces with basis over Rational Field\n and Category of subobjects of sets\n```\nIt is indirectly there by the center construction via `submodule` as the category needs to be passed.",
    "created_at": "2022-02-28T04:00:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538640",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:30" align="right">comment:30</div>

I am sure there are depending on how explicit you want. `Hom` would be an essential case, other examples could be the `radical` of a Hopf algebra (it looses the Hopf part, there are others like this) or `invariant_module` (loses the ring structure if the action is not by automorphisms), and `submodule` has always allowed this:

```
sage: SGA = SymmetricGroupAlgebra(QQ,3)
sage: SGA.submodule([SGA.an_element()])
Free module generated by {0} over Rational Field
sage: _.category()
Join of Category of finite dimensional modules with basis over Rational Field
 and Category of vector spaces with basis over Rational Field
 and Category of subobjects of sets
```
It is indirectly there by the center construction via `submodule` as the category needs to be passed.



---

archive/issue_comments_538641.json:
```json
{
    "body": "<div id=\"comment:31\" align=\"right\">comment:31</div>\n\nReplying to [@tscrim](#comment%3A28):\n> Replying to [@mkoeppe](#comment%3A27):\n> > Replying to [@tscrim](#comment%3A25):\n> > > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.\n> > \n> > \n> > I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?\n> \n> \n> You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Subobjects()`. \n\nCurrently, but we would change this default, right?\n\n> These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves \n\nOK, perhaps a way to think about this is that the word `submodule` indicates in what sense the resulting object is generated, not in what category it lies. \n\nSo if the object generated as a submodule happens to be a graded submodule (in the sense of the functorial construction of `GradedModulesWithBasis(R).Subobjects()`), we put it in that category.\n\nNow what if `self` is a `GradedAlgebraWithBasis(R)` and we call `submodule` on it, if the result happens to be a graded subalgebra (in the sense of its functorial construction), would we also be allowed to put it in that category?",
    "created_at": "2022-02-28T20:10:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538641",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:31" align="right">comment:31</div>

Replying to [@tscrim](#comment%3A28):
> Replying to [@mkoeppe](#comment%3A27):
> > Replying to [@tscrim](#comment%3A25):
> > > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.
> > 
> > 
> > I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?
> 
> 
> You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Subobjects()`. 

Currently, but we would change this default, right?

> These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves 

OK, perhaps a way to think about this is that the word `submodule` indicates in what sense the resulting object is generated, not in what category it lies. 

So if the object generated as a submodule happens to be a graded submodule (in the sense of the functorial construction of `GradedModulesWithBasis(R).Subobjects()`), we put it in that category.

Now what if `self` is a `GradedAlgebraWithBasis(R)` and we call `submodule` on it, if the result happens to be a graded subalgebra (in the sense of its functorial construction), would we also be allowed to put it in that category?



---

archive/issue_events_454889.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-02-28T20:25:59Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "title_is": "Implement GradedModulesWithBasis(R).Subobjects() and FilteredModulesWithBasis(R).Subobjects()",
    "title_was": "Add class for graded submodules of a graded module",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454889"
}
```



---

archive/issue_comments_538642.json:
```json
{
    "body": "<div id=\"comment:33\" align=\"right\">comment:33</div>\n\nReplying to [@mkoeppe](#comment%3A31):\n> Replying to [@tscrim](#comment%3A28):\n> > Replying to [@mkoeppe](#comment%3A27):\n> > > Replying to [@tscrim](#comment%3A25):\n> > > > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.\n> > > \n> > > \n> > > I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?\n> > \n> > \n> > You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Subobjects()`. \n> \n> \n> Currently, but we would change this default, right?\n\nOnly for those cases that it makes sense for:\n\n- Submodules of filtered modules are naturally filtered.\n- Possibly submodules of graded modules generated by homogeneous elements are naturally graded.\n\n> > These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves \n> \n> \n> OK, perhaps a way to think about this is that the word `submodule` indicates in what sense the resulting object is generated, not in what category it lies. \n> \n> So if the object generated as a submodule happens to be a graded submodule (in the sense of the functorial construction of `GradedModulesWithBasis(R).Subobjects()`), we put it in that category.\n\nYes to both. That's what I am now proposing, which was one of Louis's earlier suggestions.\n\n> Now what if `self` is a `GradedAlgebraWithBasis(R)` and we call `submodule` on it, if the result happens to be a graded subalgebra (in the sense of its functorial construction), would we also be allowed to put it in that category?\n\nDefinitely if no category is specified. I am not sure it is worth the code complexity and CPU cycles to verify the user has given us good input by checking the passed category is a subcategory and the homogeneity.",
    "created_at": "2022-03-01T00:30:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538642",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:33" align="right">comment:33</div>

Replying to [@mkoeppe](#comment%3A31):
> Replying to [@tscrim](#comment%3A28):
> > Replying to [@mkoeppe](#comment%3A27):
> > > Replying to [@tscrim](#comment%3A25):
> > > > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.
> > > 
> > > 
> > > I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?
> > 
> > 
> > You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Subobjects()`. 
> 
> 
> Currently, but we would change this default, right?

Only for those cases that it makes sense for:

- Submodules of filtered modules are naturally filtered.
- Possibly submodules of graded modules generated by homogeneous elements are naturally graded.

> > These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves 
> 
> 
> OK, perhaps a way to think about this is that the word `submodule` indicates in what sense the resulting object is generated, not in what category it lies. 
> 
> So if the object generated as a submodule happens to be a graded submodule (in the sense of the functorial construction of `GradedModulesWithBasis(R).Subobjects()`), we put it in that category.

Yes to both. That's what I am now proposing, which was one of Louis's earlier suggestions.

> Now what if `self` is a `GradedAlgebraWithBasis(R)` and we call `submodule` on it, if the result happens to be a graded subalgebra (in the sense of its functorial construction), would we also be allowed to put it in that category?

Definitely if no category is specified. I am not sure it is worth the code complexity and CPU cycles to verify the user has given us good input by checking the passed category is a subcategory and the homogeneity.



---

archive/issue_comments_538643.json:
```json
{
    "body": "<div id=\"comment:34\" align=\"right\">comment:34</div>\n\nI am cc-ing John in case he has any thoughts or opinions on this since he works a lot with graded modules I believe.",
    "created_at": "2022-03-01T00:32:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538643",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:34" align="right">comment:34</div>

I am cc-ing John in case he has any thoughts or opinions on this since he works a lot with graded modules I believe.



---

archive/issue_comments_538644.json:
```json
{
    "body": "<div id=\"comment:35\" align=\"right\">comment:35</div>\n\nI'm not sure I can process all of the discussion right now, but given that disclaimer, here is my take: if you are explicitly working with an instance of `ModulesWithBasis(QQ).Graded()` and ask for a submodule, then you are in a graded setting and the submodule should be graded. (Should the code test for that or just assume that it's okay? I don't know.) Mathematically if you want to define the submodule of `k[x]` generated by `1+x`, then you should apply a forgetful functor to pass to the category of ungraded modules first, and then define the submodule. Within Sage, I think the process in the previous sentence should be explicit: if you want to define the submodule generated by `1+x`, you need to explicitly say that you are not going work in the graded setting any more.\n\nI think this is consistent with the recent comments.",
    "created_at": "2022-03-01T19:28:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538644",
    "user": "https://github.com/jhpalmieri"
}
```

<div id="comment:35" align="right">comment:35</div>

I'm not sure I can process all of the discussion right now, but given that disclaimer, here is my take: if you are explicitly working with an instance of `ModulesWithBasis(QQ).Graded()` and ask for a submodule, then you are in a graded setting and the submodule should be graded. (Should the code test for that or just assume that it's okay? I don't know.) Mathematically if you want to define the submodule of `k[x]` generated by `1+x`, then you should apply a forgetful functor to pass to the category of ungraded modules first, and then define the submodule. Within Sage, I think the process in the previous sentence should be explicit: if you want to define the submodule generated by `1+x`, you need to explicitly say that you are not going work in the graded setting any more.

I think this is consistent with the recent comments.



---

archive/issue_comments_538645.json:
```json
{
    "body": "<div id=\"comment:36\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ef0227c3487e98eb8fbfc2e893a563ea3f9f0930\"><code>ef0227c</code></a></td><td><code>Merge branch 'public/33321' of git://trac.sagemath.org/sage into public/33321</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/edc6a03afdc309aa29117d944d33f79bb7d52703\"><code>edc6a03</code></a></td><td><code>Support for graded submodules and quotients of graded modules.</code></td></tr></table>\n",
    "created_at": "2022-03-02T02:00:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538645",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:36"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ef0227c3487e98eb8fbfc2e893a563ea3f9f0930"><code>ef0227c</code></a></td><td><code>Merge branch 'public/33321' of git://trac.sagemath.org/sage into public/33321</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/edc6a03afdc309aa29117d944d33f79bb7d52703"><code>edc6a03</code></a></td><td><code>Support for graded submodules and quotients of graded modules.</code></td></tr></table>




---

archive/issue_comments_538646.json:
```json
{
    "body": "Changed commit from **[`cf788b3`](https://github.com/sagemath/sagetrac-mirror/commit/cf788b3dca90accbe0c58c3d427e13f06c542441)** to **[`edc6a03`](https://github.com/sagemath/sagetrac-mirror/commit/edc6a03afdc309aa29117d944d33f79bb7d52703)**",
    "created_at": "2022-03-02T02:00:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538646",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`cf788b3`](https://github.com/sagemath/sagetrac-mirror/commit/cf788b3dca90accbe0c58c3d427e13f06c542441)** to **[`edc6a03`](https://github.com/sagemath/sagetrac-mirror/commit/edc6a03afdc309aa29117d944d33f79bb7d52703)**



---

archive/issue_comments_538647.json:
```json
{
    "body": "<div id=\"comment:37\" align=\"right\">comment:37</div>\n\nHere is my proposal based upon our discussion. I decided to let the specified category override the filtered default in case someone wants to consider the object without the filtration (say, for doing morphisms). I also extended the allowed input for `echelon_form` and `submodule` so it was more natural. I also wasn't completely sure for the filtered quotients, so I just left that alone and only did things for graded modules.",
    "created_at": "2022-03-02T02:05:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538647",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:37" align="right">comment:37</div>

Here is my proposal based upon our discussion. I decided to let the specified category override the filtered default in case someone wants to consider the object without the filtration (say, for doing morphisms). I also extended the allowed input for `echelon_form` and `submodule` so it was more natural. I also wasn't completely sure for the filtered quotients, so I just left that alone and only did things for graded modules.



---

archive/issue_comments_538648.json:
```json
{
    "body": "Author: **Louis Ng, Travis Scrimshaw**",
    "created_at": "2022-03-02T02:05:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538648",
    "user": "https://github.com/tscrim"
}
```

Author: **Louis Ng, Travis Scrimshaw**



---

archive/issue_events_454890.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2022-03-02T02:05:52Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454890"
}
```



---

archive/issue_comments_538649.json:
```json
{
    "body": "<div id=\"comment:38\" align=\"right\">comment:38</div>\n\nGreat!\n\nIn this doctest:\n\n```\nIf ``category`` is specified, then it does not give any extra\n+            structure to the submodule (we can think of this as applying\n+            the forgetful functor)::\n+\n+                sage: SM = E.submodule([x + y, x*y - y*z], category=ModulesWithBasis(QQ))\n+                sage: SM.category()\n+                Join of Category of finite dimensional modules with basis over Rational Field\n+                 and Category of vector spaces with basis over Rational Field\n+                 and Category of subobjects of sets\n+                sage: FM = E.submodule([x + 1, x*y - x*y*z], category=ModulesWithBasis(QQ))\n+                sage: FM.category()\n+                Join of Category of finite dimensional modules with basis over Rational Field\n+                 and Category of vector spaces with basis over Rational Field\n+                 and Category of subobjects of sets\n+\n```\n\nit looks like the category is not quite right yet. Apart from the confusion with \"Join of ... finite-dimensional modules, vector spaces\" that is unrelated to this ticket, shouldn't it be at least in the category of subobjects of modules?",
    "created_at": "2022-03-02T02:29:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538649",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:38" align="right">comment:38</div>

Great!

In this doctest:

```
If ``category`` is specified, then it does not give any extra
+            structure to the submodule (we can think of this as applying
+            the forgetful functor)::
+
+                sage: SM = E.submodule([x + y, x*y - y*z], category=ModulesWithBasis(QQ))
+                sage: SM.category()
+                Join of Category of finite dimensional modules with basis over Rational Field
+                 and Category of vector spaces with basis over Rational Field
+                 and Category of subobjects of sets
+                sage: FM = E.submodule([x + 1, x*y - x*y*z], category=ModulesWithBasis(QQ))
+                sage: FM.category()
+                Join of Category of finite dimensional modules with basis over Rational Field
+                 and Category of vector spaces with basis over Rational Field
+                 and Category of subobjects of sets
+
```

it looks like the category is not quite right yet. Apart from the confusion with "Join of ... finite-dimensional modules, vector spaces" that is unrelated to this ticket, shouldn't it be at least in the category of subobjects of modules?



---

archive/issue_comments_538650.json:
```json
{
    "body": "<div id=\"comment:39\" align=\"right\">comment:39</div>\n\nThe subobjects of modules is the join of subobjects of sets and vector spaces. We just do not have that specific category defined (hence the join of those two). Likewise for adding the finite dimensional axiom. I added this doctest to show that it does not automatically inherent the graded/filtered structure when the category passed does not include it.",
    "created_at": "2022-03-02T03:39:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538650",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:39" align="right">comment:39</div>

The subobjects of modules is the join of subobjects of sets and vector spaces. We just do not have that specific category defined (hence the join of those two). Likewise for adding the finite dimensional axiom. I added this doctest to show that it does not automatically inherent the graded/filtered structure when the category passed does not include it.



---

archive/issue_comments_538651.json:
```json
{
    "body": "<div id=\"comment:40\" align=\"right\">comment:40</div>\n\nReplying to [@tscrim](#comment%3A39):\n> The subobjects of modules is the join of subobjects of sets and vector spaces. We just do not have that specific category defined (hence the join of those two).\n\nOK, that makes sense.",
    "created_at": "2022-03-02T03:47:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538651",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:40" align="right">comment:40</div>

Replying to [@tscrim](#comment%3A39):
> The subobjects of modules is the join of subobjects of sets and vector spaces. We just do not have that specific category defined (hence the join of those two).

OK, that makes sense.



---

archive/issue_events_454891.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2022-03-02T03:54:26Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454891"
}
```



---

archive/issue_events_454892.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2022-03-02T03:54:26Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454892"
}
```



---

archive/issue_comments_538652.json:
```json
{
    "body": "<div id=\"comment:41\" align=\"right\">comment:41</div>\n\n\n```\nsage -t --long src/sage/graphs/graph.py  # 1 doctest failed\nsage -t --long src/sage/combinat/sf/k_dual.py  # 1 doctest failed\nsage -t --long src/sage/combinat/sf/new_kschur.py  # 1 doctest failed\nsage -t --long src/sage/matrix/matrix_space.py  # 4 doctests failed\nsage -t --long src/sage/algebras/orlik_terao.py  # 21 doctests failed\nsage -t --long src/sage/matroids/matroid.pyx  # 4 doctests failed\nsage -t --long src/sage/categories/modules_with_basis.py  # 5 doctests failed\nsage -t --long src/sage/algebras/orlik_solomon.py  # 30 doctests failed\nsage -t --long src/sage/matroids/linear_matroid.pyx  # 4 doctests failed\nsage -t --long src/sage/categories/filtered_modules_with_basis.py  # 2 doctests failed\nsage -t --long src/sage/categories/graded_modules_with_basis.py  # 6 doctests failed\n```\nThere are a number of trivial doctest failures that I will need to fix from the change in categories. However, some non-trivial ones from the invariant rings of Orlik-!Solomon/Terao algebras from the input-standardization change. I will have to look more closely. (The `graph.py` failure is unrelated IIRC.)",
    "created_at": "2022-03-02T03:54:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538652",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:41" align="right">comment:41</div>


```
sage -t --long src/sage/graphs/graph.py  # 1 doctest failed
sage -t --long src/sage/combinat/sf/k_dual.py  # 1 doctest failed
sage -t --long src/sage/combinat/sf/new_kschur.py  # 1 doctest failed
sage -t --long src/sage/matrix/matrix_space.py  # 4 doctests failed
sage -t --long src/sage/algebras/orlik_terao.py  # 21 doctests failed
sage -t --long src/sage/matroids/matroid.pyx  # 4 doctests failed
sage -t --long src/sage/categories/modules_with_basis.py  # 5 doctests failed
sage -t --long src/sage/algebras/orlik_solomon.py  # 30 doctests failed
sage -t --long src/sage/matroids/linear_matroid.pyx  # 4 doctests failed
sage -t --long src/sage/categories/filtered_modules_with_basis.py  # 2 doctests failed
sage -t --long src/sage/categories/graded_modules_with_basis.py  # 6 doctests failed
```
There are a number of trivial doctest failures that I will need to fix from the change in categories. However, some non-trivial ones from the invariant rings of Orlik-!Solomon/Terao algebras from the input-standardization change. I will have to look more closely. (The `graph.py` failure is unrelated IIRC.)



---

archive/issue_comments_538653.json:
```json
{
    "body": "Changed commit from **[`edc6a03`](https://github.com/sagemath/sagetrac-mirror/commit/edc6a03afdc309aa29117d944d33f79bb7d52703)** to **[`0d93b11`](https://github.com/sagemath/sagetrac-mirror/commit/0d93b119838e81b6aa8ab850b936074f7bee59b8)**",
    "created_at": "2022-03-02T06:52:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538653",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`edc6a03`](https://github.com/sagemath/sagetrac-mirror/commit/edc6a03afdc309aa29117d944d33f79bb7d52703)** to **[`0d93b11`](https://github.com/sagemath/sagetrac-mirror/commit/0d93b119838e81b6aa8ab850b936074f7bee59b8)**



---

archive/issue_comments_538654.json:
```json
{
    "body": "<div id=\"comment:42\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/73660b48bef663f361a8cd9ff3f20d92f35f808e\"><code>73660b4</code></a></td><td><code>Remove unnecessary filtered_* methods; fixing submodule gens Family input.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6a3b6bf4720220830021ed9277ff6789bef28e09\"><code>6a3b6bf</code></a></td><td><code>Correcting one doctest and trivial output updates.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0d93b119838e81b6aa8ab850b936074f7bee59b8\"><code>0d93b11</code></a></td><td><code>Change doctest to work around MRO resolution in matrix_space.py file.</code></td></tr></table>\n",
    "created_at": "2022-03-02T06:52:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538654",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:42"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/73660b48bef663f361a8cd9ff3f20d92f35f808e"><code>73660b4</code></a></td><td><code>Remove unnecessary filtered_* methods; fixing submodule gens Family input.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6a3b6bf4720220830021ed9277ff6789bef28e09"><code>6a3b6bf</code></a></td><td><code>Correcting one doctest and trivial output updates.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0d93b119838e81b6aa8ab850b936074f7bee59b8"><code>0d93b11</code></a></td><td><code>Change doctest to work around MRO resolution in matrix_space.py file.</code></td></tr></table>




---

archive/issue_comments_538655.json:
```json
{
    "body": "<div id=\"comment:43\" align=\"right\">comment:43</div>\n\nI fixed the bug, which came down to not getting the correct type for the generator input to `submodule`.\n\nMost of the other doctests are trivial updating. I think there are some new doctests added since beta1 (which is what I am currently using to work on this branch) to update. I still need to do that, which I probably won't do until tomorrow. However, two notable changes:\n\n- I believe the change in `modules_with_basis.py` was needed from a doctest copy/paste that was not fully updated. I think that kind of input is an abuse and the user should explicitly change the ring of the element as there is no, a priori, relation between the two modules.\n- The change of the base ring of `Sym` in `matrix_space.py` is because I was getting an unable-to-resolve-MRO issue that I could not reproduce in a more isolated example:\n\n  ```\n  TypeError: Cannot create a consistent method resolution order (MRO) for bases\n   VectorSpaces.subcategory_class, GradedModules.subcategory_class\n  ```\n  This doesn't change the content of that doctest, but allows us to continue to sidestep this MRO resolution issue (see, e.g., #22962).",
    "created_at": "2022-03-02T07:08:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538655",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:43" align="right">comment:43</div>

I fixed the bug, which came down to not getting the correct type for the generator input to `submodule`.

Most of the other doctests are trivial updating. I think there are some new doctests added since beta1 (which is what I am currently using to work on this branch) to update. I still need to do that, which I probably won't do until tomorrow. However, two notable changes:

- I believe the change in `modules_with_basis.py` was needed from a doctest copy/paste that was not fully updated. I think that kind of input is an abuse and the user should explicitly change the ring of the element as there is no, a priori, relation between the two modules.
- The change of the base ring of `Sym` in `matrix_space.py` is because I was getting an unable-to-resolve-MRO issue that I could not reproduce in a more isolated example:

  ```
  TypeError: Cannot create a consistent method resolution order (MRO) for bases
   VectorSpaces.subcategory_class, GradedModules.subcategory_class
  ```
  This doesn't change the content of that doctest, but allows us to continue to sidestep this MRO resolution issue (see, e.g., #22962).



---

archive/issue_comments_538656.json:
```json
{
    "body": "<div id=\"comment:44\" align=\"right\">comment:44</div>\n\nReplying to [@tscrim](#comment%3A43):\n> - I believe the change in `modules_with_basis.py` was needed from a doctest copy/paste that was not fully updated. \n\nYes, I agree",
    "created_at": "2022-03-02T07:26:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538656",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:44" align="right">comment:44</div>

Replying to [@tscrim](#comment%3A43):
> - I believe the change in `modules_with_basis.py` was needed from a doctest copy/paste that was not fully updated. 

Yes, I agree



---

archive/issue_comments_538657.json:
```json
{
    "body": "Changed commit from **[`0d93b11`](https://github.com/sagemath/sagetrac-mirror/commit/0d93b119838e81b6aa8ab850b936074f7bee59b8)** to **[`e5901b5`](https://github.com/sagemath/sagetrac-mirror/commit/e5901b5a8e651e555418dfe96f357af960b33acc)**",
    "created_at": "2022-03-04T07:17:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538657",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`0d93b11`](https://github.com/sagemath/sagetrac-mirror/commit/0d93b119838e81b6aa8ab850b936074f7bee59b8)** to **[`e5901b5`](https://github.com/sagemath/sagetrac-mirror/commit/e5901b5a8e651e555418dfe96f357af960b33acc)**



---

archive/issue_comments_538658.json:
```json
{
    "body": "<div id=\"comment:45\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fe7924ffa396a564861bbafbbeaac4d8c3820562\"><code>fe7924f</code></a></td><td><code>Merge branch 'public/33321' of https://github.com/sagemath/sagetrac-mirror into public/33321</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e5901b5a8e651e555418dfe96f357af960b33acc\"><code>e5901b5</code></a></td><td><code>Fixing doctest output from category changes.</code></td></tr></table>\n",
    "created_at": "2022-03-04T07:17:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538658",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:45"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fe7924ffa396a564861bbafbbeaac4d8c3820562"><code>fe7924f</code></a></td><td><code>Merge branch 'public/33321' of https://github.com/sagemath/sagetrac-mirror into public/33321</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e5901b5a8e651e555418dfe96f357af960b33acc"><code>e5901b5</code></a></td><td><code>Fixing doctest output from category changes.</code></td></tr></table>




---

archive/issue_comments_538659.json:
```json
{
    "body": "<div id=\"comment:46\" align=\"right\">comment:46</div>\n\nHere are the fixes.",
    "created_at": "2022-03-04T07:19:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538659",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:46" align="right">comment:46</div>

Here are the fixes.



---

archive/issue_events_454893.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2022-03-04T07:19:17Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454893"
}
```



---

archive/issue_events_454894.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2022-03-04T07:19:17Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454894"
}
```



---

archive/issue_comments_538660.json:
```json
{
    "body": "<div id=\"comment:47\" align=\"right\">comment:47</div>\n\nBot was morally green using beta3 and passes all tests (other than known failures) run on my machine for beta4.",
    "created_at": "2022-03-09T07:56:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538660",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:47" align="right">comment:47</div>

Bot was morally green using beta3 and passes all tests (other than known failures) run on my machine for beta4.



---

archive/issue_comments_538661.json:
```json
{
    "body": "<div id=\"comment:48\" align=\"right\">comment:48</div>\n\nLooks good to me. Refinements and generalizations can be done in follow-up tickets. Thanks for this work!",
    "created_at": "2022-03-09T18:14:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538661",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:48" align="right">comment:48</div>

Looks good to me. Refinements and generalizations can be done in follow-up tickets. Thanks for this work!



---

archive/issue_events_454895.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-09T18:14:44Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454895"
}
```



---

archive/issue_events_454896.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-09T18:14:44Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454896"
}
```



---

archive/issue_comments_538662.json:
```json
{
    "body": "Reviewer: **Matthias Koeppe**",
    "created_at": "2022-03-09T18:14:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538662",
    "user": "https://github.com/mkoeppe"
}
```

Reviewer: **Matthias Koeppe**



---

archive/issue_comments_538663.json:
```json
{
    "body": "<div id=\"comment:49\" align=\"right\">comment:49</div>\n\nThank you.\n\nI hope this also works for the application you have in mind Louis. If not or if you have other questions, feel free to email me directly to discuss things further.",
    "created_at": "2022-03-09T23:23:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538663",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:49" align="right">comment:49</div>

Thank you.

I hope this also works for the application you have in mind Louis. If not or if you have other questions, feel free to email me directly to discuss things further.



---

archive/issue_events_454897.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2022-03-12T15:11:08Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454897"
}
```



---

archive/issue_events_454898.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "ca4f346d209ee3ea752682ab04e45ec1c5d2c367",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2022-03-12T15:11:08Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/33321#event-454898"
}
```



---

archive/issue_comments_538664.json:
```json
{
    "body": "Changed branch from **[public/33321](https://github.com/sagemath/sagetrac-mirror/tree/public/33321)** to **[`e5901b5`](https://github.com/sagemath/sagetrac-mirror/commit/e5901b5a8e651e555418dfe96f357af960b33acc)**",
    "created_at": "2022-03-12T15:11:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/33321#issuecomment-538664",
    "user": "https://github.com/vbraun"
}
```

Changed branch from **[public/33321](https://github.com/sagemath/sagetrac-mirror/tree/public/33321)** to **[`e5901b5`](https://github.com/sagemath/sagetrac-mirror/commit/e5901b5a8e651e555418dfe96f357af960b33acc)**
