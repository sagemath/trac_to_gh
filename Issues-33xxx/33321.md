# Issue 33321: Implement GradedModulesWithBasis(R).Subobjects() and FilteredModulesWithBasis(R).Subobjects()

archive/issues_033084.json:
```json
{
    "body": "Currently, graded submodules do not inherit grading from its ambient:\n\n```\nsage: M = ModulesWithBasis(QQ).Graded().example()\nsage: M(Partition((4,2,1,1,1,1))).degree()\n10\nsage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ).Subobjects())\nsage: n = N.basis()\nsage: n[0].degree()\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n...\nAttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'\n```\nWe implement this by fulfilling the regressive category construction requirement for the `GradedModules().Subobjects()` category. We also do this for filtered modules (every submodule of a filtered module has a natural filtration inherited from the ambient module).\n\n\nWant: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `graded_submodule`. For example,\n\n```\nsage: M = ModulesWithBasis(QQ).Graded().example()\nsage: N = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),\n      M(Partition((5,3)))])\nsage: n = N.basis()\nsage: (n[0].lift(), n[1].lift())\n(P[4, 2, 1, 1, 1, 1], P[5,3])\nsage: (n[0].degree(), n[1].degree())\n(10, 8)\nsage: K = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),\n      M(Partition((5,3)) - M(Partition((4,3)))])\nTraceback (most recent call last):\n...\nValueError: element is not homogeneous\n```\n\n\nCC:  @mkoeppe @tscrim @jhpalmieri\n\nKeywords: submodule\n\nReviewer: Matthias Koeppe\n\nAuthor: Louis Ng, Travis Scrimshaw\n\nBranch: e5901b5a8e651e555418dfe96f357af960b33acc\n\nCommit: e5901b5a8e651e555418dfe96f357af960b33acc\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/33321\n\n",
    "closed_at": "2022-03-12T15:11:08Z",
    "created_at": "2022-02-10T18:29:38Z",
    "labels": [
        "component: categories"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.6",
    "title": "Implement GradedModulesWithBasis(R).Subobjects() and FilteredModulesWithBasis(R).Subobjects()",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/33321",
    "user": "https://github.com/louisng114"
}
```
Currently, graded submodules do not inherit grading from its ambient:

```
sage: M = ModulesWithBasis(QQ).Graded().example()
sage: M(Partition((4,2,1,1,1,1))).degree()
10
sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ).Subobjects())
sage: n = N.basis()
sage: n[0].degree()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
...
AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'
```
We implement this by fulfilling the regressive category construction requirement for the `GradedModules().Subobjects()` category. We also do this for filtered modules (every submodule of a filtered module has a natural filtration inherited from the ambient module).


Want: In the case where the generators are not from homogeneous but can made homogeneous by row reducing, it inherits its degrees. If the basis elements cannot be made homogeneous by row reduction, raise an error when trying to use `graded_submodule`. For example,

```
sage: M = ModulesWithBasis(QQ).Graded().example()
sage: N = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),
      M(Partition((5,3)))])
sage: n = N.basis()
sage: (n[0].lift(), n[1].lift())
(P[4, 2, 1, 1, 1, 1], P[5,3])
sage: (n[0].degree(), n[1].degree())
(10, 8)
sage: K = M.graded_submodule([M(Partition((4,2,1,1,1,1))) - M(Partition((5,3))),
      M(Partition((5,3)) - M(Partition((4,3)))])
Traceback (most recent call last):
...
ValueError: element is not homogeneous
```


CC:  @mkoeppe @tscrim @jhpalmieri

Keywords: submodule

Reviewer: Matthias Koeppe

Author: Louis Ng, Travis Scrimshaw

Branch: e5901b5a8e651e555418dfe96f357af960b33acc

Commit: e5901b5a8e651e555418dfe96f357af960b33acc

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/33321





---

archive/issue_comments_471096.json:
```json
{
    "body": "<a id='comment:2'></a>Can you please add some examples that illustrate what you would like to happen? \nShould submodules of graded modules always/sometimes/never be graded by default?",
    "created_at": "2022-02-10T21:23:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471096",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:2'></a>Can you please add some examples that illustrate what you would like to happen? 
Should submodules of graded modules always/sometimes/never be graded by default?



---

archive/issue_comments_471097.json:
```json
{
    "body": "<a id='comment:3'></a>The current behavior is correct because there is no guarantee that an *arbitrary* submodule is spanned by homogeneous elements. For a simple example, take the submodule spanned by `f = 1 + x` in the polynomial ring with the natural degree grading. (There are more pathological examples for the counterarguments I can see for this.)\n\nNow we could do something where we check to see if the spanning elements are homogeneous and then use the ambient grading. This then likely has a solution at the category level by creating the category of subobjects of graded modules with basis and graded modules (with basis). (Note as I argue above, this is a strict subcategory of subobjects of graded modules with basis.) This might be slightly subtle as, in principle, by saying an object is graded, you are suppose to specify what graded structure you want. Thus doing it automatically is perhaps not quite mathematically valid.\n\nPerhaps the better solution would be to provide a `graded_submodule` method that returns a specially implemented `GradedSubmoduleWithBasis` class (as a subclass of `SubmoduleWithBasis`) that does all of this. This has the advantage of being explicit about the grading structure you want (the inherited one), not having to be very careful about adding the new category, and will likely be faster. It also means we don't have to add checks for homogeneity when someone might not want/need it.\n\nFor your immediate computational purposes, you can monkey patch in a degree by\n\n```python\ndef degree(self):\n    return self.lift().degree()\n```\nNote, as mentioned above, you have told the object that it is a graded module without specifying what the graded structure is. So this is a reasonable hack until a more long-term solution is implemented.\n\nThe situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.",
    "created_at": "2022-02-11T00:15:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471097",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:3'></a>The current behavior is correct because there is no guarantee that an *arbitrary* submodule is spanned by homogeneous elements. For a simple example, take the submodule spanned by `f = 1 + x` in the polynomial ring with the natural degree grading. (There are more pathological examples for the counterarguments I can see for this.)

Now we could do something where we check to see if the spanning elements are homogeneous and then use the ambient grading. This then likely has a solution at the category level by creating the category of subobjects of graded modules with basis and graded modules (with basis). (Note as I argue above, this is a strict subcategory of subobjects of graded modules with basis.) This might be slightly subtle as, in principle, by saying an object is graded, you are suppose to specify what graded structure you want. Thus doing it automatically is perhaps not quite mathematically valid.

Perhaps the better solution would be to provide a `graded_submodule` method that returns a specially implemented `GradedSubmoduleWithBasis` class (as a subclass of `SubmoduleWithBasis`) that does all of this. This has the advantage of being explicit about the grading structure you want (the inherited one), not having to be very careful about adding the new category, and will likely be faster. It also means we don't have to add checks for homogeneity when someone might not want/need it.

For your immediate computational purposes, you can monkey patch in a degree by

```python
def degree(self):
    return self.lift().degree()
```
Note, as mentioned above, you have told the object that it is a graded module without specifying what the graded structure is. So this is a reasonable hack until a more long-term solution is implemented.

The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.



---

archive/issue_comments_471098.json:
```json
{
    "body": "<a id='comment:4'></a>+1 on developing it both for filtered and for graded modules",
    "created_at": "2022-02-11T02:13:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471098",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:4'></a>+1 on developing it both for filtered and for graded modules



---

archive/issue_comments_471099.json:
```json
{
    "body": "<a id='comment:5'></a>Replying to [comment:3 tscrim]:\n> The current behavior is correct because there is no guarantee that an *arbitrary* submodule is spanned by homogeneous elements. For a simple example, take the submodule spanned by `f = 1 + x` in the polynomial ring with the natural degree grading. (There are more pathological examples for the counterarguments I can see for this.)\n> \n> Now we could do something where we check to see if the spanning elements are homogeneous and then use the ambient grading. This then likely has a solution at the category level by creating the category of subobjects of graded modules with basis and graded modules (with basis). (Note as I argue above, this is a strict subcategory of subobjects of graded modules with basis.) This might be slightly subtle as, in principle, by saying an object is graded, you are suppose to specify what graded structure you want. Thus doing it automatically is perhaps not quite mathematically valid.\n> \n> Perhaps the better solution would be to provide a `graded_submodule` method that returns a specially implemented `GradedSubmoduleWithBasis` class (as a subclass of `SubmoduleWithBasis`) that does all of this. This has the advantage of being explicit about the grading structure you want (the inherited one), not having to be very careful about adding the new category, and will likely be faster. It also means we don't have to add checks for homogeneity when someone might not want/need it.\n> \n> For your immediate computational purposes, you can monkey patch in a degree by\n> \n> ```python\n> def degree(self):\n>     return self.lift().degree()\n> ```\n> Note, as mentioned above, you have told the object that it is a graded module without specifying what the graded structure is. So this is a reasonable hack until a more long-term solution is implemented.\n> \n> The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.\n\n\n\nWould it make sense to use 'maximal_degree' for the grading for the submodule by default?",
    "created_at": "2022-02-12T01:47:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471099",
    "user": "https://github.com/louisng114"
}
```

<a id='comment:5'></a>Replying to [comment:3 tscrim]:
> The current behavior is correct because there is no guarantee that an *arbitrary* submodule is spanned by homogeneous elements. For a simple example, take the submodule spanned by `f = 1 + x` in the polynomial ring with the natural degree grading. (There are more pathological examples for the counterarguments I can see for this.)
> 
> Now we could do something where we check to see if the spanning elements are homogeneous and then use the ambient grading. This then likely has a solution at the category level by creating the category of subobjects of graded modules with basis and graded modules (with basis). (Note as I argue above, this is a strict subcategory of subobjects of graded modules with basis.) This might be slightly subtle as, in principle, by saying an object is graded, you are suppose to specify what graded structure you want. Thus doing it automatically is perhaps not quite mathematically valid.
> 
> Perhaps the better solution would be to provide a `graded_submodule` method that returns a specially implemented `GradedSubmoduleWithBasis` class (as a subclass of `SubmoduleWithBasis`) that does all of this. This has the advantage of being explicit about the grading structure you want (the inherited one), not having to be very careful about adding the new category, and will likely be faster. It also means we don't have to add checks for homogeneity when someone might not want/need it.
> 
> For your immediate computational purposes, you can monkey patch in a degree by
> 
> ```python
> def degree(self):
>     return self.lift().degree()
> ```
> Note, as mentioned above, you have told the object that it is a graded module without specifying what the graded structure is. So this is a reasonable hack until a more long-term solution is implemented.
> 
> The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.



Would it make sense to use 'maximal_degree' for the grading for the submodule by default?



---

archive/issue_comments_471100.json:
```json
{
    "body": "<a id='comment:7'></a>Replying to [comment:5 gh-louisng114]:\n> Replying to [comment:3 tscrim]:\n> > The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.\n\n> \n> \n> Would it make sense to use 'maximal_degree' for the grading for the submodule by default?\n\n\nNot for graded modules: take `1 / (1 - x)` in the ring of formal power series considered as a graded module by degree. There is no reasonable way to do this mathematically I believe.",
    "created_at": "2022-02-12T03:30:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471100",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:7'></a>Replying to [comment:5 gh-louisng114]:
> Replying to [comment:3 tscrim]:
> > The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.

> 
> 
> Would it make sense to use 'maximal_degree' for the grading for the submodule by default?


Not for graded modules: take `1 / (1 - x)` in the ring of formal power series considered as a graded module by degree. There is no reasonable way to do this mathematically I believe.



---

archive/issue_comments_471101.json:
```json
{
    "body": "<a id='comment:9'></a>I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.",
    "created_at": "2022-02-12T23:42:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471101",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:9'></a>I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.



---

archive/issue_comments_471102.json:
```json
{
    "body": "<a id='comment:10'></a>Replying to [comment:9 tscrim]:\n> I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.\n\n\nBut this is only for when we specify the category of the submodule to be graded.",
    "created_at": "2022-02-13T18:08:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471102",
    "user": "https://github.com/louisng114"
}
```

<a id='comment:10'></a>Replying to [comment:9 tscrim]:
> I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.


But this is only for when we specify the category of the submodule to be graded.



---

archive/issue_comments_471103.json:
```json
{
    "body": "<a id='comment:11'></a>Replying to [comment:10 gh-louisng114]:\n> Replying to [comment:9 tscrim]:\n> > I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.\n\n> \n> But this is only for when we specify the category of the submodule to be graded.\n\n\nStill -1 because passing that category means I am promising to provide a grading, not have it inherited. Basically I could not create a submodue of nonhomogeneous elements that I provide a different grading to. Again, it does not make sense mathematically to do this. Thinking about how it would be coded further reinforces that to me. It also makes it easier to construct the object you want as you don't have to pass the category.\n\nFor free modules over a graded algebra, we also have different constructions if we want the module to be graded or not (although this was very recently merged #32505 and should appear in the next beta).",
    "created_at": "2022-02-13T23:24:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471103",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:11'></a>Replying to [comment:10 gh-louisng114]:
> Replying to [comment:9 tscrim]:
> > I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be *very* upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.

> 
> But this is only for when we specify the category of the submodule to be graded.


Still -1 because passing that category means I am promising to provide a grading, not have it inherited. Basically I could not create a submodue of nonhomogeneous elements that I provide a different grading to. Again, it does not make sense mathematically to do this. Thinking about how it would be coded further reinforces that to me. It also makes it easier to construct the object you want as you don't have to pass the category.

For free modules over a graded algebra, we also have different constructions if we want the module to be graded or not (although this was very recently merged #32505 and should appear in the next beta).



---

archive/issue_comments_471104.json:
```json
{
    "body": "<a id='comment:12'></a>New commits:",
    "created_at": "2022-02-26T19:29:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471104",
    "user": "https://github.com/louisng114"
}
```

<a id='comment:12'></a>New commits:



---

archive/issue_comments_471105.json:
```json
{
    "body": "<a id='comment:13'></a>In this docstring (and the next):\n\n```\n+        def filtered_submodule(self, gens):\n+            r\"\"\"\n+            Create a graded submodule by referencing the grading of\n+            ``self``. The generators have to be each homogeneous.\n```\nit should say \"filtered\". Is the condition of being homogeneous needed in this case?",
    "created_at": "2022-02-26T20:36:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471105",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:13'></a>In this docstring (and the next):

```
+        def filtered_submodule(self, gens):
+            r"""
+            Create a graded submodule by referencing the grading of
+            ``self``. The generators have to be each homogeneous.
```
it should say "filtered". Is the condition of being homogeneous needed in this case?



---

archive/issue_comments_471106.json:
```json
{
    "body": "<a id='comment:14'></a>You have a contradiction: the category has a default grading and a special method saying inherit the grading. This is telling you that the category should *not* have the default grading. Let me again say that you need to create a separate *class* for the graded module and for filtered modules you can do this at the category level.\n\nHowever, I was thinking a bit more, and there is a subtle issue with my example in comment:7. That is in the direct *product*, but the standard graded module is a direct *sum*. So there is a way to define a grading by the minimal or maximal degree of any element. However, because there are two incompatible ways of doing it, we should not do it in general for the graded case. A particular class/method is different than at the category level because you are explicitly saying \"I want this specific object in the category.\"\n\nNote that formal power series is still a *filtered* module. For filtered modules, there is a unique way to do this because for any `x` there is a *unique* minimal (or maximal for a descending filteration) index `i` such that `x \\in S_i`. Contrast this with the graded case.",
    "created_at": "2022-02-27T00:22:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471106",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:14'></a>You have a contradiction: the category has a default grading and a special method saying inherit the grading. This is telling you that the category should *not* have the default grading. Let me again say that you need to create a separate *class* for the graded module and for filtered modules you can do this at the category level.

However, I was thinking a bit more, and there is a subtle issue with my example in comment:7. That is in the direct *product*, but the standard graded module is a direct *sum*. So there is a way to define a grading by the minimal or maximal degree of any element. However, because there are two incompatible ways of doing it, we should not do it in general for the graded case. A particular class/method is different than at the category level because you are explicitly saying "I want this specific object in the category."

Note that formal power series is still a *filtered* module. For filtered modules, there is a unique way to do this because for any `x` there is a *unique* minimal (or maximal for a descending filteration) index `i` such that `x \in S_i`. Contrast this with the graded case.



---

archive/issue_comments_471107.json:
```json
{
    "body": "<a id='comment:15'></a>Replying to [comment:14 tscrim]:\n> You have a contradiction: the category has a default grading and a special method saying inherit the grading. This is telling you that the category should *not* have the default grading.\n\n\nYou are saying that a parent in the category of subobjects of graded modules is not necessarily graded as it is in Louis' code?",
    "created_at": "2022-02-27T01:04:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471107",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:15'></a>Replying to [comment:14 tscrim]:
> You have a contradiction: the category has a default grading and a special method saying inherit the grading. This is telling you that the category should *not* have the default grading.


You are saying that a parent in the category of subobjects of graded modules is not necessarily graded as it is in Louis' code?



---

archive/issue_comments_471108.json:
```json
{
    "body": "<a id='comment:16'></a>In the generic case, that is correct. Restricting to the homogeneously generated case, it is, but that is an additional restriction that would need an additional category. Although it is such a special case that IMO it is easier to understand and maintain as a particular parent class in the categories we already have.",
    "created_at": "2022-02-27T04:25:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471108",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:16'></a>In the generic case, that is correct. Restricting to the homogeneously generated case, it is, but that is an additional restriction that would need an additional category. Although it is such a special case that IMO it is easier to understand and maintain as a particular parent class in the categories we already have.



---

archive/issue_comments_471109.json:
```json
{
    "body": "<a id='comment:17'></a>Well, more precisely it is graded (since it is a direct sum), but not in a canonical way.",
    "created_at": "2022-02-27T04:26:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471109",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:17'></a>Well, more precisely it is graded (since it is a direct sum), but not in a canonical way.



---

archive/issue_comments_471110.json:
```json
{
    "body": "<a id='comment:18'></a>Isn't it the very definition of a graded submodule that the elements of the submodule have the same degree as upstairs?",
    "created_at": "2022-02-27T04:27:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471110",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:18'></a>Isn't it the very definition of a graded submodule that the elements of the submodule have the same degree as upstairs?



---

archive/issue_comments_471111.json:
```json
{
    "body": "<a id='comment:19'></a>I also don't know what you mean by \"generic\".",
    "created_at": "2022-02-27T04:27:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471111",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:19'></a>I also don't know what you mean by "generic".



---

archive/issue_comments_471112.json:
```json
{
    "body": "<a id='comment:20'></a>In fact, I don't think there's such a thing as a graded submodule that cannot be generated by homogeneous generators.",
    "created_at": "2022-02-27T04:33:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471112",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:20'></a>In fact, I don't think there's such a thing as a graded submodule that cannot be generated by homogeneous generators.



---

archive/issue_comments_471113.json:
```json
{
    "body": "<a id='comment:21'></a>As a concrete example, take a polynomial ring as a graded module over its ground ring. Then take the submodule spanned by 1 + x. This is a submodule that has 2 natural gradings (that also extends to rings), one where it has degree 0 (min deg) and the other has degree 1 (max deg). This is a graded submodule in the sense that it is a submodule and it is graded, but not one that respects the ambient space grading. This is a natural submodule to construct IMO and needs to be supported.\n\nHowever, I see the point you are making, and there seems to be an ambiguity in the definition. We need to be very precise about what category we are in. We need to allow the construction above, and so I would not want the subobjects of a graded category to have to respect the ambient grading. I think we should have an explicit hook when we want to have something that respects the ambient grading.",
    "created_at": "2022-02-27T04:55:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471113",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:21'></a>As a concrete example, take a polynomial ring as a graded module over its ground ring. Then take the submodule spanned by 1 + x. This is a submodule that has 2 natural gradings (that also extends to rings), one where it has degree 0 (min deg) and the other has degree 1 (max deg). This is a graded submodule in the sense that it is a submodule and it is graded, but not one that respects the ambient space grading. This is a natural submodule to construct IMO and needs to be supported.

However, I see the point you are making, and there seems to be an ambiguity in the definition. We need to be very precise about what category we are in. We need to allow the construction above, and so I would not want the subobjects of a graded category to have to respect the ambient grading. I think we should have an explicit hook when we want to have something that respects the ambient grading.



---

archive/issue_comments_471114.json:
```json
{
    "body": "<a id='comment:22'></a>Replying to [comment:21 tscrim]:\n> [...] This is a graded submodule in the sense that it is a submodule and it is graded, but not one that respects the ambient space grading. This is a natural submodule to construct IMO \n\n\nYes, but it is in the join category of \"subobjects of modules with basis\" and \"graded modules\", not in the category that we're talking about.",
    "created_at": "2022-02-27T04:57:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471114",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:22'></a>Replying to [comment:21 tscrim]:
> [...] This is a graded submodule in the sense that it is a submodule and it is graded, but not one that respects the ambient space grading. This is a natural submodule to construct IMO 


Yes, but it is in the join category of "subobjects of modules with basis" and "graded modules", not in the category that we're talking about.



---

archive/issue_comments_471115.json:
```json
{
    "body": "<a id='comment:23'></a>So you are saying it is different than the subobjects of graded modules? This would be a very subtle point and not what I would expect by a submodule of a graded module.",
    "created_at": "2022-02-27T05:11:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471115",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:23'></a>So you are saying it is different than the subobjects of graded modules? This would be a very subtle point and not what I would expect by a submodule of a graded module.



---

archive/issue_comments_471116.json:
```json
{
    "body": "<a id='comment:24'></a>Yes, your \"natural submodule\" is not a graded submodule. It is submodule that also happens to have a grading.",
    "created_at": "2022-02-27T05:18:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471116",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:24'></a>Yes, your "natural submodule" is not a graded submodule. It is submodule that also happens to have a grading.



---

archive/issue_comments_471117.json:
```json
{
    "body": "<a id='comment:25'></a>I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods. Actually, it is sufficient to implement this for filtered modules.\n\nFor checking the homogeneity (after converted to an echelon basis), we can either trust the user is creating something that satisfies the conditions (which keeps the code very simple) or we override the `submodule` to also do this check when the category is a subcategory of `self.category().Subobjects()`.\n\nI think we should also override the `submodule` implementation for `FilteredModulesWithBasis` to make the category filtered by default since this is unambiguous.",
    "created_at": "2022-02-27T07:47:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471117",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:25'></a>I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods. Actually, it is sufficient to implement this for filtered modules.

For checking the homogeneity (after converted to an echelon basis), we can either trust the user is creating something that satisfies the conditions (which keeps the code very simple) or we override the `submodule` to also do this check when the category is a subcategory of `self.category().Subobjects()`.

I think we should also override the `submodule` implementation for `FilteredModulesWithBasis` to make the category filtered by default since this is unambiguous.



---

archive/issue_comments_471118.json:
```json
{
    "body": "<a id='comment:26'></a>We should also document the definition of a subobject of a graded module is a graded module whose grading agrees with its ambient module.",
    "created_at": "2022-02-27T07:50:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471118",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:26'></a>We should also document the definition of a subobject of a graded module is a graded module whose grading agrees with its ambient module.



---

archive/issue_comments_471119.json:
```json
{
    "body": "<a id='comment:27'></a>Replying to [comment:25 tscrim]:\n> I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. \n\n\nYes.\n\n> So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.\n\n\nI don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?\n\nAnd don't we still (I believe this was your earlier point) want to allow users to construct plain (non-graded) submodules of a module that happens to be graded?",
    "created_at": "2022-02-27T18:03:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471119",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:27'></a>Replying to [comment:25 tscrim]:
> I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. 


Yes.

> So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.


I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?

And don't we still (I believe this was your earlier point) want to allow users to construct plain (non-graded) submodules of a module that happens to be graded?



---

archive/issue_comments_471120.json:
```json
{
    "body": "<a id='comment:28'></a>Replying to [comment:27 mkoeppe]:\n> Replying to [comment:25 tscrim]:\n> > I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. \n\n> \n> Yes.\n> \n> > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.\n\n> \n> I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?\n\n\nYou can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Suobjects()`. These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves (or at least those where the generic implementations are sufficient). So I am being a bit more cautious here to clutter not the namespace so much.\n\n> And don't we still (I believe this was your earlier point) want to allow users to construct plain (non-graded) submodules of a module that happens to be graded?\n\n\nAs long as there is either no homogeneity enforced when the category is not `GradedModulesWithBasis(R).Subobjects()`, then this shouldn't be a problem. In fact, if we do override `GradedModulesWithBasis(R).submodule()`, we can return the filtered category when given inhomogeneous elements.",
    "created_at": "2022-02-28T00:21:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471120",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:28'></a>Replying to [comment:27 mkoeppe]:
> Replying to [comment:25 tscrim]:
> > I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. 

> 
> Yes.
> 
> > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.

> 
> I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?


You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Suobjects()`. These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves (or at least those where the generic implementations are sufficient). So I am being a bit more cautious here to clutter not the namespace so much.

> And don't we still (I believe this was your earlier point) want to allow users to construct plain (non-graded) submodules of a module that happens to be graded?


As long as there is either no homogeneity enforced when the category is not `GradedModulesWithBasis(R).Subobjects()`, then this shouldn't be a problem. In fact, if we do override `GradedModulesWithBasis(R).submodule()`, we can return the filtered category when given inhomogeneous elements.



---

archive/issue_comments_471121.json:
```json
{
    "body": "<a id='comment:29'></a>Are there already examples of methods where a `category` argument can make the default category less specific, rather than more specific?",
    "created_at": "2022-02-28T02:38:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471121",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:29'></a>Are there already examples of methods where a `category` argument can make the default category less specific, rather than more specific?



---

archive/issue_comments_471122.json:
```json
{
    "body": "<a id='comment:30'></a>I am sure there are depending on how explicit you want. `Hom` would be an essential case, other examples could be the `radical` of a Hopf algebra (it looses the Hopf part, there are others like this) or `invariant_module` (loses the ring structure if the action is not by automorphisms), and `submodule` has always allowed this:\n\n```\nsage: SGA = SymmetricGroupAlgebra(QQ,3)\nsage: SGA.submodule([SGA.an_element()])\nFree module generated by {0} over Rational Field\nsage: _.category()\nJoin of Category of finite dimensional modules with basis over Rational Field\n and Category of vector spaces with basis over Rational Field\n and Category of subobjects of sets\n```\nIt is indirectly there by the center construction via `submodule` as the category needs to be passed.",
    "created_at": "2022-02-28T04:00:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471122",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:30'></a>I am sure there are depending on how explicit you want. `Hom` would be an essential case, other examples could be the `radical` of a Hopf algebra (it looses the Hopf part, there are others like this) or `invariant_module` (loses the ring structure if the action is not by automorphisms), and `submodule` has always allowed this:

```
sage: SGA = SymmetricGroupAlgebra(QQ,3)
sage: SGA.submodule([SGA.an_element()])
Free module generated by {0} over Rational Field
sage: _.category()
Join of Category of finite dimensional modules with basis over Rational Field
 and Category of vector spaces with basis over Rational Field
 and Category of subobjects of sets
```
It is indirectly there by the center construction via `submodule` as the category needs to be passed.



---

archive/issue_comments_471123.json:
```json
{
    "body": "<a id='comment:31'></a>Replying to [comment:28 tscrim]:\n> Replying to [comment:27 mkoeppe]:\n> > Replying to [comment:25 tscrim]:\n> > > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.\n\n> > \n> > I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?\n\n> \n> You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Subobjects()`. \n\n\nCurrently, but we would change this default, right?\n\n> These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves \n\n\nOK, perhaps a way to think about this is that the word `submodule` indicates in what sense the resulting object is generated, not in what category it lies. \n\nSo if the object generated as a submodule happens to be a graded submodule (in the sense of the functorial construction of `GradedModulesWithBasis(R).Subobjects()`), we put it in that category.\n\nNow what if `self` is a `GradedAlgebraWithBasis(R)` and we call `submodule` on it, if the result happens to be a graded subalgebra (in the sense of its functorial construction), would we also be allowed to put it in that category?",
    "created_at": "2022-02-28T20:10:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471123",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:31'></a>Replying to [comment:28 tscrim]:
> Replying to [comment:27 mkoeppe]:
> > Replying to [comment:25 tscrim]:
> > > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.

> > 
> > I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?

> 
> You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Subobjects()`. 


Currently, but we would change this default, right?

> These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves 


OK, perhaps a way to think about this is that the word `submodule` indicates in what sense the resulting object is generated, not in what category it lies. 

So if the object generated as a submodule happens to be a graded submodule (in the sense of the functorial construction of `GradedModulesWithBasis(R).Subobjects()`), we put it in that category.

Now what if `self` is a `GradedAlgebraWithBasis(R)` and we call `submodule` on it, if the result happens to be a graded subalgebra (in the sense of its functorial construction), would we also be allowed to put it in that category?



---

archive/issue_comments_471124.json:
```json
{
    "body": "<a id='comment:33'></a>Replying to [comment:31 mkoeppe]:\n> Replying to [comment:28 tscrim]:\n> > Replying to [comment:27 mkoeppe]:\n> > > Replying to [comment:25 tscrim]:\n> > > > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.\n\n> > > \n> > > I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?\n\n> > \n> > You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Subobjects()`. \n\n> \n> Currently, but we would change this default, right?\n\n\nOnly for those cases that it makes sense for:\n\n- Submodules of filtered modules are naturally filtered.\n- Possibly submodules of graded modules generated by homogeneous elements are naturally graded.\n\n> > These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves \n\n> \n> OK, perhaps a way to think about this is that the word `submodule` indicates in what sense the resulting object is generated, not in what category it lies. \n> \n> So if the object generated as a submodule happens to be a graded submodule (in the sense of the functorial construction of `GradedModulesWithBasis(R).Subobjects()`), we put it in that category.\n\n\nYes to both. That's what I am now proposing, which was one of Louis's earlier suggestions.\n\n> Now what if `self` is a `GradedAlgebraWithBasis(R)` and we call `submodule` on it, if the result happens to be a graded subalgebra (in the sense of its functorial construction), would we also be allowed to put it in that category?\n\n\nDefinitely if no category is specified. I am not sure it is worth the code complexity and CPU cycles to verify the user has given us good input by checking the passed category is a subcategory and the homogeneity.",
    "created_at": "2022-03-01T00:30:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471124",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:33'></a>Replying to [comment:31 mkoeppe]:
> Replying to [comment:28 tscrim]:
> > Replying to [comment:27 mkoeppe]:
> > > Replying to [comment:25 tscrim]:
> > > > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.

> > > 
> > > I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?

> > 
> > You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Subobjects()`. 

> 
> Currently, but we would change this default, right?


Only for those cases that it makes sense for:

- Submodules of filtered modules are naturally filtered.
- Possibly submodules of graded modules generated by homogeneous elements are naturally graded.

> > These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves 

> 
> OK, perhaps a way to think about this is that the word `submodule` indicates in what sense the resulting object is generated, not in what category it lies. 
> 
> So if the object generated as a submodule happens to be a graded submodule (in the sense of the functorial construction of `GradedModulesWithBasis(R).Subobjects()`), we put it in that category.


Yes to both. That's what I am now proposing, which was one of Louis's earlier suggestions.

> Now what if `self` is a `GradedAlgebraWithBasis(R)` and we call `submodule` on it, if the result happens to be a graded subalgebra (in the sense of its functorial construction), would we also be allowed to put it in that category?


Definitely if no category is specified. I am not sure it is worth the code complexity and CPU cycles to verify the user has given us good input by checking the passed category is a subcategory and the homogeneity.



---

archive/issue_comments_471125.json:
```json
{
    "body": "<a id='comment:34'></a>I am cc-ing John in case he has any thoughts or opinions on this since he works a lot with graded modules I believe.",
    "created_at": "2022-03-01T00:32:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471125",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:34'></a>I am cc-ing John in case he has any thoughts or opinions on this since he works a lot with graded modules I believe.



---

archive/issue_comments_471126.json:
```json
{
    "body": "<a id='comment:35'></a>I'm not sure I can process all of the discussion right now, but given that disclaimer, here is my take: if you are explicitly working with an instance of `ModulesWithBasis(QQ).Graded()` and ask for a submodule, then you are in a graded setting and the submodule should be graded. (Should the code test for that or just assume that it's okay? I don't know.) Mathematically if you want to define the submodule of `k[x]` generated by `1+x`, then you should apply a forgetful functor to pass to the category of ungraded modules first, and then define the submodule. Within Sage, I think the process in the previous sentence should be explicit: if you want to define the submodule generated by `1+x`, you need to explicitly say that you are not going work in the graded setting any more.\n\nI think this is consistent with the recent comments.",
    "created_at": "2022-03-01T19:28:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471126",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:35'></a>I'm not sure I can process all of the discussion right now, but given that disclaimer, here is my take: if you are explicitly working with an instance of `ModulesWithBasis(QQ).Graded()` and ask for a submodule, then you are in a graded setting and the submodule should be graded. (Should the code test for that or just assume that it's okay? I don't know.) Mathematically if you want to define the submodule of `k[x]` generated by `1+x`, then you should apply a forgetful functor to pass to the category of ungraded modules first, and then define the submodule. Within Sage, I think the process in the previous sentence should be explicit: if you want to define the submodule generated by `1+x`, you need to explicitly say that you are not going work in the graded setting any more.

I think this is consistent with the recent comments.



---

archive/issue_comments_471127.json:
```json
{
    "body": "<a id='comment:36'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-03-02T02:00:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471127",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:36'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_471128.json:
```json
{
    "body": "<a id='comment:37'></a>Here is my proposal based upon our discussion. I decided to let the specified category override the filtered default in case someone wants to consider the object without the filtration (say, for doing morphisms). I also extended the allowed input for `echelon_form` and `submodule` so it was more natural. I also wasn't completely sure for the filtered quotients, so I just left that alone and only did things for graded modules.",
    "created_at": "2022-03-02T02:05:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471128",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:37'></a>Here is my proposal based upon our discussion. I decided to let the specified category override the filtered default in case someone wants to consider the object without the filtration (say, for doing morphisms). I also extended the allowed input for `echelon_form` and `submodule` so it was more natural. I also wasn't completely sure for the filtered quotients, so I just left that alone and only did things for graded modules.



---

archive/issue_comments_471129.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2022-03-02T02:05:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471129",
    "user": "https://github.com/tscrim"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_471130.json:
```json
{
    "body": "<a id='comment:38'></a>Great!\n\nIn this doctest:\n\n```\nIf ``category`` is specified, then it does not give any extra\n+            structure to the submodule (we can think of this as applying\n+            the forgetful functor)::\n+\n+                sage: SM = E.submodule([x + y, x*y - y*z], category=ModulesWithBasis(QQ))\n+                sage: SM.category()\n+                Join of Category of finite dimensional modules with basis over Rational Field\n+                 and Category of vector spaces with basis over Rational Field\n+                 and Category of subobjects of sets\n+                sage: FM = E.submodule([x + 1, x*y - x*y*z], category=ModulesWithBasis(QQ))\n+                sage: FM.category()\n+                Join of Category of finite dimensional modules with basis over Rational Field\n+                 and Category of vector spaces with basis over Rational Field\n+                 and Category of subobjects of sets\n+\n```\n\nit looks like the category is not quite right yet. Apart from the confusion with \"Join of ... finite-dimensional modules, vector spaces\" that is unrelated to this ticket, shouldn't it be at least in the category of subobjects of modules?",
    "created_at": "2022-03-02T02:29:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471130",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:38'></a>Great!

In this doctest:

```
If ``category`` is specified, then it does not give any extra
+            structure to the submodule (we can think of this as applying
+            the forgetful functor)::
+
+                sage: SM = E.submodule([x + y, x*y - y*z], category=ModulesWithBasis(QQ))
+                sage: SM.category()
+                Join of Category of finite dimensional modules with basis over Rational Field
+                 and Category of vector spaces with basis over Rational Field
+                 and Category of subobjects of sets
+                sage: FM = E.submodule([x + 1, x*y - x*y*z], category=ModulesWithBasis(QQ))
+                sage: FM.category()
+                Join of Category of finite dimensional modules with basis over Rational Field
+                 and Category of vector spaces with basis over Rational Field
+                 and Category of subobjects of sets
+
```

it looks like the category is not quite right yet. Apart from the confusion with "Join of ... finite-dimensional modules, vector spaces" that is unrelated to this ticket, shouldn't it be at least in the category of subobjects of modules?



---

archive/issue_comments_471131.json:
```json
{
    "body": "<a id='comment:39'></a>The subobjects of modules is the join of subobjects of sets and vector spaces. We just do not have that specific category defined (hence the join of those two). Likewise for adding the finite dimensional axiom. I added this doctest to show that it does not automatically inherent the graded/filtered structure when the category passed does not include it.",
    "created_at": "2022-03-02T03:39:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471131",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:39'></a>The subobjects of modules is the join of subobjects of sets and vector spaces. We just do not have that specific category defined (hence the join of those two). Likewise for adding the finite dimensional axiom. I added this doctest to show that it does not automatically inherent the graded/filtered structure when the category passed does not include it.



---

archive/issue_comments_471132.json:
```json
{
    "body": "<a id='comment:40'></a>Replying to [comment:39 tscrim]:\n> The subobjects of modules is the join of subobjects of sets and vector spaces. We just do not have that specific category defined (hence the join of those two).\n\n\nOK, that makes sense.",
    "created_at": "2022-03-02T03:47:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471132",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:40'></a>Replying to [comment:39 tscrim]:
> The subobjects of modules is the join of subobjects of sets and vector spaces. We just do not have that specific category defined (hence the join of those two).


OK, that makes sense.



---

archive/issue_comments_471133.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2022-03-02T03:54:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471133",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_471134.json:
```json
{
    "body": "<a id='comment:41'></a>\n```\nsage -t --long src/sage/graphs/graph.py  # 1 doctest failed\nsage -t --long src/sage/combinat/sf/k_dual.py  # 1 doctest failed\nsage -t --long src/sage/combinat/sf/new_kschur.py  # 1 doctest failed\nsage -t --long src/sage/matrix/matrix_space.py  # 4 doctests failed\nsage -t --long src/sage/algebras/orlik_terao.py  # 21 doctests failed\nsage -t --long src/sage/matroids/matroid.pyx  # 4 doctests failed\nsage -t --long src/sage/categories/modules_with_basis.py  # 5 doctests failed\nsage -t --long src/sage/algebras/orlik_solomon.py  # 30 doctests failed\nsage -t --long src/sage/matroids/linear_matroid.pyx  # 4 doctests failed\nsage -t --long src/sage/categories/filtered_modules_with_basis.py  # 2 doctests failed\nsage -t --long src/sage/categories/graded_modules_with_basis.py  # 6 doctests failed\n```\nThere are a number of trivial doctest failures that I will need to fix from the change in categories. However, some non-trivial ones from the invariant rings of Orlik-!Solomon/Terao algebras from the input-standardization change. I will have to look more closely. (The `graph.py` failure is unrelated IIRC.)",
    "created_at": "2022-03-02T03:54:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471134",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:41'></a>
```
sage -t --long src/sage/graphs/graph.py  # 1 doctest failed
sage -t --long src/sage/combinat/sf/k_dual.py  # 1 doctest failed
sage -t --long src/sage/combinat/sf/new_kschur.py  # 1 doctest failed
sage -t --long src/sage/matrix/matrix_space.py  # 4 doctests failed
sage -t --long src/sage/algebras/orlik_terao.py  # 21 doctests failed
sage -t --long src/sage/matroids/matroid.pyx  # 4 doctests failed
sage -t --long src/sage/categories/modules_with_basis.py  # 5 doctests failed
sage -t --long src/sage/algebras/orlik_solomon.py  # 30 doctests failed
sage -t --long src/sage/matroids/linear_matroid.pyx  # 4 doctests failed
sage -t --long src/sage/categories/filtered_modules_with_basis.py  # 2 doctests failed
sage -t --long src/sage/categories/graded_modules_with_basis.py  # 6 doctests failed
```
There are a number of trivial doctest failures that I will need to fix from the change in categories. However, some non-trivial ones from the invariant rings of Orlik-!Solomon/Terao algebras from the input-standardization change. I will have to look more closely. (The `graph.py` failure is unrelated IIRC.)



---

archive/issue_comments_471135.json:
```json
{
    "body": "<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-03-02T06:52:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471135",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_471136.json:
```json
{
    "body": "<a id='comment:43'></a>I fixed the bug, which came down to not getting the correct type for the generator input to `submodule`.\n\nMost of the other doctests are trivial updating. I think there are some new doctests added since beta1 (which is what I am currently using to work on this branch) to update. I still need to do that, which I probably won't do until tomorrow. However, two notable changes:\n\n- I believe the change in `modules_with_basis.py` was needed from a doctest copy/paste that was not fully updated. I think that kind of input is an abuse and the user should explicitly change the ring of the element as there is no, a priori, relation between the two modules.\n- The change of the base ring of `Sym` in `matrix_space.py` is because I was getting an unable-to-resolve-MRO issue that I could not reproduce in a more isolated example:\n  {{{\nTypeError: Cannot create a consistent method resolution order (MRO) for bases\n VectorSpaces.subcategory_class, GradedModules.subcategory_class\n  }}}\n  This doesn't change the content of that doctest, but allows us to continue to sidestep this MRO resolution issue (see, e.g., #22962).",
    "created_at": "2022-03-02T07:08:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471136",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:43'></a>I fixed the bug, which came down to not getting the correct type for the generator input to `submodule`.

Most of the other doctests are trivial updating. I think there are some new doctests added since beta1 (which is what I am currently using to work on this branch) to update. I still need to do that, which I probably won't do until tomorrow. However, two notable changes:

- I believe the change in `modules_with_basis.py` was needed from a doctest copy/paste that was not fully updated. I think that kind of input is an abuse and the user should explicitly change the ring of the element as there is no, a priori, relation between the two modules.
- The change of the base ring of `Sym` in `matrix_space.py` is because I was getting an unable-to-resolve-MRO issue that I could not reproduce in a more isolated example:
  {{{
TypeError: Cannot create a consistent method resolution order (MRO) for bases
 VectorSpaces.subcategory_class, GradedModules.subcategory_class
  }}}
  This doesn't change the content of that doctest, but allows us to continue to sidestep this MRO resolution issue (see, e.g., #22962).



---

archive/issue_comments_471137.json:
```json
{
    "body": "<a id='comment:44'></a>Replying to [comment:43 tscrim]:\n> - I believe the change in `modules_with_basis.py` was needed from a doctest copy/paste that was not fully updated. \n\n\nYes, I agree",
    "created_at": "2022-03-02T07:26:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471137",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:44'></a>Replying to [comment:43 tscrim]:
> - I believe the change in `modules_with_basis.py` was needed from a doctest copy/paste that was not fully updated. 


Yes, I agree



---

archive/issue_comments_471138.json:
```json
{
    "body": "<a id='comment:45'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-03-04T07:17:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471138",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:45'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_471139.json:
```json
{
    "body": "<a id='comment:46'></a>Here are the fixes.",
    "created_at": "2022-03-04T07:19:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471139",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:46'></a>Here are the fixes.



---

archive/issue_comments_471140.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2022-03-04T07:19:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471140",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_471141.json:
```json
{
    "body": "<a id='comment:47'></a>Bot was morally green using beta3 and passes all tests (other than known failures) run on my machine for beta4.",
    "created_at": "2022-03-09T07:56:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471141",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:47'></a>Bot was morally green using beta3 and passes all tests (other than known failures) run on my machine for beta4.



---

archive/issue_comments_471142.json:
```json
{
    "body": "<a id='comment:48'></a>Looks good to me. Refinements and generalizations can be done in follow-up tickets. Thanks for this work!",
    "created_at": "2022-03-09T18:14:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471142",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:48'></a>Looks good to me. Refinements and generalizations can be done in follow-up tickets. Thanks for this work!



---

archive/issue_comments_471143.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2022-03-09T18:14:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471143",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_471144.json:
```json
{
    "body": "<a id='comment:49'></a>Thank you.\n\nI hope this also works for the application you have in mind Louis. If not or if you have other questions, feel free to email me directly to discuss things further.",
    "created_at": "2022-03-09T23:23:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471144",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:49'></a>Thank you.

I hope this also works for the application you have in mind Louis. If not or if you have other questions, feel free to email me directly to discuss things further.



---

archive/issue_events_087938.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2022-03-12T15:11:08Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33321#event-87938"
}
```



---

archive/issue_comments_471145.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2022-03-12T15:11:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33321",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33321#issuecomment-471145",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
