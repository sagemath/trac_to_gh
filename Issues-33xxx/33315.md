# Issue 33315: Provide common subexpression elimination like SymPy's `cse`

archive/issues_033078.json:
```json
{
    "body": "CC:  @slel\n\nExplanation copied from:\n\n- https://www.sympy.org/scipy-2017-codegen-tutorial/notebooks/07-the-hard-way.html\n\n## Common Subexpression Elimination\n\nIf you look carefully at the expressions in the two matrices you'll see repeated expressions. These are not ideal in the sense that the computer has to repeat the exact same calculation multiple times. For large expressions this can be a major issue. Compilers, such as gcc, can often eliminate common subexpressions on their own when different optimization flags are invoked but for complex expressions the algorithms in some compilers do not do a thorough job or compilation can take an extremely long time. SymPy has tools to perform **common subexpression elimination** which is both thorough and reasonably efficient. In particular if `gcc` is run with the lowest optimization setting `-O0`, `cse` can give large speedups.\n\nFor example if you have two expressions:\n\n```\na = x*y + 5\nb = x*y + 6\n```\nyou can convert this to these three expressions:\n\n```\nz = x*y\na = z + 5\nb = z + 6\n```\nand `x*y` only has to be computed once.\n\nThe `cse()` function in SymPy returns\n\n- the subexpression, `z = x*y`, and\n- the simplified expressions: `a = z + 5`, `b = z + 6`.\n\nHere is how it works:\n\n```\n>>> sym.cse?\n\nsub_exprs, simplified_rhs = sym.cse(rhs_of_odes)\n\nfor var, expr in sub_exprs:\n    sym.pprint(sym.Eq(var, expr))\n\nx\u2080 = 0.0158\u22c5y\u2080\u22c5y\u2081\nx\u2081 = -x\u2080\nx\u2082 = 27600000.0\u22c5y\u2080\u22c5y\u2084\nx\u2083 = -x\u2082\nx\u2084 = 24400.0\u22c5y\u2082\u22c5y\u2084\n       2\nx\u2085 = y\u2080 \nx\u2086 = 14520000.0\u22c5x\u2085\nx\u2087 = -x\u2086\nx\u2088 = 5.83\u22c5y\u2084\nx\u2089 = 20900000.0\u22c5y\u2080\u22c5y\u2081\u2081\nx\u2081\u2080 = -x\u2089\nx\u2081\u2081 = 35500000.0\u22c5y\u2080\u22c5y\u2085\nx\u2081\u2082 = -x\u2081\u2081\nx\u2081\u2083 = 13600000.0\u22c5y\u2080\u22c5y\u2086\nx\u2081\u2084 = -x\u2081\u2083\nx\u2081\u2085 = 22900000.0\u22c5y\u2080\u22c5y\u2087\nx\u2081\u2086 = -x\u2081\u2085\nx\u2081\u2087 = y\u2080\u22c5y\u2088\nx\u2081\u2088 = 13000000.0\u22c5x\u2081\u2087\nx\u2081\u2089 = -x\u2081\u2088\nx\u2082\u2080 = 13000000.0\u22c5y\u2080\u22c5y\u2089\n```\n\nIs there something like this in SageMath?\n\nIssue created by migration from https://trac.sagemath.org/ticket/33315\n\n",
    "created_at": "2022-02-08T16:59:08Z",
    "labels": [
        "component: symbolics",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Provide common subexpression elimination like SymPy's `cse`",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/33315",
    "user": "https://github.com/dorp92"
}
```
CC:  @slel

Explanation copied from:

- https://www.sympy.org/scipy-2017-codegen-tutorial/notebooks/07-the-hard-way.html

## Common Subexpression Elimination

If you look carefully at the expressions in the two matrices you'll see repeated expressions. These are not ideal in the sense that the computer has to repeat the exact same calculation multiple times. For large expressions this can be a major issue. Compilers, such as gcc, can often eliminate common subexpressions on their own when different optimization flags are invoked but for complex expressions the algorithms in some compilers do not do a thorough job or compilation can take an extremely long time. SymPy has tools to perform **common subexpression elimination** which is both thorough and reasonably efficient. In particular if `gcc` is run with the lowest optimization setting `-O0`, `cse` can give large speedups.

For example if you have two expressions:

```
a = x*y + 5
b = x*y + 6
```
you can convert this to these three expressions:

```
z = x*y
a = z + 5
b = z + 6
```
and `x*y` only has to be computed once.

The `cse()` function in SymPy returns

- the subexpression, `z = x*y`, and
- the simplified expressions: `a = z + 5`, `b = z + 6`.

Here is how it works:

```
>>> sym.cse?

sub_exprs, simplified_rhs = sym.cse(rhs_of_odes)

for var, expr in sub_exprs:
    sym.pprint(sym.Eq(var, expr))

x₀ = 0.0158⋅y₀⋅y₁
x₁ = -x₀
x₂ = 27600000.0⋅y₀⋅y₄
x₃ = -x₂
x₄ = 24400.0⋅y₂⋅y₄
       2
x₅ = y₀ 
x₆ = 14520000.0⋅x₅
x₇ = -x₆
x₈ = 5.83⋅y₄
x₉ = 20900000.0⋅y₀⋅y₁₁
x₁₀ = -x₉
x₁₁ = 35500000.0⋅y₀⋅y₅
x₁₂ = -x₁₁
x₁₃ = 13600000.0⋅y₀⋅y₆
x₁₄ = -x₁₃
x₁₅ = 22900000.0⋅y₀⋅y₇
x₁₆ = -x₁₅
x₁₇ = y₀⋅y₈
x₁₈ = 13000000.0⋅x₁₇
x₁₉ = -x₁₈
x₂₀ = 13000000.0⋅y₀⋅y₉
```

Is there something like this in SageMath?

Issue created by migration from https://trac.sagemath.org/ticket/33315





---

archive/issue_events_087920.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-07T00:07:21Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/33315",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33315#event-87920"
}
```



---

archive/issue_events_087921.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T16:33:45Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/33315",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33315#event-87921"
}
```



---

archive/issue_events_087922.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T16:33:45Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/33315",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33315#event-87922"
}
```
