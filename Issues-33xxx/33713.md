# Issue 33713: Implementation of finite Drinfeld modules

archive/issues_033476.json:
```json
{
    "body": "**Edit (2022-09-27). A lot has changed since the original post. Here is a quick update.**\n\n## What is a Drinfeld module?\n\nLet `L` be a finite field extension of `\\Fq` and fix a ring morphism `\\gamma: \\Fq[X] \\to L`. Let `\\Ltau` be the ring of Ore polynomials with coefficients in `L` and whose generator is the Frobenius endomorphism `\\tau: x \\mapsto x^q`. A *Drinfeld module over the morphism `\\gamma`* `\\phi` is uniquely defined by an `\\Fq`-algebra morphism `\\Fq[X] \\to \\Ltau, P \\mapsto \\phi_P`, verifying `\\phi_X = \\gamma(X) + a_1\\tau + \\dots + a_r\\tau^r` and `r > 0`.\n\nA *morphism of Drinfeld modules `u: \\phi \\to \\psi`* is defined by an Ore polynomial `u \\in \\Ltau` verifying `u \\phi_X = \\psi_X u`.\n\nDrinfeld modules and their morphisms are the object and morphisms of the *category of Drinfeld modules defined over the morphism `\\gamma`*.\n\nA Drinfeld module induces an `\\Fq[X]`-module law on `L`, defined by `a \\star z = \\phi_a(z)`, where `a \\in \\Fq[X]` and `z \\in L`. This is referred to as the *Drinfeld module action induced by `\\phi`*.\n\n## Overview\n\nWe created:\n- `DrinfeldModule(Parent, UniqueRepresentation)`;\n- `FiniteDrinfeldModule(DrinfeldModule)`;\n- `DrinfeldModuleAction(Action)`;\n- `DrinfeldModules(Category_over_base)`;\n- `DrinfeldModuleHomset(Homset)`;\n- `DrinfeldModuleMorphism(Morphism, UniqueRepresentation)`.\n\nHere is a short demo:\n\n```\nsage: Fq = GF(2)\nsage: FqX.<X> = Fq[]\nsage: K.<i> = Fq.extension(2)\nsage: phi = DrinfeldModule(FqX, [i, i, 1])\nsage: phi\nDrinfeld module defined by X |--> t^2 + i*t + i over base Ring morphism:\n  From: Univariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)\n  To:   Finite Field in i of size 2^2\n  Defn: X |--> i\nsage: phi(X)\nt^2 + i*t + i\nsage: psi = DrinfeldModule(FqX, [i, i+1, 1])\nsage: t = phi.ore_polring().gen()\nsage: i + t in Hom(phi, psi)\nTrue\nsage: phi.velu(i + t)\nDrinfeld module defined by X |--> t^2 + (i + 1)*t + i over base Ring morphism:\n  From: Univariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)\n  To:   Finite Field in i of size 2^2\n  Defn: X |--> i\n```\n\n---\n\n---\n\n---\n\n\n\nI would like to propose an implementation for *finite Drinfeld modules*. I\nopened this ticket to discuss this idea and have feedback on implementation\ndirections, in order to comply with Sage's guidelines. Please feel free to express any doubt or criticism, or give ideas! I very much value the collaborative aspect of the [SageMath](SageMath) community.\n\n# Motivation\n\nA finite Drinfeld module is defined as follows. Let `Fq` be a finite fields\nwith `q` elements, let `L` be a finite extension of `Fq`. Consider the\n`\\Fqbar`-linear endomorphism `\\tau: x \\mapsto x^q`, and define `L\\{\\tau\\}` as\nthe ring of Ore polynomials in `\\tau` with coefficients in `L` (see [ticket: 29629]). Also fix `\\omega` a non zero element of\n`L`. An `\\Fq`-Drinfeld module defined over `L` is, by definition, an\n`\\Fq`-algebra morphism `\\phi: \\Fq[X]\\toL\\{\\tau\\}` such that:\n* `\\phi(X)` as constant coefficient `\\omega`,\n* `\\phi(\\Fq[X])` is not contained in `L`.\n\nAt the moment, there exists no such implementation in Sage.\n\nDrinfeld modules are standard arithmetic tools in the theory of function\nfields. See [Goss, *Basic structures of function field arithmetic*, 1998],\n[Rosen, *Number theory in function fields*, 2002]. Good resources are also\n[Gekeler, *On finite Drinfeld modules*, 1991], [Hayes, ''A brief introduction to\nDrinfeld modules*, 1991] and [Caranay, Greenberg, Scheidler, *Computing modular\npolynomials and isogenies of rank two Drinfeld modules'', 2020]. The author of\nthis ticket got interested in Drinfeld modules with isogeny-based cryptographic\napplications in mind; see https://arxiv.org/abs/2203.06970.\n\nI am a first-year PhD student working with\n[P.-J. Spaenlehauer](https://members.loria.fr/PJSpaenlehauer/index.html) and\n[E. Thom\u00e9](https://members.loria.fr/EThome/).\n\n# Implementation details\n\nI propose three classes: `FiniteDrinfeldModule`, `FiniteDrinfeldModulesRankSet`\nand `FiniteDrinfeldModulesSet`.\n\n## The `FiniteDrinfeldModule` class\n\nThis is the class for representing finite Drinfeld modules. It must be\ninstantiated with a polynomial ring and an Ore polynomial ring:\n\n```\nsage: Fq = GF(2)\nsage: L = Fq.extension(2)\nsage: FqX.<X> = Fq[]\nsage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism())\nsage: omega = L.gen()\nsage: phi_X = omega + t + t^2\nsage: phi = FiniteDrinfeldModule(FqX, Ltau, phi_X)  # phi is only defined by the image of X\n```\n\nHere are the methods that I wish to add in the first version:\n\n```\nsage: phi.generator()  # phi_X\nt^2 + t + z2\nsage: phi(X^2)  # Magic method __call__\nt^4 + t^2 + t + z2 + 1\nsage: phi.polynomial_ring  # Property, reference to FqX\nUnivariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)\nsage: phi.ore_polynomial_ring  # Property, reference to Ltau\nOre Polynomial Ring in t over Finite Field in z2 of size 2^2 twisted by z2 |--> z2^2\nsage: phi.rank  # Property, rank of phi\n2\nsage: phi.frobenius  # Property, returns t\nt\nsage: phi.omega  # Property, returns omega\nz2\nsage: phi.Fq  # Property, reference to Fq\nFinite Field of size 2\nsage: phi.definition_field  # Property, reference to L\nFinite Field in z2 of size 2^2\nsage: phi.j_invariant  # Only if rank is 2, returns j-invariant\n1\n```\n\nA crucial feature of finite Drinfeld module is that they endow the algebraic\nclosure `\\Fqbar` with a structure of left-`\\Fq[X]`-module. I think the most\nappropriate mechanism is to have a method `algebraic_closure_action` return a\n`LeftModuleAction` (see\nhttps://doc.sagemath.org/html/en/reference/coercion/sage/structure/coerce_actions.html#sage.structure.coerce_actions.LeftModuleAction).\nI am not yet sure if it is the best way to do it.\n\nOn top of this, the first version should be well doctested and include Sage's\nown magic method (`_repr_`, `_latex`, etc).\n\nIn further versions, I wish to include:\n* methods in isogenies of Drinfeld modules (esp. V\u00e9lu's formula for Drinfeld modules);\n* methods on the torsion of Drinfeld modules (module law and vector space law);\n* class methods (instanciate a random Drinfeld module, or from a j-invariant);\n* methods on the well-definition of a Drinfeld module on some sub-field of L.\n\nNaturally, any input (especially negative) is more than welcome!\n\n## The `FiniteDrinfeldModulesRankSet` and `FiniteDrinfeldModulesSet` classes\n\nTo comply with the coercion model (see\nhttps://doc.sagemath.org/html/en/developer/coding_in_python.html#the-sage-coercion-model,\nhttps://doc.sagemath.org/html/en/reference/coercion/index.html), any instance\nof `FiniteDrinfeldModule` must have a parent. I was thinking about creating a\nclass `FiniteDrinfeldModulesRankSet`, representing the set of all finite\nDrinfeld modules (with `FqX`, `Ltau` and `omega` fixed) with a prescribed rank.\nThe class `FiniteDrinfeldModulesSet` is the same, except the rank can be\narbitrary.\n\nThe details are not clear to me at this point.\n\n# Development environment\n\nIt is not clear to me yet in which environment I should work: tox virtual\nenvironment, Docker ?.. Any advice is more than welcome.\n\n\n**CC:**  @xcaruso @mbombar @zimmermann6 @davidayotte @spaenlehauer\n\n**Keywords:** Drinfeld modules, Ore polynomials, Function fields\n\n**Branch:** [public/drinfeld_module](https://github.com/sagemath/sagetrac-mirror/tree/public/drinfeld_module)\n\n**Commit:** [6982ae08d9ce6dbb622ba570299e2130b2397026](https://github.com/sagemath/sagetrac-mirror/commit/6982ae08d9ce6dbb622ba570299e2130b2397026)\n\n**Author:** Antoine Leudi\u00e8re\n\n**Status:** needs_work\n\n**Dependencies:** #34692\n\nIssue created by migration from https://trac.sagemath.org/ticket/33713\n\n",
    "created_at": "2022-04-15T09:20:59Z",
    "labels": [
        "component: number theory",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Implementation of finite Drinfeld modules",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/33713",
    "user": "https://github.com/antoine-leudiere"
}
```
**Edit (2022-09-27). A lot has changed since the original post. Here is a quick update.**

## What is a Drinfeld module?

Let `L` be a finite field extension of `\Fq` and fix a ring morphism `\gamma: \Fq[X] \to L`. Let `\Ltau` be the ring of Ore polynomials with coefficients in `L` and whose generator is the Frobenius endomorphism `\tau: x \mapsto x^q`. A *Drinfeld module over the morphism `\gamma`* `\phi` is uniquely defined by an `\Fq`-algebra morphism `\Fq[X] \to \Ltau, P \mapsto \phi_P`, verifying `\phi_X = \gamma(X) + a_1\tau + \dots + a_r\tau^r` and `r > 0`.

A *morphism of Drinfeld modules `u: \phi \to \psi`* is defined by an Ore polynomial `u \in \Ltau` verifying `u \phi_X = \psi_X u`.

Drinfeld modules and their morphisms are the object and morphisms of the *category of Drinfeld modules defined over the morphism `\gamma`*.

A Drinfeld module induces an `\Fq[X]`-module law on `L`, defined by `a \star z = \phi_a(z)`, where `a \in \Fq[X]` and `z \in L`. This is referred to as the *Drinfeld module action induced by `\phi`*.

## Overview

We created:
- `DrinfeldModule(Parent, UniqueRepresentation)`;
- `FiniteDrinfeldModule(DrinfeldModule)`;
- `DrinfeldModuleAction(Action)`;
- `DrinfeldModules(Category_over_base)`;
- `DrinfeldModuleHomset(Homset)`;
- `DrinfeldModuleMorphism(Morphism, UniqueRepresentation)`.

Here is a short demo:

```
sage: Fq = GF(2)
sage: FqX.<X> = Fq[]
sage: K.<i> = Fq.extension(2)
sage: phi = DrinfeldModule(FqX, [i, i, 1])
sage: phi
Drinfeld module defined by X |--> t^2 + i*t + i over base Ring morphism:
  From: Univariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)
  To:   Finite Field in i of size 2^2
  Defn: X |--> i
sage: phi(X)
t^2 + i*t + i
sage: psi = DrinfeldModule(FqX, [i, i+1, 1])
sage: t = phi.ore_polring().gen()
sage: i + t in Hom(phi, psi)
True
sage: phi.velu(i + t)
Drinfeld module defined by X |--> t^2 + (i + 1)*t + i over base Ring morphism:
  From: Univariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)
  To:   Finite Field in i of size 2^2
  Defn: X |--> i
```

---

---

---



I would like to propose an implementation for *finite Drinfeld modules*. I
opened this ticket to discuss this idea and have feedback on implementation
directions, in order to comply with Sage's guidelines. Please feel free to express any doubt or criticism, or give ideas! I very much value the collaborative aspect of the [SageMath](SageMath) community.

# Motivation

A finite Drinfeld module is defined as follows. Let `Fq` be a finite fields
with `q` elements, let `L` be a finite extension of `Fq`. Consider the
`\Fqbar`-linear endomorphism `\tau: x \mapsto x^q`, and define `L\{\tau\}` as
the ring of Ore polynomials in `\tau` with coefficients in `L` (see [ticket: 29629]). Also fix `\omega` a non zero element of
`L`. An `\Fq`-Drinfeld module defined over `L` is, by definition, an
`\Fq`-algebra morphism `\phi: \Fq[X]\toL\{\tau\}` such that:
* `\phi(X)` as constant coefficient `\omega`,
* `\phi(\Fq[X])` is not contained in `L`.

At the moment, there exists no such implementation in Sage.

Drinfeld modules are standard arithmetic tools in the theory of function
fields. See [Goss, *Basic structures of function field arithmetic*, 1998],
[Rosen, *Number theory in function fields*, 2002]. Good resources are also
[Gekeler, *On finite Drinfeld modules*, 1991], [Hayes, ''A brief introduction to
Drinfeld modules*, 1991] and [Caranay, Greenberg, Scheidler, *Computing modular
polynomials and isogenies of rank two Drinfeld modules'', 2020]. The author of
this ticket got interested in Drinfeld modules with isogeny-based cryptographic
applications in mind; see https://arxiv.org/abs/2203.06970.

I am a first-year PhD student working with
[P.-J. Spaenlehauer](https://members.loria.fr/PJSpaenlehauer/index.html) and
[E. Thomé](https://members.loria.fr/EThome/).

# Implementation details

I propose three classes: `FiniteDrinfeldModule`, `FiniteDrinfeldModulesRankSet`
and `FiniteDrinfeldModulesSet`.

## The `FiniteDrinfeldModule` class

This is the class for representing finite Drinfeld modules. It must be
instantiated with a polynomial ring and an Ore polynomial ring:

```
sage: Fq = GF(2)
sage: L = Fq.extension(2)
sage: FqX.<X> = Fq[]
sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism())
sage: omega = L.gen()
sage: phi_X = omega + t + t^2
sage: phi = FiniteDrinfeldModule(FqX, Ltau, phi_X)  # phi is only defined by the image of X
```

Here are the methods that I wish to add in the first version:

```
sage: phi.generator()  # phi_X
t^2 + t + z2
sage: phi(X^2)  # Magic method __call__
t^4 + t^2 + t + z2 + 1
sage: phi.polynomial_ring  # Property, reference to FqX
Univariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)
sage: phi.ore_polynomial_ring  # Property, reference to Ltau
Ore Polynomial Ring in t over Finite Field in z2 of size 2^2 twisted by z2 |--> z2^2
sage: phi.rank  # Property, rank of phi
2
sage: phi.frobenius  # Property, returns t
t
sage: phi.omega  # Property, returns omega
z2
sage: phi.Fq  # Property, reference to Fq
Finite Field of size 2
sage: phi.definition_field  # Property, reference to L
Finite Field in z2 of size 2^2
sage: phi.j_invariant  # Only if rank is 2, returns j-invariant
1
```

A crucial feature of finite Drinfeld module is that they endow the algebraic
closure `\Fqbar` with a structure of left-`\Fq[X]`-module. I think the most
appropriate mechanism is to have a method `algebraic_closure_action` return a
`LeftModuleAction` (see
https://doc.sagemath.org/html/en/reference/coercion/sage/structure/coerce_actions.html#sage.structure.coerce_actions.LeftModuleAction).
I am not yet sure if it is the best way to do it.

On top of this, the first version should be well doctested and include Sage's
own magic method (`_repr_`, `_latex`, etc).

In further versions, I wish to include:
* methods in isogenies of Drinfeld modules (esp. Vélu's formula for Drinfeld modules);
* methods on the torsion of Drinfeld modules (module law and vector space law);
* class methods (instanciate a random Drinfeld module, or from a j-invariant);
* methods on the well-definition of a Drinfeld module on some sub-field of L.

Naturally, any input (especially negative) is more than welcome!

## The `FiniteDrinfeldModulesRankSet` and `FiniteDrinfeldModulesSet` classes

To comply with the coercion model (see
https://doc.sagemath.org/html/en/developer/coding_in_python.html#the-sage-coercion-model,
https://doc.sagemath.org/html/en/reference/coercion/index.html), any instance
of `FiniteDrinfeldModule` must have a parent. I was thinking about creating a
class `FiniteDrinfeldModulesRankSet`, representing the set of all finite
Drinfeld modules (with `FqX`, `Ltau` and `omega` fixed) with a prescribed rank.
The class `FiniteDrinfeldModulesSet` is the same, except the rank can be
arbitrary.

The details are not clear to me at this point.

# Development environment

It is not clear to me yet in which environment I should work: tox virtual
environment, Docker ?.. Any advice is more than welcome.


**CC:**  @xcaruso @mbombar @zimmermann6 @davidayotte @spaenlehauer

**Keywords:** Drinfeld modules, Ore polynomials, Function fields

**Branch:** [public/drinfeld_module](https://github.com/sagemath/sagetrac-mirror/tree/public/drinfeld_module)

**Commit:** [6982ae08d9ce6dbb622ba570299e2130b2397026](https://github.com/sagemath/sagetrac-mirror/commit/6982ae08d9ce6dbb622ba570299e2130b2397026)

**Author:** Antoine Leudière

**Status:** needs_work

**Dependencies:** #34692

Issue created by migration from https://trac.sagemath.org/ticket/33713





---

archive/issue_comments_671978.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,6 +1,6 @@\n I would like to propose an implementation for *finite Drinfeld modules*. I\n opened this ticket to discuss this idea and have feedback on implementation\n-directions, in order to comply with Sage's guidelines. Please do feel free to express any doubt or criticism, or give ideas! I very much value the collaborative aspect of the [SageMath](SageMath) community.\n+directions, in order to comply with Sage's guidelines. Please feel free to express any doubt or criticism, or give ideas! I very much value the collaborative aspect of the [SageMath](SageMath) community.\n \n # Motivation\n \n@@ -11,16 +11,16 @@\n `L`. An `\\Fq`-Drinfeld module defined over `L` is, by definition, an\n `\\Fq`-algebra morphism `\\phi: \\Fq[X]\\toL\\{\\tau\\}` such that:\n * `\\phi(X)` as constant coefficient `\\omega`,\n-* `phi` is not contained in `L`.\n+* `\\phi(\\Fq[X])` is not contained in `L`.\n \n At the moment, there exists no such implementation in Sage.\n \n Drinfeld modules are standard arithmetic tools in the theory of function\n-fields. See [Goss, Basic structures of function field arithmetic, 1998],\n-[Rosen, Number theory in function fields, 2002]. Good resources are also\n-[Gekeler, On finite Drinfeld modules, 1991], [Hayes, A brief introduction to\n-Drinfeld modules, 1991] and [Caranay, Greenberg, Scheidler, Computing modular\n-polynomials and isogenies of rank two Drinfeld modules, 2020]. The author of\n+fields. See [Goss, *Basic structures of function field arithmetic*, 1998],\n+[Rosen, *Number theory in function fields*, 2002]. Good resources are also\n+[Gekeler, *On finite Drinfeld modules*, 1991], [Hayes, ''A brief introduction to\n+Drinfeld modules*, 1991] and [Caranay, Greenberg, Scheidler, *Computing modular\n+polynomials and isogenies of rank two Drinfeld modules'', 2020]. The author of\n this ticket got interested in Drinfeld modules with isogeny-based cryptographic\n applications in mind; see https://arxiv.org/abs/2203.06970.\n \n@@ -84,8 +84,7 @@\n own magic method (`_repr_`, `_latex`, etc).\n \n In further versions, I wish to include:\n-* methods in isogenies of Drinfeld modules (esp. V\u00e9lu's formula for Drinfeld\n-* modules);\n+* methods in isogenies of Drinfeld modules (esp. V\u00e9lu's formula for Drinfeld modules);\n * methods on the torsion of Drinfeld modules (module law and vector space law);\n * class methods (instanciate a random Drinfeld module, or from a j-invariant);\n * methods on the well-definition of a Drinfeld module on some sub-field of L.\n``````\n",
    "created_at": "2022-04-15T14:07:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671978",
    "user": "https://github.com/antoine-leudiere"
}
```


**Description changed:**
``````diff
--- 
+++ 
@@ -1,6 +1,6 @@
 I would like to propose an implementation for *finite Drinfeld modules*. I
 opened this ticket to discuss this idea and have feedback on implementation
-directions, in order to comply with Sage's guidelines. Please do feel free to express any doubt or criticism, or give ideas! I very much value the collaborative aspect of the [SageMath](SageMath) community.
+directions, in order to comply with Sage's guidelines. Please feel free to express any doubt or criticism, or give ideas! I very much value the collaborative aspect of the [SageMath](SageMath) community.
 
 # Motivation
 
@@ -11,16 +11,16 @@
 `L`. An `\Fq`-Drinfeld module defined over `L` is, by definition, an
 `\Fq`-algebra morphism `\phi: \Fq[X]\toL\{\tau\}` such that:
 * `\phi(X)` as constant coefficient `\omega`,
-* `phi` is not contained in `L`.
+* `\phi(\Fq[X])` is not contained in `L`.
 
 At the moment, there exists no such implementation in Sage.
 
 Drinfeld modules are standard arithmetic tools in the theory of function
-fields. See [Goss, Basic structures of function field arithmetic, 1998],
-[Rosen, Number theory in function fields, 2002]. Good resources are also
-[Gekeler, On finite Drinfeld modules, 1991], [Hayes, A brief introduction to
-Drinfeld modules, 1991] and [Caranay, Greenberg, Scheidler, Computing modular
-polynomials and isogenies of rank two Drinfeld modules, 2020]. The author of
+fields. See [Goss, *Basic structures of function field arithmetic*, 1998],
+[Rosen, *Number theory in function fields*, 2002]. Good resources are also
+[Gekeler, *On finite Drinfeld modules*, 1991], [Hayes, ''A brief introduction to
+Drinfeld modules*, 1991] and [Caranay, Greenberg, Scheidler, *Computing modular
+polynomials and isogenies of rank two Drinfeld modules'', 2020]. The author of
 this ticket got interested in Drinfeld modules with isogeny-based cryptographic
 applications in mind; see https://arxiv.org/abs/2203.06970.
 
@@ -84,8 +84,7 @@
 own magic method (`_repr_`, `_latex`, etc).
 
 In further versions, I wish to include:
-* methods in isogenies of Drinfeld modules (esp. Vélu's formula for Drinfeld
-* modules);
+* methods in isogenies of Drinfeld modules (esp. Vélu's formula for Drinfeld modules);
 * methods on the torsion of Drinfeld modules (module law and vector space law);
 * class methods (instanciate a random Drinfeld module, or from a j-invariant);
 * methods on the well-definition of a Drinfeld module on some sub-field of L.
``````




---

archive/issue_comments_671979.json:
```json
{
    "body": "<a id='comment:2'></a>\nSome quick comments:\n- I'm not completely sure that Drinfeld modules should be elements of some parent; maybe, actually, they could parents themselves (e.g. elliptic curves are parents) but it is also not that nice because it breaks the construction `phi(X^2)`; I do not know if having something outside this hierarchy is relevant here.\n- usually in Sage, we do not expose properties but methods, *e.g.* `phi.polynomial_ring()` is more appropriate than `phi.polynomial_ring`, etc.\n- for the development environment, to start with, I think you can simply create a new git branch on your local repository, work on it and push it here on trac when you're ready.",
    "created_at": "2022-04-16T06:32:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671979",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:2'></a>
Some quick comments:
- I'm not completely sure that Drinfeld modules should be elements of some parent; maybe, actually, they could parents themselves (e.g. elliptic curves are parents) but it is also not that nice because it breaks the construction `phi(X^2)`; I do not know if having something outside this hierarchy is relevant here.
- usually in Sage, we do not expose properties but methods, *e.g.* `phi.polynomial_ring()` is more appropriate than `phi.polynomial_ring`, etc.
- for the development environment, to start with, I think you can simply create a new git branch on your local repository, work on it and push it here on trac when you're ready.



---

archive/issue_events_099730.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-17T19:59:27Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33713#event-99730"
}
```




---

archive/issue_comments_671980.json:
```json
{
    "body": "<a id='comment:4'></a>\nHi Xavier, thank you for your input. Ok for the methods instead of properties. For the parent/coercion, the paragraph [*Parents and Elements*](https://doc.sagemath.org/html/en/reference/coercion/index.html#parents-and-elements) states\n  Most things in Sage are either parents or have a parent.\n\nI think it is quite nice, when in doubt about something, to be able to call `parent(phi)` and have the set of Drinfeld modules in which `phi` was defined. Of course, this is a bit redundant with `_repr_`.\n\nAnyway, the most important thing is `FiniteDrinfeldModule`, and this is where I start.",
    "created_at": "2022-04-19T11:04:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671980",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:4'></a>
Hi Xavier, thank you for your input. Ok for the methods instead of properties. For the parent/coercion, the paragraph [*Parents and Elements*](https://doc.sagemath.org/html/en/reference/coercion/index.html#parents-and-elements) states
  Most things in Sage are either parents or have a parent.

I think it is quite nice, when in doubt about something, to be able to call `parent(phi)` and have the set of Drinfeld modules in which `phi` was defined. Of course, this is a bit redundant with `_repr_`.

Anyway, the most important thing is `FiniteDrinfeldModule`, and this is where I start.



---

archive/issue_comments_671981.json:
```json
{
    "body": "**Commit:** [439907fd9a15f7abff7b000e9845806099a6d329](https://github.com/sagemath/sagetrac-mirror/commit/439907fd9a15f7abff7b000e9845806099a6d329)",
    "created_at": "2022-04-19T12:43:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671981",
    "user": "https://github.com/antoine-leudiere"
}
```


**Commit:** [439907fd9a15f7abff7b000e9845806099a6d329](https://github.com/sagemath/sagetrac-mirror/commit/439907fd9a15f7abff7b000e9845806099a6d329)



---

archive/issue_comments_671982.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -89,7 +89,7 @@\n * class methods (instanciate a random Drinfeld module, or from a j-invariant);\n * methods on the well-definition of a Drinfeld module on some sub-field of L.\n \n-Naturally, any input (especially negative) is more than welcomed!\n+Naturally, any input (especially negative) is more than welcome!\n \n ## The `FiniteDrinfeldModulesRankSet` and `FiniteDrinfeldModulesSet` classes\n \n``````\n",
    "created_at": "2022-04-19T12:43:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671982",
    "user": "https://github.com/antoine-leudiere"
}
```


**Description changed:**
``````diff
--- 
+++ 
@@ -89,7 +89,7 @@
 * class methods (instanciate a random Drinfeld module, or from a j-invariant);
 * methods on the well-definition of a Drinfeld module on some sub-field of L.
 
-Naturally, any input (especially negative) is more than welcomed!
+Naturally, any input (especially negative) is more than welcome!
 
 ## The `FiniteDrinfeldModulesRankSet` and `FiniteDrinfeldModulesSet` classes
 
``````




---

archive/issue_comments_671983.json:
```json
{
    "body": "**Branch:** [u/antoine-leudiere/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/antoine-leudiere/finite_drinfeld_modules)",
    "created_at": "2022-04-19T12:43:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671983",
    "user": "https://github.com/antoine-leudiere"
}
```


**Branch:** [u/antoine-leudiere/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/antoine-leudiere/finite_drinfeld_modules)



---

archive/issue_comments_671984.json:
```json
{
    "body": "<a id='comment:6'></a>\n* la case Author (ici plus haut) doit contenir le nom complet, c'est tout\n\n* il suffit de donner le nom de la branche, pas besoin de remplir la case commit",
    "created_at": "2022-04-19T18:37:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671984",
    "user": "https://github.com/fchapoton"
}
```


<a id='comment:6'></a>
* la case Author (ici plus haut) doit contenir le nom complet, c'est tout

* il suffit de donner le nom de la branche, pas besoin de remplir la case commit



---

archive/issue_comments_671985.json:
```json
{
    "body": "**Changing author** from \"Antoine Leudi\u00e8re (antoine-leudiere)\" to \"Antoine Leudi\u00e8re\".",
    "created_at": "2022-04-19T18:37:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671985",
    "user": "https://github.com/fchapoton"
}
```


**Changing author** from "Antoine Leudière (antoine-leudiere)" to "Antoine Leudière".



---

archive/issue_comments_671986.json:
```json
{
    "body": "<a id='comment:7'></a>\nIl existe une hi\u00e9rarchie : cat\u00e9gorie > parent > \u00e9l\u00e9ment.\n\nMoralement, chaque parent est un ensemble.\n\nPar exemple, la cat\u00e9gorie \"Groups\", dans laquelle se placent les parents qui sont des groupes, ces parents ayant eux m\u00eames des \u00e9l\u00e9ments. Pour un parent donn\u00e9, on peut demander sa cat\u00e9gorie par la m\u00e9thode `.category()` et aussi `.categories()`.\n\nPeut-\u00eatre qu'il n'est pas n\u00e9cessaire de cr\u00e9er la cat\u00e9gorie \"DrinfeldModules\" maintenant.",
    "created_at": "2022-04-19T18:43:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671986",
    "user": "https://github.com/fchapoton"
}
```


<a id='comment:7'></a>
Il existe une hiérarchie : catégorie > parent > élément.

Moralement, chaque parent est un ensemble.

Par exemple, la catégorie "Groups", dans laquelle se placent les parents qui sont des groupes, ces parents ayant eux mêmes des éléments. Pour un parent donné, on peut demander sa catégorie par la méthode `.category()` et aussi `.categories()`.

Peut-être qu'il n'est pas nécessaire de créer la catégorie "DrinfeldModules" maintenant.



---

archive/issue_comments_671987.json:
```json
{
    "body": "<a id='comment:8'></a>\nReplying to [chapoton](#comment%3A7):\n> Il existe une hi\u00e9rarchie : cat\u00e9gorie > parent > \u00e9l\u00e9ment.\n> \n> Moralement, chaque parent est un ensemble.\n> \n> Par exemple, la cat\u00e9gorie \"Groups\", dans laquelle se placent les parents qui sont des groupes, ces parents ayant eux m\u00eames des \u00e9l\u00e9ments. Pour un parent donn\u00e9, on peut demander sa cat\u00e9gorie par la m\u00e9thode `.category()` et aussi `.categories()`.\n> \n> Peut-\u00eatre qu'il n'est pas n\u00e9cessaire de cr\u00e9er la cat\u00e9gorie \"DrinfeldModules\" maintenant.\n\n\nMerci Fr\u00e9d\u00e9ric ; c'est entendu, nous verrons plus tard.",
    "created_at": "2022-04-20T08:44:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671987",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:8'></a>
Replying to [chapoton](#comment%3A7):
> Il existe une hiérarchie : catégorie > parent > élément.
> 
> Moralement, chaque parent est un ensemble.
> 
> Par exemple, la catégorie "Groups", dans laquelle se placent les parents qui sont des groupes, ces parents ayant eux mêmes des éléments. Pour un parent donné, on peut demander sa catégorie par la méthode `.category()` et aussi `.categories()`.
> 
> Peut-être qu'il n'est pas nécessaire de créer la catégorie "DrinfeldModules" maintenant.


Merci Frédéric ; c'est entendu, nous verrons plus tard.



---

archive/issue_comments_671988.json:
```json
{
    "body": "<a id='comment:9'></a>\nAh tiens, on parle fran\u00e7ais maintenant ici ?\nI switch to english because I think that other people might be interested.\n\nThe difficulty, I think, with Drinfeld modules is that they exhibit as the same time aspects of elements and parents.\nBy definition, they are ring homomorphisms from `Fq[X]` to some Ore polynomial ring. In this sense, they should be considered as elements of some hom space. However, in practice, my understanding is that we often view them as spaces (in general `Fqbar`) endowed with a semi-linear action of the algebra `Fq[X]`. As such, it makes sense to consider the category of Drinfeld modules and define methods which are usually related to parents (e.g. `rank`, `definition_field`, etc.).\n\nIMO, the situation is quite similar to what we have for group representations, which can be viewed either as group morphisms `G -> GLn(K)` or as `K`-vector spaces endowed with a linear action of `G`. In sage, the latter point of view is privilegied but I'm not sure we should follow the same pattern here because the most standard definition of Drinfeld modules are in terms of ring homomorphisms.",
    "created_at": "2022-04-23T08:27:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671988",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:9'></a>
Ah tiens, on parle français maintenant ici ?
I switch to english because I think that other people might be interested.

The difficulty, I think, with Drinfeld modules is that they exhibit as the same time aspects of elements and parents.
By definition, they are ring homomorphisms from `Fq[X]` to some Ore polynomial ring. In this sense, they should be considered as elements of some hom space. However, in practice, my understanding is that we often view them as spaces (in general `Fqbar`) endowed with a semi-linear action of the algebra `Fq[X]`. As such, it makes sense to consider the category of Drinfeld modules and define methods which are usually related to parents (e.g. `rank`, `definition_field`, etc.).

IMO, the situation is quite similar to what we have for group representations, which can be viewed either as group morphisms `G -> GLn(K)` or as `K`-vector spaces endowed with a linear action of `G`. In sage, the latter point of view is privilegied but I'm not sure we should follow the same pattern here because the most standard definition of Drinfeld modules are in terms of ring homomorphisms.



---

archive/issue_comments_671989.json:
```json
{
    "body": "<a id='comment:10'></a>\nThis is a good synthethis of the problem. It is true that most interesting\nproperties of Drinfeld modules come from the Fq[X]-algebra structure on Fqbar.\nHowever, the structure of ring homomorphism is richer and we should not forget\nit. For exemple, it is with it that we can easily define the rank or the\ncharacteristic polynomial. But in the meantime, talking about Drinfeld module\nas only ring homomorphisms kinda misses the point of those objects, as we are\nprimilarly interested in their action on Fqbar.\n\nThat's why my initial idea was to make drinfeld modules children of some\n`DrinfeldModuleSet` or `DrinfeldModuleCategory` (not too familiar with\nconventions here). I believe with this I can still make the class\n`FiniteDrinfeldModule` inherit `RingHomomorphism`.\n\nI plan on soon pushing a first draft of `FiniteDrinfeldModule` that inherits\n`RingHomomorphism`.",
    "created_at": "2022-04-25T06:32:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671989",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:10'></a>
This is a good synthethis of the problem. It is true that most interesting
properties of Drinfeld modules come from the Fq[X]-algebra structure on Fqbar.
However, the structure of ring homomorphism is richer and we should not forget
it. For exemple, it is with it that we can easily define the rank or the
characteristic polynomial. But in the meantime, talking about Drinfeld module
as only ring homomorphisms kinda misses the point of those objects, as we are
primilarly interested in their action on Fqbar.

That's why my initial idea was to make drinfeld modules children of some
`DrinfeldModuleSet` or `DrinfeldModuleCategory` (not too familiar with
conventions here). I believe with this I can still make the class
`FiniteDrinfeldModule` inherit `RingHomomorphism`.

I plan on soon pushing a first draft of `FiniteDrinfeldModule` that inherits
`RingHomomorphism`.



---

archive/issue_comments_671990.json:
```json
{
    "body": "**Changing commit** from \"[439907fd9a15f7abff7b000e9845806099a6d329](https://github.com/sagemath/sagetrac-mirror/commit/439907fd9a15f7abff7b000e9845806099a6d329)\" to \"[df3598cd28addbeea131fdaacb00c2acd9fae95e](https://github.com/sagemath/sagetrac-mirror/commit/df3598cd28addbeea131fdaacb00c2acd9fae95e)\".",
    "created_at": "2022-04-26T16:49:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671990",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[439907fd9a15f7abff7b000e9845806099a6d329](https://github.com/sagemath/sagetrac-mirror/commit/439907fd9a15f7abff7b000e9845806099a6d329)" to "[df3598cd28addbeea131fdaacb00c2acd9fae95e](https://github.com/sagemath/sagetrac-mirror/commit/df3598cd28addbeea131fdaacb00c2acd9fae95e)".



---

archive/issue_comments_671991.json:
```json
{
    "body": "<a id='comment:11'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/df3598cd28addbeea131fdaacb00c2acd9fae95e\">df3598c</a></td><td><code>Create a draft of FiniteDrinfeldModule</code></td></tr></table>\n",
    "created_at": "2022-04-26T16:49:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671991",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:11'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/df3598cd28addbeea131fdaacb00c2acd9fae95e">df3598c</a></td><td><code>Create a draft of FiniteDrinfeldModule</code></td></tr></table>




---

archive/issue_comments_671992.json:
```json
{
    "body": "**Changing commit** from \"[df3598cd28addbeea131fdaacb00c2acd9fae95e](https://github.com/sagemath/sagetrac-mirror/commit/df3598cd28addbeea131fdaacb00c2acd9fae95e)\" to \"[84c7b5b652ab828a68e492af31831fc25ed4b52a](https://github.com/sagemath/sagetrac-mirror/commit/84c7b5b652ab828a68e492af31831fc25ed4b52a)\".",
    "created_at": "2022-04-26T18:59:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671992",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[df3598cd28addbeea131fdaacb00c2acd9fae95e](https://github.com/sagemath/sagetrac-mirror/commit/df3598cd28addbeea131fdaacb00c2acd9fae95e)" to "[84c7b5b652ab828a68e492af31831fc25ed4b52a](https://github.com/sagemath/sagetrac-mirror/commit/84c7b5b652ab828a68e492af31831fc25ed4b52a)".



---

archive/issue_comments_671993.json:
```json
{
    "body": "<a id='comment:12'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/84c7b5b652ab828a68e492af31831fc25ed4b52a\">84c7b5b</a></td><td><code>Create draft for finite Drinfeld module doctest</code></td></tr></table>\n",
    "created_at": "2022-04-26T18:59:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671993",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:12'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/84c7b5b652ab828a68e492af31831fc25ed4b52a">84c7b5b</a></td><td><code>Create draft for finite Drinfeld module doctest</code></td></tr></table>




---

archive/issue_comments_671994.json:
```json
{
    "body": "<a id='comment:13'></a>\nHi guys.\n\nI commited and pushed an elementary *draft* for `FiniteDrinfeldModule` (the\nclass representing Drinfeld modules) and `FiniteDrinfeldModuleAction` (the\nclass representing the `\\Fq[X]`-action given by a Drinfeld module).\n\nYou can try them now. The (incomplete and rudimentary) doctest gives you usage\nexamples.\n\nAny feedback would be greatly appreciated, so that I do not go in the wrong\ndirection.\n\nSummary:\n\n* `FiniteDrinfeldModule` inherits `sage.rings.morphism.RingHomomorphism_im_gens`.\n* `FiniteDrinfeldModuleAction` inherits `sage.categories.action.Action`.\n* I tried to systematically check the validity of the user inputs. I still have\n  corner cases to cover though.\n* The computation of the action is done in\n  `FiniteDrinfeldModuleAction._act_`, but I really do not know if this is the\n  right place. The documentation was not clear to me so I chose this option via\n  trial and error and by looking at the code of `Action`.\n* Similarly, the method of `FiniteDrinfeldModule` used to get the associated\n  action is `_get_action_`, which seems wrong considering the `_` prefix.\n* I put those two classes in a single file, located in\n  `$SAGE_ROOT/src/sage/modules`. As discussed below, this may be misleading\n  considering that, *technically* a Drinfeld module is not a module but a\n  morphism. Furthermore, may be the two classes should be in separate files.",
    "created_at": "2022-04-26T19:23:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671994",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:13'></a>
Hi guys.

I commited and pushed an elementary *draft* for `FiniteDrinfeldModule` (the
class representing Drinfeld modules) and `FiniteDrinfeldModuleAction` (the
class representing the `\Fq[X]`-action given by a Drinfeld module).

You can try them now. The (incomplete and rudimentary) doctest gives you usage
examples.

Any feedback would be greatly appreciated, so that I do not go in the wrong
direction.

Summary:

* `FiniteDrinfeldModule` inherits `sage.rings.morphism.RingHomomorphism_im_gens`.
* `FiniteDrinfeldModuleAction` inherits `sage.categories.action.Action`.
* I tried to systematically check the validity of the user inputs. I still have
  corner cases to cover though.
* The computation of the action is done in
  `FiniteDrinfeldModuleAction._act_`, but I really do not know if this is the
  right place. The documentation was not clear to me so I chose this option via
  trial and error and by looking at the code of `Action`.
* Similarly, the method of `FiniteDrinfeldModule` used to get the associated
  action is `_get_action_`, which seems wrong considering the `_` prefix.
* I put those two classes in a single file, located in
  `$SAGE_ROOT/src/sage/modules`. As discussed below, this may be misleading
  considering that, *technically* a Drinfeld module is not a module but a
  morphism. Furthermore, may be the two classes should be in separate files.



---

archive/issue_comments_671995.json:
```json
{
    "body": "<a id='comment:14'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2723f99dbcb6005d7446e47ca3ea8d20f1f09b8c\">2723f99</a></td><td><code>Fix FiniteDrinfeldModule action in all.py</code></td></tr></table>\n",
    "created_at": "2022-04-27T12:47:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671995",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:14'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2723f99dbcb6005d7446e47ca3ea8d20f1f09b8c">2723f99</a></td><td><code>Fix FiniteDrinfeldModule action in all.py</code></td></tr></table>




---

archive/issue_comments_671996.json:
```json
{
    "body": "**Changing commit** from \"[84c7b5b652ab828a68e492af31831fc25ed4b52a](https://github.com/sagemath/sagetrac-mirror/commit/84c7b5b652ab828a68e492af31831fc25ed4b52a)\" to \"[2723f99dbcb6005d7446e47ca3ea8d20f1f09b8c](https://github.com/sagemath/sagetrac-mirror/commit/2723f99dbcb6005d7446e47ca3ea8d20f1f09b8c)\".",
    "created_at": "2022-04-27T12:47:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671996",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[84c7b5b652ab828a68e492af31831fc25ed4b52a](https://github.com/sagemath/sagetrac-mirror/commit/84c7b5b652ab828a68e492af31831fc25ed4b52a)" to "[2723f99dbcb6005d7446e47ca3ea8d20f1f09b8c](https://github.com/sagemath/sagetrac-mirror/commit/2723f99dbcb6005d7446e47ca3ea8d20f1f09b8c)".



---

archive/issue_comments_671997.json:
```json
{
    "body": "<a id='comment:15'></a>\n**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8bef6ba375e8b60448764395d46c72144c9a66a2\">8bef6ba</a></td><td><code>Refactor _latex_ method in FiniteDrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f0a9f630a6f7be1215f883cbb9d07f893ca27cb1\">f0a9f63</a></td><td><code>Refactor FiniteDrinfeldModuleAction</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/86348fff6bdd0aec5a414ed07925291cb4e13041\">86348ff</a></td><td><code>Add various getters for FiniteDrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2c24562b74fdcb23c8844d727a15d8c217ff0ec5\">2c24562</a></td><td><code>Add methods to deal with complex multiplication in FiniteDrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0499221177f9c76783cd672cb65ae52242a57c42\">0499221</a></td><td><code>Add methods to deal with isogenies in FiniteDrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3609c915438fd89da5686cc310be848b587f672a\">3609c91</a></td><td><code>Move FiniteDrinfeldModule to sage.rings.function_field</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e3fc37f4ab6d0ea5034970751686d891429c6d05\">e3fc37f</a></td><td><code>Fix method is_morphism in FiniteDrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0515d9b19b550ec27326bf978c9a0e8e555f4e65\">0515d9b</a></td><td><code>Add blank line before FiniteDrinfeldModuleAction (PEP8)</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8c848d901a85e52e2a05fe0f13a16a25199db812\">8c848d9</a></td><td><code>Refactor doctest in FiniteDrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7c96d1f73f6d0ee9054eff247ade1a597381a449\">7c96d1f</a></td><td><code>Alphabetically order methods in sage.rings.function_field.finite_drinfeld_module.py</code></td></tr></table>\n",
    "created_at": "2022-05-12T16:21:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671997",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:15'></a>
**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8bef6ba375e8b60448764395d46c72144c9a66a2">8bef6ba</a></td><td><code>Refactor _latex_ method in FiniteDrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f0a9f630a6f7be1215f883cbb9d07f893ca27cb1">f0a9f63</a></td><td><code>Refactor FiniteDrinfeldModuleAction</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/86348fff6bdd0aec5a414ed07925291cb4e13041">86348ff</a></td><td><code>Add various getters for FiniteDrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2c24562b74fdcb23c8844d727a15d8c217ff0ec5">2c24562</a></td><td><code>Add methods to deal with complex multiplication in FiniteDrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0499221177f9c76783cd672cb65ae52242a57c42">0499221</a></td><td><code>Add methods to deal with isogenies in FiniteDrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3609c915438fd89da5686cc310be848b587f672a">3609c91</a></td><td><code>Move FiniteDrinfeldModule to sage.rings.function_field</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e3fc37f4ab6d0ea5034970751686d891429c6d05">e3fc37f</a></td><td><code>Fix method is_morphism in FiniteDrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0515d9b19b550ec27326bf978c9a0e8e555f4e65">0515d9b</a></td><td><code>Add blank line before FiniteDrinfeldModuleAction (PEP8)</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8c848d901a85e52e2a05fe0f13a16a25199db812">8c848d9</a></td><td><code>Refactor doctest in FiniteDrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7c96d1f73f6d0ee9054eff247ade1a597381a449">7c96d1f</a></td><td><code>Alphabetically order methods in sage.rings.function_field.finite_drinfeld_module.py</code></td></tr></table>




---

archive/issue_comments_671998.json:
```json
{
    "body": "**Changing commit** from \"[2723f99dbcb6005d7446e47ca3ea8d20f1f09b8c](https://github.com/sagemath/sagetrac-mirror/commit/2723f99dbcb6005d7446e47ca3ea8d20f1f09b8c)\" to \"[7c96d1f73f6d0ee9054eff247ade1a597381a449](https://github.com/sagemath/sagetrac-mirror/commit/7c96d1f73f6d0ee9054eff247ade1a597381a449)\".",
    "created_at": "2022-05-12T16:21:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671998",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[2723f99dbcb6005d7446e47ca3ea8d20f1f09b8c](https://github.com/sagemath/sagetrac-mirror/commit/2723f99dbcb6005d7446e47ca3ea8d20f1f09b8c)" to "[7c96d1f73f6d0ee9054eff247ade1a597381a449](https://github.com/sagemath/sagetrac-mirror/commit/7c96d1f73f6d0ee9054eff247ade1a597381a449)".



---

archive/issue_comments_671999.json:
```json
{
    "body": "<a id='comment:16'></a>\nle linter (qui v\u00e9rifie certains d\u00e9tails dans le code) est pas content:\n\n```\nsage/rings/function_field/finite_drinfeld_module.py:295:12: E713 test for membership should be 'not in'\n16\nsage/rings/function_field/finite_drinfeld_module.py:389:12: E713 test for membership should be 'not in'\n17\nsage/rings/function_field/finite_drinfeld_module.py:411:12: E713 test for membership should be 'not in'\n18\nsage/rings/function_field/finite_drinfeld_module.py:420:12: E713 test for membership should be 'not in'\n19\nsage/rings/function_field/finite_drinfeld_module.py:453:12: E713 test for membership should be 'not in'\n```",
    "created_at": "2022-05-12T19:20:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-671999",
    "user": "https://github.com/fchapoton"
}
```


<a id='comment:16'></a>
le linter (qui vérifie certains détails dans le code) est pas content:

```
sage/rings/function_field/finite_drinfeld_module.py:295:12: E713 test for membership should be 'not in'
16
sage/rings/function_field/finite_drinfeld_module.py:389:12: E713 test for membership should be 'not in'
17
sage/rings/function_field/finite_drinfeld_module.py:411:12: E713 test for membership should be 'not in'
18
sage/rings/function_field/finite_drinfeld_module.py:420:12: E713 test for membership should be 'not in'
19
sage/rings/function_field/finite_drinfeld_module.py:453:12: E713 test for membership should be 'not in'
```



---

archive/issue_comments_672000.json:
```json
{
    "body": "<a id='comment:17'></a>\nThank you Fr\u00e9d\u00e9ric for the reminder. I'll be sure to check that out.\n\nReplying to [chapoton](#comment%3A16):\n> le linter (qui v\u00e9rifie certains d\u00e9tails dans le code) est pas content:\n> \n> ```\n> sage/rings/function_field/finite_drinfeld_module.py:295:12: E713 test for membership should be 'not in'\n> 16\n> sage/rings/function_field/finite_drinfeld_module.py:389:12: E713 test for membership should be 'not in'\n> 17\n> sage/rings/function_field/finite_drinfeld_module.py:411:12: E713 test for membership should be 'not in'\n> 18\n> sage/rings/function_field/finite_drinfeld_module.py:420:12: E713 test for membership should be 'not in'\n> 19\n> sage/rings/function_field/finite_drinfeld_module.py:453:12: E713 test for membership should be 'not in'\n> ```\n",
    "created_at": "2022-05-13T09:22:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672000",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:17'></a>
Thank you Frédéric for the reminder. I'll be sure to check that out.

Replying to [chapoton](#comment%3A16):
> le linter (qui vérifie certains détails dans le code) est pas content:
> 
> ```
> sage/rings/function_field/finite_drinfeld_module.py:295:12: E713 test for membership should be 'not in'
> 16
> sage/rings/function_field/finite_drinfeld_module.py:389:12: E713 test for membership should be 'not in'
> 17
> sage/rings/function_field/finite_drinfeld_module.py:411:12: E713 test for membership should be 'not in'
> 18
> sage/rings/function_field/finite_drinfeld_module.py:420:12: E713 test for membership should be 'not in'
> 19
> sage/rings/function_field/finite_drinfeld_module.py:453:12: E713 test for membership should be 'not in'
> ```




---

archive/issue_comments_672001.json:
```json
{
    "body": "<a id='comment:19'></a>\nHello Antoine, \nthank you for this new feature, it looks very well done! Is there a reason why you only consider Drinfeld modules over finite fields? Some times ago I did a basic implementation of Drinfeld modules over A = Fq[T] (see https://github.com/DavidAyotte/drinfeld_modules) (still unfinished, my end goal is to work with Drinfeld modular forms). Also, do you plan to implement a constructor for your Drinfeld module class? For example, given a finite list of element in a finite field `[a_0, a_1,... , a_r]`, the constructor could create a Drinfeld module of rank r defined by \n\n`T |---> a_0 + a_1*tau + ... + a_r*tau^r`   (tau = frobenius endomorphism).\n\nI think that this would improve the usage of this implementation for the end-user. Anyhow, I will be looking forward to this ticket and I will be glad to help you if you have any questions!",
    "created_at": "2022-05-13T21:14:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672001",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:19'></a>
Hello Antoine, 
thank you for this new feature, it looks very well done! Is there a reason why you only consider Drinfeld modules over finite fields? Some times ago I did a basic implementation of Drinfeld modules over A = Fq[T] (see https://github.com/DavidAyotte/drinfeld_modules) (still unfinished, my end goal is to work with Drinfeld modular forms). Also, do you plan to implement a constructor for your Drinfeld module class? For example, given a finite list of element in a finite field `[a_0, a_1,... , a_r]`, the constructor could create a Drinfeld module of rank r defined by 

`T |---> a_0 + a_1*tau + ... + a_r*tau^r`   (tau = frobenius endomorphism).

I think that this would improve the usage of this implementation for the end-user. Anyhow, I will be looking forward to this ticket and I will be glad to help you if you have any questions!



---

archive/issue_comments_672002.json:
```json
{
    "body": "<a id='comment:20'></a>\nDavid,\n\nIt is very nice to have somebody else interested in Drinfeld modules, thank you for reaching out!\n\nReplying to [gh-DavidAyotte](#comment%3A19):\n> Hello Antoine, \n> thank you for this new feature, it looks very well done! Is there a reason why you only consider Drinfeld modules over finite fields? Some times ago I did a basic implementation of Drinfeld modules over A = Fq[T] (see https://github.com/DavidAyotte/drinfeld_modules) (still unfinished, my end goal is to work with Drinfeld modular forms).\n\n\nThe main reason I only consider *finite* Drinfeld modules is practical. I am not too familiar with general Drinfeld modules at the moment (for our cryptographic purposes we mainly worked with rank two finite Drinfeld modules), and I have an incremental vision of development (I would rather begin with a small but well-understood module than with a giant monolithic monster). In the long term I would very much want to implement more general Drinfeld modules, even though they are harder to work with.\n\n\n> Also, do you plan to implement a constructor for your Drinfeld module class? For example, given a finite list of element in a finite field `[a_0, a_1,... , a_r]`, the constructor could create a Drinfeld module of rank r defined by \n> \n> `T |---> a_0 + a_1*tau + ... + a_r*tau^r`   (tau = frobenius endomorphism).\n> \n> I think that this would improve the usage of this implementation for the end-user. Anyhow, I will be looking forward to this ticket and I will be glad to help you if you have any questions!\n\n\nThis is a nice suggestion. If I am not mistaken, the idiomatic way to do this is to call the parent category of the objects. With Ore polynomials, one would do (see penultimate line):\n\n```\nsage: Fq = GF(3^2)\nsage: z2 = Fq.gen()\nsage: FqX.<X> = Fq[]\nsage: p = X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5\nsage: L = Fq.extension(6)\nsage: frob = L.frobenius_endomorphism(2)\nsage: Ltau.<t> = OrePolynomialRing(L, frob)\nsage: omega = p.roots(L, multiplicities=False)[0]\nsage: phi_X = Ltau([omega, 1, 1])\nsage: phi = FiniteDrinfeldModule(FqX, phi_X, p)\n```\n\nAs my implementation requires multiple arguments for `__init__`, and that at some point either the user or the code in `__init__` needs to access the Ore polynomial ring, I think it is best not to bloat the code and to let the user use the \"list constructor\" of `OrePolynomialRing` if they want. Consequently, at the moment, I do not think that I should add this constructor to `FiniteDrinfeldModule`.\n\nAnother possibility however, is to create the category of finite Drinfeld modules (with respect to those fixed `FqX` and `Ltau`), and to use the list constructor on them:\n\n```\nsage: parent = phi.parent()\nCategory of finite Drinfeld modules from ... to ...\nsage: psi = parent([omega, 1, 1])\n```\n\nI hope this is clear; tell me if it is not. Feel free to continue the discussion!\n\nAntoine\n\n*EDIT*.: The possibility of creating a class representing the category of Drinfeld modules was already discussed in this thread. It is not clear yet if we should add this feature.",
    "created_at": "2022-05-16T10:56:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672002",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:20'></a>
David,

It is very nice to have somebody else interested in Drinfeld modules, thank you for reaching out!

Replying to [gh-DavidAyotte](#comment%3A19):
> Hello Antoine, 
> thank you for this new feature, it looks very well done! Is there a reason why you only consider Drinfeld modules over finite fields? Some times ago I did a basic implementation of Drinfeld modules over A = Fq[T] (see https://github.com/DavidAyotte/drinfeld_modules) (still unfinished, my end goal is to work with Drinfeld modular forms).


The main reason I only consider *finite* Drinfeld modules is practical. I am not too familiar with general Drinfeld modules at the moment (for our cryptographic purposes we mainly worked with rank two finite Drinfeld modules), and I have an incremental vision of development (I would rather begin with a small but well-understood module than with a giant monolithic monster). In the long term I would very much want to implement more general Drinfeld modules, even though they are harder to work with.


> Also, do you plan to implement a constructor for your Drinfeld module class? For example, given a finite list of element in a finite field `[a_0, a_1,... , a_r]`, the constructor could create a Drinfeld module of rank r defined by 
> 
> `T |---> a_0 + a_1*tau + ... + a_r*tau^r`   (tau = frobenius endomorphism).
> 
> I think that this would improve the usage of this implementation for the end-user. Anyhow, I will be looking forward to this ticket and I will be glad to help you if you have any questions!


This is a nice suggestion. If I am not mistaken, the idiomatic way to do this is to call the parent category of the objects. With Ore polynomials, one would do (see penultimate line):

```
sage: Fq = GF(3^2)
sage: z2 = Fq.gen()
sage: FqX.<X> = Fq[]
sage: p = X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5
sage: L = Fq.extension(6)
sage: frob = L.frobenius_endomorphism(2)
sage: Ltau.<t> = OrePolynomialRing(L, frob)
sage: omega = p.roots(L, multiplicities=False)[0]
sage: phi_X = Ltau([omega, 1, 1])
sage: phi = FiniteDrinfeldModule(FqX, phi_X, p)
```

As my implementation requires multiple arguments for `__init__`, and that at some point either the user or the code in `__init__` needs to access the Ore polynomial ring, I think it is best not to bloat the code and to let the user use the "list constructor" of `OrePolynomialRing` if they want. Consequently, at the moment, I do not think that I should add this constructor to `FiniteDrinfeldModule`.

Another possibility however, is to create the category of finite Drinfeld modules (with respect to those fixed `FqX` and `Ltau`), and to use the list constructor on them:

```
sage: parent = phi.parent()
Category of finite Drinfeld modules from ... to ...
sage: psi = parent([omega, 1, 1])
```

I hope this is clear; tell me if it is not. Feel free to continue the discussion!

Antoine

*EDIT*.: The possibility of creating a class representing the category of Drinfeld modules was already discussed in this thread. It is not clear yet if we should add this feature.



---

archive/issue_comments_672003.json:
```json
{
    "body": "**Changing commit** from \"[7c96d1f73f6d0ee9054eff247ade1a597381a449](https://github.com/sagemath/sagetrac-mirror/commit/7c96d1f73f6d0ee9054eff247ade1a597381a449)\" to \"[8db54f202036320ae848576f93a68a5e5f579fb6](https://github.com/sagemath/sagetrac-mirror/commit/8db54f202036320ae848576f93a68a5e5f579fb6)\".",
    "created_at": "2022-05-16T11:05:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672003",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[7c96d1f73f6d0ee9054eff247ade1a597381a449](https://github.com/sagemath/sagetrac-mirror/commit/7c96d1f73f6d0ee9054eff247ade1a597381a449)" to "[8db54f202036320ae848576f93a68a5e5f579fb6](https://github.com/sagemath/sagetrac-mirror/commit/8db54f202036320ae848576f93a68a5e5f579fb6)".



---

archive/issue_comments_672004.json:
```json
{
    "body": "<a id='comment:21'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1a7891f0bbbd8486a511407df223a436df3b08f9\">1a7891f</a></td><td><code>Create class FiniteDrinfeldModule_rank_two</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8db54f202036320ae848576f93a68a5e5f579fb6\">8db54f2</a></td><td><code>Merge branch 'develop' into u/antoine-leudiere/finite_drinfeld_modules</code></td></tr></table>\n",
    "created_at": "2022-05-16T11:05:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672004",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:21'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1a7891f0bbbd8486a511407df223a436df3b08f9">1a7891f</a></td><td><code>Create class FiniteDrinfeldModule_rank_two</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8db54f202036320ae848576f93a68a5e5f579fb6">8db54f2</a></td><td><code>Merge branch 'develop' into u/antoine-leudiere/finite_drinfeld_modules</code></td></tr></table>




---

archive/issue_comments_672005.json:
```json
{
    "body": "<a id='comment:22'></a>\n> at some point either the user or the code in __init__ needs to access the Ore polynomial ring.\n\n\nYes indeed that makes very much sense. I had in mind a much simpler example, but for the example you gave you indeed need to create all these objects. As you said, let's not bloat to much this ticket.",
    "created_at": "2022-05-16T13:05:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672005",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:22'></a>
> at some point either the user or the code in __init__ needs to access the Ore polynomial ring.


Yes indeed that makes very much sense. I had in mind a much simpler example, but for the example you gave you indeed need to create all these objects. As you said, let's not bloat to much this ticket.



---

archive/issue_comments_672006.json:
```json
{
    "body": "<a id='comment:23'></a>\nReplying to [gh-DavidAyotte](#comment%3A22):\n> As you said, let's not bloat to much this ticket.\n\n\nOh I was talking about not bloating the *code*, this ticket is the best place to discuss! I literally opened it for this purpose. By all means, feel free to post here!\n\nFurthermore, I do not like the fact that instantiating a `FiniteDrinfeldModule` currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.",
    "created_at": "2022-05-16T13:15:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672006",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:23'></a>
Replying to [gh-DavidAyotte](#comment%3A22):
> As you said, let's not bloat to much this ticket.


Oh I was talking about not bloating the *code*, this ticket is the best place to discuss! I literally opened it for this purpose. By all means, feel free to post here!

Furthermore, I do not like the fact that instantiating a `FiniteDrinfeldModule` currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.



---

archive/issue_comments_672007.json:
```json
{
    "body": "<a id='comment:24'></a>\n> Furthermore, I do not like the fact that instantiating a FiniteDrinfeldModule currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.\n\n\nThis is also my concern and my idea was this \"list constructor\", but it is not as simple as that. Let's think of it and we'll surely come up with something.",
    "created_at": "2022-05-16T13:18:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672007",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:24'></a>
> Furthermore, I do not like the fact that instantiating a FiniteDrinfeldModule currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.


This is also my concern and my idea was this "list constructor", but it is not as simple as that. Let's think of it and we'll surely come up with something.



---

archive/issue_comments_672008.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [antoine-leudiere](#comment%3A23):\n> Furthermore, I do not like the fact that instantiating a `FiniteDrinfeldModule` currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.\n\n\nThe same in 6 lines:\n\n```\nsage: Fq.<z2> = GF(3^2)\nsage: FqX.<X> = Fq[]\nsage: p = X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5\nsage: L.<omega> = Fq.extension(p)\nsage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))\nsage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2, p)\n```\n\nand I assume that you can further reduce to 5 lines by making optimal the argument `characteristic`:\n\n```\nsage: Fq.<z2> = GF(3^2)\nsage: FqX.<X> = Fq[]\nsage: L.<omega> = Fq.extension(X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5)\nsage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))\nsage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2)\n```\n\nI agree that it will be a little be slower because `L` is here a \"quotient polynomial ring\" and not a \"finite field\". However, this should be fixed after ticket #28485 (if merged one day).",
    "created_at": "2022-05-16T18:19:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672008",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:25'></a>
Replying to [antoine-leudiere](#comment%3A23):
> Furthermore, I do not like the fact that instantiating a `FiniteDrinfeldModule` currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.


The same in 6 lines:

```
sage: Fq.<z2> = GF(3^2)
sage: FqX.<X> = Fq[]
sage: p = X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5
sage: L.<omega> = Fq.extension(p)
sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))
sage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2, p)
```

and I assume that you can further reduce to 5 lines by making optimal the argument `characteristic`:

```
sage: Fq.<z2> = GF(3^2)
sage: FqX.<X> = Fq[]
sage: L.<omega> = Fq.extension(X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5)
sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))
sage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2)
```

I agree that it will be a little be slower because `L` is here a "quotient polynomial ring" and not a "finite field". However, this should be fixed after ticket #28485 (if merged one day).



---

archive/issue_comments_672009.json:
```json
{
    "body": "<a id='comment:26'></a>\nHi Xavier and thanks a lot for the input. Yeah, with those tricks we can shorten those lines. Some details:\n\n- At the moment, I cannot use the syntax `Fq.<z2> = GF(3^2)`. It is because of ticket:33807 and the fact that I need `is_subring` in the method `FiniteDrinfeldModule.change_ring`. This is a bit unstable...\n\n- However I believe there is a mistake in your snippet. In my example, `L` is *not* the extension of `Fq` with modulus `p`. It is a larger extension, which contains `Fq[X]/p = Fq(omega)`. Long story short I need to know the polynomial that generates `Fq(omega)`, where `omega` is the constant coefficient of `phi_X` (see e.g. `frobenius_norm`). But `omega` does not need to generate `L`. I discussed about this in [this thread](https://ask.sagemath.org/question/62312/subextension-over-non-prime-subfield-as-a-quotient/). Hope this is clear...\n\nBy the way, better support for relative field extensions would indeed make things so much easier. \n\n\nReplying to [caruso](#comment%3A25):\n> Replying to [antoine-leudiere](#comment%3A23):\n> > Furthermore, I do not like the fact that instantiating a `FiniteDrinfeldModule` currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.\n\n> \n> The same in 6 lines:\n> \n> ```\n> sage: Fq.<z2> = GF(3^2)\n> sage: FqX.<X> = Fq[]\n> sage: p = X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5\n> sage: L.<omega> = Fq.extension(p)\n> sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))\n> sage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2, p)\n> ```\n> \n> and I assume that you can further reduce to 5 lines by making optimal the argument `characteristic`:\n> \n> ```\n> sage: Fq.<z2> = GF(3^2)\n> sage: FqX.<X> = Fq[]\n> sage: L.<omega> = Fq.extension(X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5)\n> sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))\n> sage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2)\n> ```\n> \n> I agree that it will be a little be slower because `L` is here a \"quotient polynomial ring\" and not a \"finite field\". However, this should be fixed after ticket #28485 (if merged one day).\n",
    "created_at": "2022-05-17T15:23:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672009",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:26'></a>
Hi Xavier and thanks a lot for the input. Yeah, with those tricks we can shorten those lines. Some details:

- At the moment, I cannot use the syntax `Fq.<z2> = GF(3^2)`. It is because of ticket:33807 and the fact that I need `is_subring` in the method `FiniteDrinfeldModule.change_ring`. This is a bit unstable...

- However I believe there is a mistake in your snippet. In my example, `L` is *not* the extension of `Fq` with modulus `p`. It is a larger extension, which contains `Fq[X]/p = Fq(omega)`. Long story short I need to know the polynomial that generates `Fq(omega)`, where `omega` is the constant coefficient of `phi_X` (see e.g. `frobenius_norm`). But `omega` does not need to generate `L`. I discussed about this in [this thread](https://ask.sagemath.org/question/62312/subextension-over-non-prime-subfield-as-a-quotient/). Hope this is clear...

By the way, better support for relative field extensions would indeed make things so much easier. 


Replying to [caruso](#comment%3A25):
> Replying to [antoine-leudiere](#comment%3A23):
> > Furthermore, I do not like the fact that instantiating a `FiniteDrinfeldModule` currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.

> 
> The same in 6 lines:
> 
> ```
> sage: Fq.<z2> = GF(3^2)
> sage: FqX.<X> = Fq[]
> sage: p = X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5
> sage: L.<omega> = Fq.extension(p)
> sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))
> sage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2, p)
> ```
> 
> and I assume that you can further reduce to 5 lines by making optimal the argument `characteristic`:
> 
> ```
> sage: Fq.<z2> = GF(3^2)
> sage: FqX.<X> = Fq[]
> sage: L.<omega> = Fq.extension(X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5)
> sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))
> sage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2)
> ```
> 
> I agree that it will be a little be slower because `L` is here a "quotient polynomial ring" and not a "finite field". However, this should be fixed after ticket #28485 (if merged one day).




---

archive/issue_comments_672010.json:
```json
{
    "body": "<a id='comment:27'></a>\nReplying to [antoine-leudiere](#comment%3A26):\n> - At the moment, I cannot use the syntax `Fq.<z2> = GF(3^2)`. It is because of ticket:33807 and the fact that I need `is_subring` in the method `FiniteDrinfeldModule.change_ring`. This is a bit unstable...\n\n\nMaybe, you should consider using `has_coerce_map_from` instead?\n\n> - However I believe there is a mistake in your snippet. In my example, `L` is *not* the extension of `Fq` with modulus `p`. It is a larger extension, which contains `Fq[X]/p = Fq(omega)`.\n\n\nAh okay. I actually thought that there was a typo in your code :-/.\nBut then, you need to construct `L` and `omega` separately and it is normal that the code becomes longer...\n\n> Long story short I need to know the polynomial that generates `Fq(omega)`, where `omega` is the constant coefficient of `phi_X` (see e.g. `frobenius_norm`). But `omega` does not need to generate `L`. I discussed about this in [this thread](https://ask.sagemath.org/question/62312/subextension-over-non-prime-subfield-as-a-quotient/). Hope this is clear...\n\n\nIt is. But in which situation do you really need this construction?",
    "created_at": "2022-05-17T20:16:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672010",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:27'></a>
Replying to [antoine-leudiere](#comment%3A26):
> - At the moment, I cannot use the syntax `Fq.<z2> = GF(3^2)`. It is because of ticket:33807 and the fact that I need `is_subring` in the method `FiniteDrinfeldModule.change_ring`. This is a bit unstable...


Maybe, you should consider using `has_coerce_map_from` instead?

> - However I believe there is a mistake in your snippet. In my example, `L` is *not* the extension of `Fq` with modulus `p`. It is a larger extension, which contains `Fq[X]/p = Fq(omega)`.


Ah okay. I actually thought that there was a typo in your code :-/.
But then, you need to construct `L` and `omega` separately and it is normal that the code becomes longer...

> Long story short I need to know the polynomial that generates `Fq(omega)`, where `omega` is the constant coefficient of `phi_X` (see e.g. `frobenius_norm`). But `omega` does not need to generate `L`. I discussed about this in [this thread](https://ask.sagemath.org/question/62312/subextension-over-non-prime-subfield-as-a-quotient/). Hope this is clear...


It is. But in which situation do you really need this construction?



---

archive/issue_comments_672011.json:
```json
{
    "body": "<a id='comment:28'></a>\nReplying to [caruso](#comment%3A27):\n> Replying to [antoine-leudiere](#comment%3A26):\n> > - At the moment, I cannot use the syntax `Fq.<z2> = GF(3^2)`. It is because of ticket:33807 and the fact that I need `is_subring` in the method `FiniteDrinfeldModule.change_ring`. This is a bit unstable...\n \n> \n> Maybe, you should consider using `has_coerce_map_from` instead?\n\n\nThanks for the suggestion. Apparently, nope. The method `is_subring` (method of class `Ring`) is defined in `src/sage/rings/ring.pyx`, and it is roughly defined like this:\n\n```\ndef is_subring(self, other):\n    if self is other:\n        return True\n    try:\n        return self.Hom(other).natural_map().is_injective()\n    except (TypeError, AttributeError):\n        return False\n```\n\nSince we have this `(version `SageMath version 9.6, Release Date: 2022-05-15`):\n\n```\nsage: Fq.<z2> = GF(3^2)\nsage: L = Fq.extension(6)\nsage: M = L.extension(2)\nsage: Fq.is_subring(M)\nFalse\nsage: Hom(Fq, M).natural_map()\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-5-4531a212934e> in <module>\n----> 1 Hom(Fq, M).natural_map()\n\n~/pro/code/finite_drinfeld_modules-sage/source/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/rings/homset.py in natural_map(self)\n    209         f = self.codomain().coerce_map_from(self.domain())\n    210         if f is None:\n--> 211             raise TypeError(\"natural coercion morphism from %s to %s not defined\"%(self.domain(), self.codomain()))\n    212         return f\n    213 \n\nTypeError: natural coercion morphism from Finite Field in z2 of size 3^2 to Finite Field in z24 of size 3^24 not defined\nsage: \n```\n\nI seems that we really need a fix. For the moment I don't feel like making it myself: the class `Ring` is the base of so many things, and I do not want to break anything. \n\n\n> > Long story short I need to know the polynomial that generates `Fq(omega)`, where `omega` is the constant coefficient of `phi_X` (see e.g. `frobenius_norm`). But `omega` does not need to generate `L`. I discussed about this in [this thread](https://ask.sagemath.org/question/62312/subextension-over-non-prime-subfield-as-a-quotient/). Hope this is clear...\n\n> \n> It is. But in which situation do you really need this construction?\n\n\nThe constant term `omega` is used to calculate the images under the Drinfeld module (seen as a morphism).\n\nThe prime polynomial `characteristic` is mainly used to gather information on complex multiplication. More precisely, the Frobenius norm a rank two Drinfeld module is (up to multiplying by a constant) a power of `characteristic` ([Gekeler, Th. 2.11](https://www.ams.org/journals/tran/2008-360-04/S0002-9947-07-04558-8/S0002-9947-07-04558-8.pdf); see also [Schost-Mussleh, Prop. 3](https://arxiv.org/pdf/1907.12731.pdf)). With this information, we can compute the characteristic polynomial and decide if the D.m. is supersingular.\n\nNote however that I do not need to built the relative / intermediate extensions as I first (wrongly) thought. It seems that I can do anything with just the constant term `omega` and the characteristic `characteristic`.",
    "created_at": "2022-05-18T09:52:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672011",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:28'></a>
Replying to [caruso](#comment%3A27):
> Replying to [antoine-leudiere](#comment%3A26):
> > - At the moment, I cannot use the syntax `Fq.<z2> = GF(3^2)`. It is because of ticket:33807 and the fact that I need `is_subring` in the method `FiniteDrinfeldModule.change_ring`. This is a bit unstable...
 
> 
> Maybe, you should consider using `has_coerce_map_from` instead?


Thanks for the suggestion. Apparently, nope. The method `is_subring` (method of class `Ring`) is defined in `src/sage/rings/ring.pyx`, and it is roughly defined like this:

```
def is_subring(self, other):
    if self is other:
        return True
    try:
        return self.Hom(other).natural_map().is_injective()
    except (TypeError, AttributeError):
        return False
```

Since we have this `(version `SageMath version 9.6, Release Date: 2022-05-15`):

```
sage: Fq.<z2> = GF(3^2)
sage: L = Fq.extension(6)
sage: M = L.extension(2)
sage: Fq.is_subring(M)
False
sage: Hom(Fq, M).natural_map()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-5-4531a212934e> in <module>
----> 1 Hom(Fq, M).natural_map()

~/pro/code/finite_drinfeld_modules-sage/source/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/rings/homset.py in natural_map(self)
    209         f = self.codomain().coerce_map_from(self.domain())
    210         if f is None:
--> 211             raise TypeError("natural coercion morphism from %s to %s not defined"%(self.domain(), self.codomain()))
    212         return f
    213 

TypeError: natural coercion morphism from Finite Field in z2 of size 3^2 to Finite Field in z24 of size 3^24 not defined
sage: 
```

I seems that we really need a fix. For the moment I don't feel like making it myself: the class `Ring` is the base of so many things, and I do not want to break anything. 


> > Long story short I need to know the polynomial that generates `Fq(omega)`, where `omega` is the constant coefficient of `phi_X` (see e.g. `frobenius_norm`). But `omega` does not need to generate `L`. I discussed about this in [this thread](https://ask.sagemath.org/question/62312/subextension-over-non-prime-subfield-as-a-quotient/). Hope this is clear...

> 
> It is. But in which situation do you really need this construction?


The constant term `omega` is used to calculate the images under the Drinfeld module (seen as a morphism).

The prime polynomial `characteristic` is mainly used to gather information on complex multiplication. More precisely, the Frobenius norm a rank two Drinfeld module is (up to multiplying by a constant) a power of `characteristic` ([Gekeler, Th. 2.11](https://www.ams.org/journals/tran/2008-360-04/S0002-9947-07-04558-8/S0002-9947-07-04558-8.pdf); see also [Schost-Mussleh, Prop. 3](https://arxiv.org/pdf/1907.12731.pdf)). With this information, we can compute the characteristic polynomial and decide if the D.m. is supersingular.

Note however that I do not need to built the relative / intermediate extensions as I first (wrongly) thought. It seems that I can do anything with just the constant term `omega` and the characteristic `characteristic`.



---

archive/issue_comments_672012.json:
```json
{
    "body": "<a id='comment:30'></a>\nThere is a generic `Representation` class that was implemented within the past few years as an attempt by me to figure out what a good framework for representation theory would be in Sage. So I am open to alternatives for how to do these implementations.\n\nThat being said, a representation is not a morphism, nor do I think it should be implemented as one. Strictly speaking it is a pair `(V, f)`, where `V` is a (always? free) module and `f: A -> End(V)` a homomorphism (of objects in whatever category `A` is). What is typical in my area of representation theory is to equate the pair with the module, which we can think of it as an `A`-module when `A` is an algebra. Consequently, I think the way to model this in Sage: have a module with an action of `A` (which Sage, sometimes secretly, treats as a morphism). Consequently, representations should be parents.\n\nNote that there is also the `_acted_upon_` and `_act_on_` methods for implementing actions. Although if you are interested in properties tied to `f`, then your current implementation might be best.",
    "created_at": "2022-06-08T06:13:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672012",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:30'></a>
There is a generic `Representation` class that was implemented within the past few years as an attempt by me to figure out what a good framework for representation theory would be in Sage. So I am open to alternatives for how to do these implementations.

That being said, a representation is not a morphism, nor do I think it should be implemented as one. Strictly speaking it is a pair `(V, f)`, where `V` is a (always? free) module and `f: A -> End(V)` a homomorphism (of objects in whatever category `A` is). What is typical in my area of representation theory is to equate the pair with the module, which we can think of it as an `A`-module when `A` is an algebra. Consequently, I think the way to model this in Sage: have a module with an action of `A` (which Sage, sometimes secretly, treats as a morphism). Consequently, representations should be parents.

Note that there is also the `_acted_upon_` and `_act_on_` methods for implementing actions. Although if you are interested in properties tied to `f`, then your current implementation might be best.



---

archive/issue_comments_672013.json:
```json
{
    "body": "<a id='comment:31'></a>\nHello Travis, I allow myself to add to this conversation because Drinfeld module plays a central role in my research. Personnally, I think that this is a tricky problem because most people who works with Drinfeld modules (me included) do not see them as representation. They are mostly objects with a *geometric* flavor rather than algebraic. In fact, they are analogues of elliptic curves in the finite characteristic function field setting. I believe that it would be non-standard for [SageMath](SageMath) to implement Drinfeld modules as actual modules with an action of a ring instead of a morphism.\n\nI also think that Drinfeld modules should be their own parent and category (this was already discussed at the beginning of this thread). One problem here would be the question of \"elements\". This is because we don't really work with elements of the object, but more with the properties of the object. In other words, people works with the *object and its properties* rather than with the *object and its elements*.",
    "created_at": "2022-06-08T13:48:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672013",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:31'></a>
Hello Travis, I allow myself to add to this conversation because Drinfeld module plays a central role in my research. Personnally, I think that this is a tricky problem because most people who works with Drinfeld modules (me included) do not see them as representation. They are mostly objects with a *geometric* flavor rather than algebraic. In fact, they are analogues of elliptic curves in the finite characteristic function field setting. I believe that it would be non-standard for [SageMath](SageMath) to implement Drinfeld modules as actual modules with an action of a ring instead of a morphism.

I also think that Drinfeld modules should be their own parent and category (this was already discussed at the beginning of this thread). One problem here would be the question of "elements". This is because we don't really work with elements of the object, but more with the properties of the object. In other words, people works with the *object and its properties* rather than with the *object and its elements*.



---

archive/issue_comments_672014.json:
```json
{
    "body": "<a id='comment:32'></a>\nThanks Travis and David for the input. Like David, I never thought of Drinfeld\nmodules as representations, but I will consider it.",
    "created_at": "2022-06-08T15:01:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672014",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:32'></a>
Thanks Travis and David for the input. Like David, I never thought of Drinfeld
modules as representations, but I will consider it.



---

archive/issue_comments_672015.json:
```json
{
    "body": "<a id='comment:33'></a>\nA quick status report. I had a lot to do in the last few weeks and I did not really work on\nthe code. That being said, there are three main things left to do:\n\n1. Write doctests.\n\n2. Add an option to the constructor `OrePolynomialRing` so that `F2tau.<t> = OrePolynomialRing(GF(2), GF(2).frobenius_endomorphism())` builds a real Ore algebra and not a regular polynomial ring.\n\n3. Implement a *smart* mechanism so that the constructor of `FiniteDrinfeldModule` autonomously decides (depending on the input) to instantiate `FiniteDrinfeldModule` or `FiniteDrinfeldModule_rank_two`. Like this:\n\n```\nsage: psi = FiniteDrinfeldModule(FqX, omega + t^5, characteristic)\nsage: type(psi)\n<class 'sage.rings.function_field.finite_drinfeld_module.FiniteDrinfeldModule'>\nsage: phi = FiniteDrinfeldModule(FqX, omega + t^2, characteristic)\nsage: type(phi)\n<class 'sage.rings.function_field.finite_drinfeld_module.FiniteDrinfeldModule_rank_two'>\n```\n\nGoal 1) is straightforward. \n\nGoal 2) should be OK; I discussed this with Xavier.\n\nGoal 3), however, is tricky. One way to do this is to make `FiniteDrinfeldModule` inherit [`CachedRepresentation` or `UniqueRepresentation`](https://doc.sagemath.org/html/en/reference/structure/sage/structure/unique_representation.html), and to implement `__classcall_private__`. The drawback is that two instances with same parameters (`polring`, `gen`, `characteristic`) will always be references to one another. This prevents users from doing deep copies, which limits their abilities. I discussed this (with David and Travis) in [this sage-devel thread](https://groups.google.com/g/sage-devel/c/PaUReuoxEXI). I am still not decided on what to do. Any other suggestion would be welcome.\n\n\nAntoine",
    "created_at": "2022-06-08T15:05:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672015",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:33'></a>
A quick status report. I had a lot to do in the last few weeks and I did not really work on
the code. That being said, there are three main things left to do:

1. Write doctests.

2. Add an option to the constructor `OrePolynomialRing` so that `F2tau.<t> = OrePolynomialRing(GF(2), GF(2).frobenius_endomorphism())` builds a real Ore algebra and not a regular polynomial ring.

3. Implement a *smart* mechanism so that the constructor of `FiniteDrinfeldModule` autonomously decides (depending on the input) to instantiate `FiniteDrinfeldModule` or `FiniteDrinfeldModule_rank_two`. Like this:

```
sage: psi = FiniteDrinfeldModule(FqX, omega + t^5, characteristic)
sage: type(psi)
<class 'sage.rings.function_field.finite_drinfeld_module.FiniteDrinfeldModule'>
sage: phi = FiniteDrinfeldModule(FqX, omega + t^2, characteristic)
sage: type(phi)
<class 'sage.rings.function_field.finite_drinfeld_module.FiniteDrinfeldModule_rank_two'>
```

Goal 1) is straightforward. 

Goal 2) should be OK; I discussed this with Xavier.

Goal 3), however, is tricky. One way to do this is to make `FiniteDrinfeldModule` inherit [`CachedRepresentation` or `UniqueRepresentation`](https://doc.sagemath.org/html/en/reference/structure/sage/structure/unique_representation.html), and to implement `__classcall_private__`. The drawback is that two instances with same parameters (`polring`, `gen`, `characteristic`) will always be references to one another. This prevents users from doing deep copies, which limits their abilities. I discussed this (with David and Travis) in [this sage-devel thread](https://groups.google.com/g/sage-devel/c/PaUReuoxEXI). I am still not decided on what to do. Any other suggestion would be welcome.


Antoine



---

archive/issue_comments_672016.json:
```json
{
    "body": "<a id='comment:34'></a>\nFor 3), another option is to use the class `Factory`; however, I know that Travis prefers `__classcall_private__`.",
    "created_at": "2022-06-08T15:20:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672016",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:34'></a>
For 3), another option is to use the class `Factory`; however, I know that Travis prefers `__classcall_private__`.



---

archive/issue_comments_672017.json:
```json
{
    "body": "<a id='comment:35'></a>\nHello Antoine, may I ask why do you want to seperate the rank 2 case with that of the general rank case? My guess here is that some methods are proper to the rank 2 case that aren't yet known for the general rank case. For such methods, do you think that simply adding a rank verification would work? For example, if someone ask for the j-invariant of a rank 3 Drinfeld module, an error would be returned saying that it is not yet implemented. To me, this leaves open the question to the user: \"do such method exists in the higher rank case?\" which is an interesting question to ask when studying Drinfeld modules. By the way, theory of J-invariants are known in the higher rank case, which I think could be interesting to implement.",
    "created_at": "2022-06-08T18:30:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672017",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:35'></a>
Hello Antoine, may I ask why do you want to seperate the rank 2 case with that of the general rank case? My guess here is that some methods are proper to the rank 2 case that aren't yet known for the general rank case. For such methods, do you think that simply adding a rank verification would work? For example, if someone ask for the j-invariant of a rank 3 Drinfeld module, an error would be returned saying that it is not yet implemented. To me, this leaves open the question to the user: "do such method exists in the higher rank case?" which is an interesting question to ask when studying Drinfeld modules. By the way, theory of J-invariants are known in the higher rank case, which I think could be interesting to implement.



---

archive/issue_comments_672018.json:
```json
{
    "body": "<a id='comment:36'></a>\nI think this is a relevant question. To me, sane coding practices dictate the\nanswer.\n\nIt is true that the rank two methods may one day become general rank methods.\nFor example, the characteristic polynomial of the Frobenius endomorphism is\ndefined for any rank. And the j-invariant is also defined for some rank one\nDrinfeld modules.\n\nHowever, we are not there yet. It is way cleaner (for the developer *and* the\nuser) to have class inheritance. It is ugly to check if if the rank is 2 and to\nraise an exception at the begining of each rank two method. Furthermore,\nhistorically, rank two Drinfeld modules are of special interest when it comes\nto computation, and they deserve their own class. See\n[Schost, Musleh, 2019](https://arxiv.org/abs/1907.12731) or\n[Caranay, Greenberg, Scheidler, 2019](https://people.ucalgary.ca/~rscheidl/Papers/DMVolcanos.pdf). And, if in the future we build algorithms for general ranks (which I hope!),\nwe will easily be able to implement them as methods of the general class.",
    "created_at": "2022-06-09T08:59:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672018",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:36'></a>
I think this is a relevant question. To me, sane coding practices dictate the
answer.

It is true that the rank two methods may one day become general rank methods.
For example, the characteristic polynomial of the Frobenius endomorphism is
defined for any rank. And the j-invariant is also defined for some rank one
Drinfeld modules.

However, we are not there yet. It is way cleaner (for the developer *and* the
user) to have class inheritance. It is ugly to check if if the rank is 2 and to
raise an exception at the begining of each rank two method. Furthermore,
historically, rank two Drinfeld modules are of special interest when it comes
to computation, and they deserve their own class. See
[Schost, Musleh, 2019](https://arxiv.org/abs/1907.12731) or
[Caranay, Greenberg, Scheidler, 2019](https://people.ucalgary.ca/~rscheidl/Papers/DMVolcanos.pdf). And, if in the future we build algorithms for general ranks (which I hope!),
we will easily be able to implement them as methods of the general class.



---

archive/issue_comments_672019.json:
```json
{
    "body": "<a id='comment:37'></a>\nOkay, so based on the definition given in the description (reading is very useful `:)`), I see why they should be functions. Which means there is a parent of all such modules (I will probably cringe every time this terminology appears since it is so different than what I am used to calling a module, please excuse anytime I get confused). That parent belongs in the category of certain homsets. I might have\n\nPerhaps you can give me some samples with what you want to do (either as (pseudo)code or mathematically)? I feel like I need a little bit more to help me get my bearings.\n\nAs I mentioned on sage-devel, you need to explain why you want deep copies (seems fishy as you should not be modifying internal data; usually we don't do this because we would quickly eat up memory caching lots of elements). The `__classcall__` mechanism is also independent of `UniqueRepresentation`.",
    "created_at": "2022-06-09T09:26:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672019",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:37'></a>
Okay, so based on the definition given in the description (reading is very useful `:)`), I see why they should be functions. Which means there is a parent of all such modules (I will probably cringe every time this terminology appears since it is so different than what I am used to calling a module, please excuse anytime I get confused). That parent belongs in the category of certain homsets. I might have

Perhaps you can give me some samples with what you want to do (either as (pseudo)code or mathematically)? I feel like I need a little bit more to help me get my bearings.

As I mentioned on sage-devel, you need to explain why you want deep copies (seems fishy as you should not be modifying internal data; usually we don't do this because we would quickly eat up memory caching lots of elements). The `__classcall__` mechanism is also independent of `UniqueRepresentation`.



---

archive/issue_comments_672020.json:
```json
{
    "body": "<a id='comment:38'></a>\nReplying to [tscrim](#comment%3A37):\n> Okay, so based on the definition given in the description (reading is very useful `:)`), I see why they should be functions. Which means there is a parent of all such modules (I will probably cringe every time this terminology appears since it is so different than what I am used to calling a module, please excuse anytime I get confused).\n\n\nHahahaha, no worries, I totally understand. A general principle for Drinfeld\nmodules is that what they do is more important as what they are. And what they\ndo is endow `Fqbar` with this `Fq[X]`-module law. However I still believe that\nthey should be implemented as morphisms.\n\n\n> That parent belongs in the category of certain homsets. I might have\n> \n> Perhaps you can give me some samples with what you want to do (either as (pseudo)code or mathematically)? I feel like I need a little bit more to help me get my bearings.\n\n\nSure. The prime goal of this implementation is to provide researchers with a\ntoolbox with which they can manipulate objects. A fun example is the CGL hash\nfunction.\n\n1. You take a message that you want to hash.\n2. You somehow convert this message to a j-invariant of a rank two *supersingular* finite Drinfeld module (method `is_supersingular`).\n3. You make a random walk in the tree whose nodes are isomorphism classes (represented by j-invariants) and whose vertices are isogenies between those classes. The random walk is realized with V\u00e9lu's formula (method `velu`).\n4. The j-invariant on which you stop is, by definition, the hash of the message.\n\nA quick and dirty implementation is the following:\n\n```\ndef cgl_hash(j):\n    # Do 100 random walks\n    for _ in range(100):\n        # phi has j-invariant j\n        phi = FiniteDrinfeldModule_rank_two(FqX, omega + t + t^2/j, characteristic)\n        is_isogeny = False\n        while not is_isogeny:\n            # Ideally, m should rather be an isogeny of small fixed-degree\n            m = Ltau.random_element()\n            if phi.is_isogeny(m):\n                phi = phi.velu(m)\n                phi = FiniteDrinfeldModule_rank_two(FqX, phi(X), characteristic)  # Ugly, I know\n                is_isogeny = True\n    return phi.j()\n\nif __name__ == '__main__':\n    Fq = GF(2)\n    z2 = Fq.gen()\n    FqX.<X> = Fq[]\n    characteristic = X^6 + X^4 + X^3 + X + 1\n    L.<z6> = Fq.extension(6)\n    Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(1))\n    omega = characteristic.roots(L, multiplicities=False)[0]\n    phi = FiniteDrinfeldModule_rank_two(FqX, t^2 + (z6^5 + z6)*t + z6, characteristic)\n    assert phi.is_supersingular()\n    j = phi.j()\n    hash_ = cgl_hash(j)\n```\n\nYou see that the goal is not to perform one specific case but to provide simple\nmethods that are easy to use. This [SageMath](SageMath) module (`;)`) is nothing more than\na calculator with Drinfeld modules.\n\nI genuinely do not know if this is useful for you, feel free to ask more\nquestions.\n\n\n> \n> As I mentioned on sage-devel, you need to explain why you want deep copies (seems fishy as you should not be modifying internal data; usually we don't do this because we would quickly eat up memory caching lots of elements).\n\n\nOk so I was not clear on this. My bad. I do not have a specific use case where\nthe user would want to make deep copies. I however try to follow the general\nprinciple of not imposing technical constraints to the user. If at some point a\nuser needs to deep copy, I want them to be able to. As simple as that.\n\n\n> The `__classcall__` mechanism is also independent of `UniqueRepresentation`.\n\n\nFair enough, this meens that I am a bit confused on all of this. I will try to\nget my head around this (and on the `Factory` stuff).\n\nBy the way, thanks a **lot** for taking so much time and genuine interest on\nthis.",
    "created_at": "2022-06-09T13:53:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672020",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:38'></a>
Replying to [tscrim](#comment%3A37):
> Okay, so based on the definition given in the description (reading is very useful `:)`), I see why they should be functions. Which means there is a parent of all such modules (I will probably cringe every time this terminology appears since it is so different than what I am used to calling a module, please excuse anytime I get confused).


Hahahaha, no worries, I totally understand. A general principle for Drinfeld
modules is that what they do is more important as what they are. And what they
do is endow `Fqbar` with this `Fq[X]`-module law. However I still believe that
they should be implemented as morphisms.


> That parent belongs in the category of certain homsets. I might have
> 
> Perhaps you can give me some samples with what you want to do (either as (pseudo)code or mathematically)? I feel like I need a little bit more to help me get my bearings.


Sure. The prime goal of this implementation is to provide researchers with a
toolbox with which they can manipulate objects. A fun example is the CGL hash
function.

1. You take a message that you want to hash.
2. You somehow convert this message to a j-invariant of a rank two *supersingular* finite Drinfeld module (method `is_supersingular`).
3. You make a random walk in the tree whose nodes are isomorphism classes (represented by j-invariants) and whose vertices are isogenies between those classes. The random walk is realized with Vélu's formula (method `velu`).
4. The j-invariant on which you stop is, by definition, the hash of the message.

A quick and dirty implementation is the following:

```
def cgl_hash(j):
    # Do 100 random walks
    for _ in range(100):
        # phi has j-invariant j
        phi = FiniteDrinfeldModule_rank_two(FqX, omega + t + t^2/j, characteristic)
        is_isogeny = False
        while not is_isogeny:
            # Ideally, m should rather be an isogeny of small fixed-degree
            m = Ltau.random_element()
            if phi.is_isogeny(m):
                phi = phi.velu(m)
                phi = FiniteDrinfeldModule_rank_two(FqX, phi(X), characteristic)  # Ugly, I know
                is_isogeny = True
    return phi.j()

if __name__ == '__main__':
    Fq = GF(2)
    z2 = Fq.gen()
    FqX.<X> = Fq[]
    characteristic = X^6 + X^4 + X^3 + X + 1
    L.<z6> = Fq.extension(6)
    Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(1))
    omega = characteristic.roots(L, multiplicities=False)[0]
    phi = FiniteDrinfeldModule_rank_two(FqX, t^2 + (z6^5 + z6)*t + z6, characteristic)
    assert phi.is_supersingular()
    j = phi.j()
    hash_ = cgl_hash(j)
```

You see that the goal is not to perform one specific case but to provide simple
methods that are easy to use. This [SageMath](SageMath) module (`;)`) is nothing more than
a calculator with Drinfeld modules.

I genuinely do not know if this is useful for you, feel free to ask more
questions.


> 
> As I mentioned on sage-devel, you need to explain why you want deep copies (seems fishy as you should not be modifying internal data; usually we don't do this because we would quickly eat up memory caching lots of elements).


Ok so I was not clear on this. My bad. I do not have a specific use case where
the user would want to make deep copies. I however try to follow the general
principle of not imposing technical constraints to the user. If at some point a
user needs to deep copy, I want them to be able to. As simple as that.


> The `__classcall__` mechanism is also independent of `UniqueRepresentation`.


Fair enough, this meens that I am a bit confused on all of this. I will try to
get my head around this (and on the `Factory` stuff).

By the way, thanks a **lot** for taking so much time and genuine interest on
this.



---

archive/issue_comments_672021.json:
```json
{
    "body": "<a id='comment:39'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/28d01ed0a45523db67958a41771f13da4905b954\">28d01ed</a></td><td><code>Merge branch 'develop' into u/antoine-leudiere/finite_drinfeld_modules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9bcadf21f86e8e4e6fda8e151ecb33db7acd6552\">9bcadf2</a></td><td><code>Fix j-invariant method for FiniteDrinfeldModule_rank_two</code></td></tr></table>\n",
    "created_at": "2022-06-09T13:54:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672021",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:39'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/28d01ed0a45523db67958a41771f13da4905b954">28d01ed</a></td><td><code>Merge branch 'develop' into u/antoine-leudiere/finite_drinfeld_modules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9bcadf21f86e8e4e6fda8e151ecb33db7acd6552">9bcadf2</a></td><td><code>Fix j-invariant method for FiniteDrinfeldModule_rank_two</code></td></tr></table>




---

archive/issue_comments_672022.json:
```json
{
    "body": "**Changing commit** from \"[8db54f202036320ae848576f93a68a5e5f579fb6](https://github.com/sagemath/sagetrac-mirror/commit/8db54f202036320ae848576f93a68a5e5f579fb6)\" to \"[9bcadf21f86e8e4e6fda8e151ecb33db7acd6552](https://github.com/sagemath/sagetrac-mirror/commit/9bcadf21f86e8e4e6fda8e151ecb33db7acd6552)\".",
    "created_at": "2022-06-09T13:54:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672022",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[8db54f202036320ae848576f93a68a5e5f579fb6](https://github.com/sagemath/sagetrac-mirror/commit/8db54f202036320ae848576f93a68a5e5f579fb6)" to "[9bcadf21f86e8e4e6fda8e151ecb33db7acd6552](https://github.com/sagemath/sagetrac-mirror/commit/9bcadf21f86e8e4e6fda8e151ecb33db7acd6552)".



---

archive/issue_comments_672023.json:
```json
{
    "body": "<a id='comment:40'></a>\nReplying to [antoine-leudiere](#comment%3A36):\n\n> And the j-invariant is also defined for some rank one Drinfeld modules.\n\n\nJ-invariants are also defined for higher rank Drinfeld modules (see this [paper](https://link.springer.com/article/10.1023/A:1009724323513)).\n\n> However, we are not there yet.\n\n\nThis is the thing. Your code will very likely evolve in the future as people might gain interest in it and want to contribute to it. My **main concern** here is that your rank two specific class might become superfluous in the future. You mention that you don't want to \"bloat\" the code, but code repetition is a form of bloating.\n\n> It is ugly to check if if the rank is 2 and to raise an exception at the begining of each rank two method.\n\n\nI'm sorry, I'm not conviced by this very subjective argument :-) Your code currently have eight rank two specific methods. When I look briefly, four of them could be generalized to higher rank (`j`, `delta`, `g` and `characteristic_polynomial` as you said) and maybe more. Do you have any other rank two specific methods you want to implement? \n\nHistorically, I believe that the main reasons people restricted themselves to the rank 2 specific case is because it simplifies the computations. Nowadays, the higher rank generalizations is getting some interests.\n\nHowever, don't get me wrong, I don't want to stop you in your implementation and I'm very enthusiastic in having Drinfeld modules in [SageMath](SageMath). Thank you for doing this and I already have plenty of ideas of new enhancements for this implementation! Good job on your work!",
    "created_at": "2022-06-09T17:20:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672023",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:40'></a>
Replying to [antoine-leudiere](#comment%3A36):

> And the j-invariant is also defined for some rank one Drinfeld modules.


J-invariants are also defined for higher rank Drinfeld modules (see this [paper](https://link.springer.com/article/10.1023/A:1009724323513)).

> However, we are not there yet.


This is the thing. Your code will very likely evolve in the future as people might gain interest in it and want to contribute to it. My **main concern** here is that your rank two specific class might become superfluous in the future. You mention that you don't want to "bloat" the code, but code repetition is a form of bloating.

> It is ugly to check if if the rank is 2 and to raise an exception at the begining of each rank two method.


I'm sorry, I'm not conviced by this very subjective argument :-) Your code currently have eight rank two specific methods. When I look briefly, four of them could be generalized to higher rank (`j`, `delta`, `g` and `characteristic_polynomial` as you said) and maybe more. Do you have any other rank two specific methods you want to implement? 

Historically, I believe that the main reasons people restricted themselves to the rank 2 specific case is because it simplifies the computations. Nowadays, the higher rank generalizations is getting some interests.

However, don't get me wrong, I don't want to stop you in your implementation and I'm very enthusiastic in having Drinfeld modules in [SageMath](SageMath). Thank you for doing this and I already have plenty of ideas of new enhancements for this implementation! Good job on your work!



---

archive/issue_comments_672024.json:
```json
{
    "body": "<a id='comment:41'></a>\nReplying to [antoine-leudiere](#comment%3A38):\n> Replying to [tscrim](#comment%3A37):\n> > Okay, so based on the definition given in the description (reading is very useful `:)`), I see why they should be functions. Which means there is a parent of all such modules (I will probably cringe every time this terminology appears since it is so different than what I am used to calling a module, please excuse anytime I get confused).\n\n> \n> Hahahaha, no worries, I totally understand. A general principle for Drinfeld\n> modules is that what they do is more important as what they are. And what they\n> do is endow `Fqbar` with this `Fq[X]`-module law. However I still believe that\n> they should be implemented as morphisms.\n\n\nI am not sure that `Fqbar` with an action should be the object you want. It will potentially have multiple action of the same `Fq[X]` acting on it. So I would want this to be a different class (which could be a subclass of `Representation`) that takes in a `DrinfeldModule` and the underlying space. This way you would have no ambiguity about the action.\n\nI would think a bit about how you want the user to interact with your code. What are the main entry points? I don't want all of the main classes to be imported into the global namespace (in particular, the rank two case should it survive refactoring). I would guess that mathematically it should be the method of some (relatively general) parent that we already have (with possibly raising a `NotImplementedError` on some cases your code does not yet cover).\n\nFrom the example you gave and from a quick look at the code, it looks like the most natural object to add a hook to is the `OrePolynomialRing` or possibly its elements.\n\n> > Perhaps you can give me some samples with what you want to do (either as (pseudo)code or mathematically)? I feel like I need a little bit more to help me get my bearings.\n\n> \n> Sure. A fun example is the CGL hash function.\n\n\nThank you for the example. It is helpful to see the usage.\n\nWhat (natural) structure(s) exists on the set of Drinfeld modules? Is it a module (in the linear algebra sense)? Ring? This could be useful in determining if we want a special subclass of the homset for Drinfeld modules.\n\n> > As I mentioned on sage-devel, you need to explain why you want deep copies (seems fishy as you should not be modifying internal data; usually we don't do this because we would quickly eat up memory caching lots of elements).\n\n> \n> Ok so I was not clear on this. My bad. I do not have a specific use case where\n> the user would want to make deep copies. I however try to follow the general\n> principle of not imposing technical constraints to the user. If at some point a\n> user needs to deep copy, I want them to be able to. As simple as that.\n\n\nTo be polite, this is not a valid argument. Your objects are (functionally) immutable. Thus, if you do not expect a lot of them to be constructed (which from my understanding you do not), then there are strong benefits for having uniqueness (e.g., free hash and equality checks). Someone doing a deep copy and mutating your object not only would likely violate some of the internal assumptions of Sage's code (e.g., hashing) but is a code smell that an inconsistent object could result.\n\nSome other quick comments:\n\n- This is not a full C/C++ library where everything needs to be perfectly encapsulated and accessed with getter (or setter) methods. For example, it might be better to store `_Fq` as an attribute than get it as a function. This can have a big impact on speed in Python.\n- I agree with David about the rank two case. All of those methods that (should) have a well-defined generalization should be there and raise a `NotImplementedError` where appropriate. The rank two class might still be useful for doing specialized computations, but sometimes a simple `if` statement in the appropriate methods makes the code more maintainable (this is a subjective decision though).\n- I am very worried about the `is_morphism()` method considering the base class.\n- The signature of `_get_action_()` is not correct for a parent, but it does not make sense for a morphism.\n- We follow Python's convention for error messages of starting with a lower case letter and no punctuation at the end.\n- Please avoid the double underscore name mangling. It generally makes things more complicated for subclasses to work with unless you have a really good reason to keep the data protected.",
    "created_at": "2022-06-13T09:39:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672024",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:41'></a>
Replying to [antoine-leudiere](#comment%3A38):
> Replying to [tscrim](#comment%3A37):
> > Okay, so based on the definition given in the description (reading is very useful `:)`), I see why they should be functions. Which means there is a parent of all such modules (I will probably cringe every time this terminology appears since it is so different than what I am used to calling a module, please excuse anytime I get confused).

> 
> Hahahaha, no worries, I totally understand. A general principle for Drinfeld
> modules is that what they do is more important as what they are. And what they
> do is endow `Fqbar` with this `Fq[X]`-module law. However I still believe that
> they should be implemented as morphisms.


I am not sure that `Fqbar` with an action should be the object you want. It will potentially have multiple action of the same `Fq[X]` acting on it. So I would want this to be a different class (which could be a subclass of `Representation`) that takes in a `DrinfeldModule` and the underlying space. This way you would have no ambiguity about the action.

I would think a bit about how you want the user to interact with your code. What are the main entry points? I don't want all of the main classes to be imported into the global namespace (in particular, the rank two case should it survive refactoring). I would guess that mathematically it should be the method of some (relatively general) parent that we already have (with possibly raising a `NotImplementedError` on some cases your code does not yet cover).

From the example you gave and from a quick look at the code, it looks like the most natural object to add a hook to is the `OrePolynomialRing` or possibly its elements.

> > Perhaps you can give me some samples with what you want to do (either as (pseudo)code or mathematically)? I feel like I need a little bit more to help me get my bearings.

> 
> Sure. A fun example is the CGL hash function.


Thank you for the example. It is helpful to see the usage.

What (natural) structure(s) exists on the set of Drinfeld modules? Is it a module (in the linear algebra sense)? Ring? This could be useful in determining if we want a special subclass of the homset for Drinfeld modules.

> > As I mentioned on sage-devel, you need to explain why you want deep copies (seems fishy as you should not be modifying internal data; usually we don't do this because we would quickly eat up memory caching lots of elements).

> 
> Ok so I was not clear on this. My bad. I do not have a specific use case where
> the user would want to make deep copies. I however try to follow the general
> principle of not imposing technical constraints to the user. If at some point a
> user needs to deep copy, I want them to be able to. As simple as that.


To be polite, this is not a valid argument. Your objects are (functionally) immutable. Thus, if you do not expect a lot of them to be constructed (which from my understanding you do not), then there are strong benefits for having uniqueness (e.g., free hash and equality checks). Someone doing a deep copy and mutating your object not only would likely violate some of the internal assumptions of Sage's code (e.g., hashing) but is a code smell that an inconsistent object could result.

Some other quick comments:

- This is not a full C/C++ library where everything needs to be perfectly encapsulated and accessed with getter (or setter) methods. For example, it might be better to store `_Fq` as an attribute than get it as a function. This can have a big impact on speed in Python.
- I agree with David about the rank two case. All of those methods that (should) have a well-defined generalization should be there and raise a `NotImplementedError` where appropriate. The rank two class might still be useful for doing specialized computations, but sometimes a simple `if` statement in the appropriate methods makes the code more maintainable (this is a subjective decision though).
- I am very worried about the `is_morphism()` method considering the base class.
- The signature of `_get_action_()` is not correct for a parent, but it does not make sense for a morphism.
- We follow Python's convention for error messages of starting with a lower case letter and no punctuation at the end.
- Please avoid the double underscore name mangling. It generally makes things more complicated for subclasses to work with unless you have a really good reason to keep the data protected.



---

archive/issue_comments_672025.json:
```json
{
    "body": "<a id='comment:42'></a>\nI had a lot of work this week, sorry for the delay! Quick heads up.\n\n**Rank two situation**\n\nFair enough, let's use `NotImplementedError`. I will delete the class\n`FiniteDrinfeldModule_rank_two`.\n\n@Travis. There indeed are benefits to unique representations. However, this is\nnot something that is fundamentally necessary from a mathematical point of\nview. And, for this reason, I do not want to limit the users. It's not my\nbusiness to tell what users can or cannot do. My job is to provide them with a\nsafe and well-built library.\n\n**Base class**\n\nA finite Drinfeld `FqX`-module is **not** a module. Blame Drinfeld for this. A finite Drinfeld `FqX`-module\n**is** a morphism, which induces an `FqX`-module law on `Fqbar`. See my original comment.\nDrinfeld modules `\\Fq[X] \\to L\\{\\tau\\}`, however, are the objects of a category\nwhose morphisms `i: \\phi \\to \\psi` are, by definition, Ore polynomials `i` such\nthat `i*phi(X) = psi(X)*i`.\n\nWe've been thinking about this with Xavier (who I visited this week), and we\nwrote a different implementation that inherits `CategoryObject` instead of\n`RingHomomorphism_im_gens`. We created the category `DrinfeldModules` and we\nwill create homspaces for Drinfeld modules. We pushed a quick, dirty,\nundocumented and untested code on the branch\n[u/antoine-leudiere/finite_drinfeld_modules-category-object](https://git.sagemath.org/sage.git/log/?h=u/antoine-leudiere/finite_drinfeld_modules-category_object).\n\nThis makes much sense from cryptography perspectives, for example, as in this\ncontext we mainly manipulate morphisms of Drinfeld modules.\nThe code is cleaner when having `Hom(phi, psi)`, and we could probably\nimplement methods like `random_element`, `supersingular_element` or\n`ordinary_element` on the category.\n\n\nWe overloaded `__call__` for convenience.\n\nFurthermore, we could remove some of the boilerplate code, and the\n`characteristic` is now an attribute of the category which is *not* necessary\nanymore when instantiating `FiniteDrinfeldModule`.\n\nDemo:\n\n```\nsage: # Create Drinfeld modules\nsage: Fq = GF(7^2)\nsage: FqX.<X> = Fq[]\nsage: L.<w> = GF(7^6)\nsage: phi = FiniteDrinfeldModule(FqX, [w, 1, 1])\nsage: phi\nFinite Drinfeld module:\n  Polring:        Univariate Polynomial Ring in X over Finite Field in z2 of size 7^2\n  Ore polring:    Ore Polynomial Ring in t over Finite Field in z6 of size 7^6 twisted by z6 |--> z6^(7^2)\n  Generator:      t^2 + t + z6\nsage: psi = FiniteDrinfeldModule(FqX, phi(X))\nsage: phi == psi\nTrue\nsage: # Category of Drinfeld modules\nsage: dr = phi.category()\nsage: dr\nCategory of Drinfeld modules defined by Ring morphism:\n  From: Univariate Polynomial Ring in X over Finite Field in z2 of size 7^2\n  To:   Finite Field in z6 of size 7^6\n  Defn: X |--> z6\nsage: dr(phi(X))\nFinite Drinfeld module:\n  Polring:        Univariate Polynomial Ring in X over Finite Field in z2 of size 7^2\n  Ore polring:    Ore Polynomial Ring in t over Finite Field in z6 of size 7^6 twisted by z6 |--> z6^(7^2)\n  Generator:      t^2 + t + z6\nsage: dr(phi(X)) == phi\nTrue\nsage: dr.characteristic()\nx^3 + (6*z2 + 4)*x^2 + (4*z2 + 5)*x + 6*z2\nsage: dr.characteristic()(phi(X)[0])\n0\nsage: # Some methods\nsage: phi.characteristic_polynomial()\nT^2 + (3*X + 6*z2 + 5)*T + 6*X^3 + (z2 + 3)*X^2 + (3*z2 + 2)*X + z2\nsage: t = phi.ore_variable()\nsage: phi.characteristic_polynomial()(t^3, phi(X))\n0\nsage: phi.j()\n1\n```\n\nBy the way, David will be happy with the constructor!\n\n**Misc**\n\n* For the getters, why is it a problem to use methods as everything is already\n  stored somewhoere?\n* I agree, names `is_morphism`, etc, are shitty. Hopefully we will get rid of\n  those by using syntax like `i in Hom(phi, psi)`. In the meantime, I can\n  replace `is_` to `has_`.\n* Ok for `_get_action_`. I really was not sure about it, as mentioned it\n  earlier.",
    "created_at": "2022-06-16T17:42:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672025",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:42'></a>
I had a lot of work this week, sorry for the delay! Quick heads up.

**Rank two situation**

Fair enough, let's use `NotImplementedError`. I will delete the class
`FiniteDrinfeldModule_rank_two`.

@Travis. There indeed are benefits to unique representations. However, this is
not something that is fundamentally necessary from a mathematical point of
view. And, for this reason, I do not want to limit the users. It's not my
business to tell what users can or cannot do. My job is to provide them with a
safe and well-built library.

**Base class**

A finite Drinfeld `FqX`-module is **not** a module. Blame Drinfeld for this. A finite Drinfeld `FqX`-module
**is** a morphism, which induces an `FqX`-module law on `Fqbar`. See my original comment.
Drinfeld modules `\Fq[X] \to L\{\tau\}`, however, are the objects of a category
whose morphisms `i: \phi \to \psi` are, by definition, Ore polynomials `i` such
that `i*phi(X) = psi(X)*i`.

We've been thinking about this with Xavier (who I visited this week), and we
wrote a different implementation that inherits `CategoryObject` instead of
`RingHomomorphism_im_gens`. We created the category `DrinfeldModules` and we
will create homspaces for Drinfeld modules. We pushed a quick, dirty,
undocumented and untested code on the branch
[u/antoine-leudiere/finite_drinfeld_modules-category-object](https://git.sagemath.org/sage.git/log/?h=u/antoine-leudiere/finite_drinfeld_modules-category_object).

This makes much sense from cryptography perspectives, for example, as in this
context we mainly manipulate morphisms of Drinfeld modules.
The code is cleaner when having `Hom(phi, psi)`, and we could probably
implement methods like `random_element`, `supersingular_element` or
`ordinary_element` on the category.


We overloaded `__call__` for convenience.

Furthermore, we could remove some of the boilerplate code, and the
`characteristic` is now an attribute of the category which is *not* necessary
anymore when instantiating `FiniteDrinfeldModule`.

Demo:

```
sage: # Create Drinfeld modules
sage: Fq = GF(7^2)
sage: FqX.<X> = Fq[]
sage: L.<w> = GF(7^6)
sage: phi = FiniteDrinfeldModule(FqX, [w, 1, 1])
sage: phi
Finite Drinfeld module:
  Polring:        Univariate Polynomial Ring in X over Finite Field in z2 of size 7^2
  Ore polring:    Ore Polynomial Ring in t over Finite Field in z6 of size 7^6 twisted by z6 |--> z6^(7^2)
  Generator:      t^2 + t + z6
sage: psi = FiniteDrinfeldModule(FqX, phi(X))
sage: phi == psi
True
sage: # Category of Drinfeld modules
sage: dr = phi.category()
sage: dr
Category of Drinfeld modules defined by Ring morphism:
  From: Univariate Polynomial Ring in X over Finite Field in z2 of size 7^2
  To:   Finite Field in z6 of size 7^6
  Defn: X |--> z6
sage: dr(phi(X))
Finite Drinfeld module:
  Polring:        Univariate Polynomial Ring in X over Finite Field in z2 of size 7^2
  Ore polring:    Ore Polynomial Ring in t over Finite Field in z6 of size 7^6 twisted by z6 |--> z6^(7^2)
  Generator:      t^2 + t + z6
sage: dr(phi(X)) == phi
True
sage: dr.characteristic()
x^3 + (6*z2 + 4)*x^2 + (4*z2 + 5)*x + 6*z2
sage: dr.characteristic()(phi(X)[0])
0
sage: # Some methods
sage: phi.characteristic_polynomial()
T^2 + (3*X + 6*z2 + 5)*T + 6*X^3 + (z2 + 3)*X^2 + (3*z2 + 2)*X + z2
sage: t = phi.ore_variable()
sage: phi.characteristic_polynomial()(t^3, phi(X))
0
sage: phi.j()
1
```

By the way, David will be happy with the constructor!

**Misc**

* For the getters, why is it a problem to use methods as everything is already
  stored somewhoere?
* I agree, names `is_morphism`, etc, are shitty. Hopefully we will get rid of
  those by using syntax like `i in Hom(phi, psi)`. In the meantime, I can
  replace `is_` to `has_`.
* Ok for `_get_action_`. I really was not sure about it, as mentioned it
  earlier.



---

archive/issue_comments_672026.json:
```json
{
    "body": "<a id='comment:43'></a>\nHello Antoine, thanks for the heads up! It looks a lot more convenient now to create a Drinfeld module (I am indeed happy with the constructor `:)`). Did you opened a ticket for the implementation of the category of Drinfeld modules?",
    "created_at": "2022-06-16T19:02:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672026",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:43'></a>
Hello Antoine, thanks for the heads up! It looks a lot more convenient now to create a Drinfeld module (I am indeed happy with the constructor `:)`). Did you opened a ticket for the implementation of the category of Drinfeld modules?



---

archive/issue_comments_672027.json:
```json
{
    "body": "<a id='comment:44'></a>\nReplying to [antoine-leudiere](#comment%3A42):\n> @Travis. There indeed are benefits to unique representations. However, this is\n> not something that is fundamentally necessary from a mathematical point of\n> view. And, for this reason, I do not want to limit the users. It's not my\n> business to tell what users can or cannot do. My job is to provide them with a\n> safe and well-built library.\n\n\nHaving just seen another ticket that has issues with non-uniqueness, you are making a point for me with a \"well-built library.\" You need to interact with the broader Sage library as well and fit into that framework. Your reasoning about not wanting to impose technical limitations on users is, again, invalid once you have immutable data. There is no reason anyone should be making a deep copy. As soon as you want to change something, then your object has changed and so it will be different. There is no reason to have `X == X` but not `X is X` beyond not wanting to pollute the cache (which includes creating lots of elements that cannot be garbage collected for a long time), the input not distinguishing `X` (up to some relatively simple normalization), or normalization is a time-consuming process. Programming is not mathematics (something I often have to remind myself of).\n\n> **Base class**\n> \n> A finite Drinfeld `FqX`-module is **not** a module. Blame Drinfeld for this. A finite Drinfeld `FqX`-module\n> **is** a morphism, which induces an `FqX`-module law on `Fqbar`. See my original comment.\n> Drinfeld modules `\\Fq[X] \\to L\\{\\tau\\}`, however, are the objects of a category\n> whose morphisms `i: \\phi \\to \\psi` are, by definition, Ore polynomials `i` such\n> that `i*phi(X) = psi(X)*i`.\n\n\nYou have fixed `\\Fq[X]` and `L\\{\\tau\\}`, right? So the category is just the parent `H = \\Hom(\\Fq[X], L\\{\\tau})`. Then the set of morphisms is a subalgebra(?) of the Ore polynomials. So it would make sense to implement the set of morphisms using the corresponding Ore polynomial ring.\n\nAlso, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?\n\n> We've been thinking about this with Xavier (who I visited this week), and we\n> wrote a different implementation that inherits `CategoryObject` instead of\n> `RingHomomorphism_im_gens`.\n\n\nCan you explain a bit more of your reasoning/overall design?\n\n> We created the category `DrinfeldModules` and we\n> will create homspaces for Drinfeld modules.\n\n\nI don't think it makes sense to implement this as a category in Sage given your code and examples since Sage categories are not quite like mathematical categories. I am not against this though (making them `CategoryObject`s reinforces that they should also be `UniqueRepresentation`s). See above and below for alternative constructions based on what you have told me.\n\n> Demo:\n\n\nYou are using the category like a parent and the parents like elements. Your code also reflects this with implementing methods that you were expected to overload with non-generic versions.\n\n> **Misc**\n> \n> * For the getters, why is it a problem to use methods as everything is already\n>   stored somewhere?\n\n\nSpeed, speed, and speed. When you are working internally, even in subclasses, I think it is better to use the attributes.\n\n> * I agree, names `is_morphism`, etc, are shitty. Hopefully we will get rid of\n>   those by using syntax like `i in Hom(phi, psi)`. In the meantime, I can\n>   replace `is_` to `has_`.\n\n\nThe code might be trying to speak to you a bit here. It isn't quite a matter of syntax, but of overall design.\n\n> * Ok for `_get_action_`. I really was not sure about it, as mentioned it\n>   earlier.\n\n\nFor this, the code is telling me that you want to have a `Representation` object that takes in the `Fqbar` space and the Drinfeld module. Then this object would have a natural `get_action()` method.\n\nPerhaps we cannot get out of having something in the global namespace. Although I get the feeling that there is a natural place to hook this into as a method.",
    "created_at": "2022-06-17T09:38:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672027",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:44'></a>
Replying to [antoine-leudiere](#comment%3A42):
> @Travis. There indeed are benefits to unique representations. However, this is
> not something that is fundamentally necessary from a mathematical point of
> view. And, for this reason, I do not want to limit the users. It's not my
> business to tell what users can or cannot do. My job is to provide them with a
> safe and well-built library.


Having just seen another ticket that has issues with non-uniqueness, you are making a point for me with a "well-built library." You need to interact with the broader Sage library as well and fit into that framework. Your reasoning about not wanting to impose technical limitations on users is, again, invalid once you have immutable data. There is no reason anyone should be making a deep copy. As soon as you want to change something, then your object has changed and so it will be different. There is no reason to have `X == X` but not `X is X` beyond not wanting to pollute the cache (which includes creating lots of elements that cannot be garbage collected for a long time), the input not distinguishing `X` (up to some relatively simple normalization), or normalization is a time-consuming process. Programming is not mathematics (something I often have to remind myself of).

> **Base class**
> 
> A finite Drinfeld `FqX`-module is **not** a module. Blame Drinfeld for this. A finite Drinfeld `FqX`-module
> **is** a morphism, which induces an `FqX`-module law on `Fqbar`. See my original comment.
> Drinfeld modules `\Fq[X] \to L\{\tau\}`, however, are the objects of a category
> whose morphisms `i: \phi \to \psi` are, by definition, Ore polynomials `i` such
> that `i*phi(X) = psi(X)*i`.


You have fixed `\Fq[X]` and `L\{\tau\}`, right? So the category is just the parent `H = \Hom(\Fq[X], L\{\tau})`. Then the set of morphisms is a subalgebra(?) of the Ore polynomials. So it would make sense to implement the set of morphisms using the corresponding Ore polynomial ring.

Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?

> We've been thinking about this with Xavier (who I visited this week), and we
> wrote a different implementation that inherits `CategoryObject` instead of
> `RingHomomorphism_im_gens`.


Can you explain a bit more of your reasoning/overall design?

> We created the category `DrinfeldModules` and we
> will create homspaces for Drinfeld modules.


I don't think it makes sense to implement this as a category in Sage given your code and examples since Sage categories are not quite like mathematical categories. I am not against this though (making them `CategoryObject`s reinforces that they should also be `UniqueRepresentation`s). See above and below for alternative constructions based on what you have told me.

> Demo:


You are using the category like a parent and the parents like elements. Your code also reflects this with implementing methods that you were expected to overload with non-generic versions.

> **Misc**
> 
> * For the getters, why is it a problem to use methods as everything is already
>   stored somewhere?


Speed, speed, and speed. When you are working internally, even in subclasses, I think it is better to use the attributes.

> * I agree, names `is_morphism`, etc, are shitty. Hopefully we will get rid of
>   those by using syntax like `i in Hom(phi, psi)`. In the meantime, I can
>   replace `is_` to `has_`.


The code might be trying to speak to you a bit here. It isn't quite a matter of syntax, but of overall design.

> * Ok for `_get_action_`. I really was not sure about it, as mentioned it
>   earlier.


For this, the code is telling me that you want to have a `Representation` object that takes in the `Fqbar` space and the Drinfeld module. Then this object would have a natural `get_action()` method.

Perhaps we cannot get out of having something in the global namespace. Although I get the feeling that there is a natural place to hook this into as a method.



---

archive/issue_comments_672028.json:
```json
{
    "body": "<a id='comment:45'></a>\nReplying to [tscrim](#comment%3A44):\n\n> There is no reason anyone should be making a deep copy.\n\n\nMy whole point is that we do not know that. Let us move on.\n\n> You have fixed `\\Fq[X]` and `L\\{\\tau\\}`, right? So the category is just the parent `H = \\Hom(\\Fq[X], L\\{\\tau})`.\n\n\n`\\Fq[X]` and `L\\{\\tau\\}` indeed are fixed; do not forget also to fix `\\omega \\in L^\\times`. There are other conditions to be fulfilled for an element of your `H` to be a Drinfeld module, you may refer to the definition I gave in my original post.\n\n> Then the set of morphisms is a subalgebra(?) of the Ore polynomials.\n\n\nNo. You can add morphisms, you can compose them with endomorphisms, but you cannot multiply them. The set of morphisms `\\phi \\to \\psi` is a left `\\End(\\psi)`-submodule (or a right `\\End(\\phi)`-submodule) of `L\\{\\tau\\}`. This implies that it is an `\\Fq[X]`-left (or right) module whose elements live in `\\L\\{\\tau\\}`.\n\n> Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?\n\n\nI did --- they form a category. I have not heard of any other (meaningful) structure.\n\n> Can you explain a bit more of your reasoning/overall design?\n\n\nAs I said, the idea is that we manipulate Drinfeld modules as much as we manipulate their morphisms (isogenies) and endomorphisms. When defining the category `DrinfeldModules` and making `FiniteDrinfeldModule` inheriting `CategoryObject`, we achieve basically two things:\n* we can manipulate morphisms and isogenies using nice syntax like `Hom(phi, psi)`;\n* we can delegate the management of the fixed objects (esp. the characteristic, which originally was the cause of long boilerplate code) to the category.\n\n> You are using the category like a parent and the parents like elements.\n\n\nIt seems OK to overload `__call__`, which seems to be the only parent-like behavior.\n\n> Speed, speed, and speed. When you are working internally, even in subclasses, I think it is better to use the attributes.\n\n\nGetters are safer. I don't think the cost of calling \n\n```python\ndef polring(self):\n    return self._polring\n```\n\nis that bad.\n\n> The code might be trying to speak to you a bit here. It isn't quite a matter of syntax, but of overall design.\n\n\nYeah, that's why Xavier and I thought about implementing the category and the homspaces. The syntax `i in Hom(phi, psi)` to test if `i` is a morphism is neat. It literally was in the part of the post you replied to.\n\n> For this, the code is telling me that you want to have a `Representation` object that takes in the `Fqbar` space and the Drinfeld module. Then this object would have a natural `get_action()` method.\n\n\nOk I will think about it.",
    "created_at": "2022-06-17T12:57:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672028",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:45'></a>
Replying to [tscrim](#comment%3A44):

> There is no reason anyone should be making a deep copy.


My whole point is that we do not know that. Let us move on.

> You have fixed `\Fq[X]` and `L\{\tau\}`, right? So the category is just the parent `H = \Hom(\Fq[X], L\{\tau})`.


`\Fq[X]` and `L\{\tau\}` indeed are fixed; do not forget also to fix `\omega \in L^\times`. There are other conditions to be fulfilled for an element of your `H` to be a Drinfeld module, you may refer to the definition I gave in my original post.

> Then the set of morphisms is a subalgebra(?) of the Ore polynomials.


No. You can add morphisms, you can compose them with endomorphisms, but you cannot multiply them. The set of morphisms `\phi \to \psi` is a left `\End(\psi)`-submodule (or a right `\End(\phi)`-submodule) of `L\{\tau\}`. This implies that it is an `\Fq[X]`-left (or right) module whose elements live in `\L\{\tau\}`.

> Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?


I did --- they form a category. I have not heard of any other (meaningful) structure.

> Can you explain a bit more of your reasoning/overall design?


As I said, the idea is that we manipulate Drinfeld modules as much as we manipulate their morphisms (isogenies) and endomorphisms. When defining the category `DrinfeldModules` and making `FiniteDrinfeldModule` inheriting `CategoryObject`, we achieve basically two things:
* we can manipulate morphisms and isogenies using nice syntax like `Hom(phi, psi)`;
* we can delegate the management of the fixed objects (esp. the characteristic, which originally was the cause of long boilerplate code) to the category.

> You are using the category like a parent and the parents like elements.


It seems OK to overload `__call__`, which seems to be the only parent-like behavior.

> Speed, speed, and speed. When you are working internally, even in subclasses, I think it is better to use the attributes.


Getters are safer. I don't think the cost of calling 

```python
def polring(self):
    return self._polring
```

is that bad.

> The code might be trying to speak to you a bit here. It isn't quite a matter of syntax, but of overall design.


Yeah, that's why Xavier and I thought about implementing the category and the homspaces. The syntax `i in Hom(phi, psi)` to test if `i` is a morphism is neat. It literally was in the part of the post you replied to.

> For this, the code is telling me that you want to have a `Representation` object that takes in the `Fqbar` space and the Drinfeld module. Then this object would have a natural `get_action()` method.


Ok I will think about it.



---

archive/issue_comments_672029.json:
```json
{
    "body": "<a id='comment:46'></a>\nReplying to [tscrim](#comment%3A44):\n> > We've been thinking about this with Xavier (who I visited this week), and we\n> > wrote a different implementation that inherits `CategoryObject` instead of\n> > `RingHomomorphism_im_gens`.\n\n> \n> Can you explain a bit more of your reasoning/overall design?\n\n\nAs I tried to argue before, the overall idea is that, although Drinfeld modules are defined as ring homomorphisms, we usually treat them more as parents than as elements. In particular, the category of Drinfeld modules is quite meaningful while adding/multiplying Drinfeld modules does not make sense. On the other hand, Drinfeld modules do not have elements (as Antoine underlined, they are not modules in the usual sense). This is the main abstract reason why we believe that implementing them as category objects is a nice solution. Besides, in practice, we realized that this framework is also convenient (e.g. it makes easier the creation of Drinfeld modules).\n\nPreviously, I clumsily compared Drinfeld modules with representations; it's certainly better to compare them with elliptic curves (which are the objects they are supposed to mimic in the context of function fields). By definition, an elliptic curve is the datum of a Weierstrass equation (i.e. an equation of the form `y^2 = x^3 + a*x + b`, at least in characteristic different from 2 and 3); however, nobody considers seriously to implement them as elements in the ring of bivariate polynomials. One reason is that adding/multiplying Weierstrass equations is not meaningful.\n\nBesides, we do not really want an abstract elliptic curve to have elements. (Of course, their sets of points over some fields have elements; one can maybe argue that, when considered as a scheme, the elements of an elliptic curve are the prime ideals of the quotient ring `K[x,y]/(y^2 - x^3 - a*x - b)` but this is probably not really what is expected by the user.)\n\nIn [SageMath](SageMath), elliptic curves are parents:\n\n```\nsage: E = EllipticCurve(u'389a')\nsage: E\nElliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field\nsage: isinstance(E, Parent)\nTrue\n```\n\nHowever, `E` does not have elements:\n\n```\nsage: E._element_constructor_\nTraceback (most recent call last):\n...\nAttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute '_element_constructor_'\n\nsage: E.element_class\nTraceback (most recent call last):\n...\nAttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute 'element_class'\n```\n\nand the method `__call__` has been overriden to create set of points:\n\n```\nsage: E(QQ)\nAbelian group of points on Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field\n```\n\nWe somehow decided to follow the same pattern for Drinfeld modules, except that, given that they do have not elements, we found that `CategoryObject` was better suited. (I assume that the class `CategoryObject` was not already introduced when elliptic curves were first implemented in [SageMath](SageMath).)\n\n> You are using the category like a parent and the parents like elements. Your code also reflects this with implementing methods that you were expected to overload with non-generic versions.\n\n\nI don't have that feeling.\n\nFor instance, we have a constructor for directly creating Drinfeld modules without passing through the parent/category. (I agree that such constructors exist elsewhere in sage, e.g. `matrix`, but they are not that common.) Also, as Antoine already said, we plan to implement `Hom(phi, psi)` when `phi` and `psi` are Drinfeld modules.\n\nWe override `__call__` for the convenience of the user, but if you don't like this, we can probably just get rid of this.",
    "created_at": "2022-06-17T19:35:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672029",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:46'></a>
Replying to [tscrim](#comment%3A44):
> > We've been thinking about this with Xavier (who I visited this week), and we
> > wrote a different implementation that inherits `CategoryObject` instead of
> > `RingHomomorphism_im_gens`.

> 
> Can you explain a bit more of your reasoning/overall design?


As I tried to argue before, the overall idea is that, although Drinfeld modules are defined as ring homomorphisms, we usually treat them more as parents than as elements. In particular, the category of Drinfeld modules is quite meaningful while adding/multiplying Drinfeld modules does not make sense. On the other hand, Drinfeld modules do not have elements (as Antoine underlined, they are not modules in the usual sense). This is the main abstract reason why we believe that implementing them as category objects is a nice solution. Besides, in practice, we realized that this framework is also convenient (e.g. it makes easier the creation of Drinfeld modules).

Previously, I clumsily compared Drinfeld modules with representations; it's certainly better to compare them with elliptic curves (which are the objects they are supposed to mimic in the context of function fields). By definition, an elliptic curve is the datum of a Weierstrass equation (i.e. an equation of the form `y^2 = x^3 + a*x + b`, at least in characteristic different from 2 and 3); however, nobody considers seriously to implement them as elements in the ring of bivariate polynomials. One reason is that adding/multiplying Weierstrass equations is not meaningful.

Besides, we do not really want an abstract elliptic curve to have elements. (Of course, their sets of points over some fields have elements; one can maybe argue that, when considered as a scheme, the elements of an elliptic curve are the prime ideals of the quotient ring `K[x,y]/(y^2 - x^3 - a*x - b)` but this is probably not really what is expected by the user.)

In [SageMath](SageMath), elliptic curves are parents:

```
sage: E = EllipticCurve(u'389a')
sage: E
Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
sage: isinstance(E, Parent)
True
```

However, `E` does not have elements:

```
sage: E._element_constructor_
Traceback (most recent call last):
...
AttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute '_element_constructor_'

sage: E.element_class
Traceback (most recent call last):
...
AttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute 'element_class'
```

and the method `__call__` has been overriden to create set of points:

```
sage: E(QQ)
Abelian group of points on Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
```

We somehow decided to follow the same pattern for Drinfeld modules, except that, given that they do have not elements, we found that `CategoryObject` was better suited. (I assume that the class `CategoryObject` was not already introduced when elliptic curves were first implemented in [SageMath](SageMath).)

> You are using the category like a parent and the parents like elements. Your code also reflects this with implementing methods that you were expected to overload with non-generic versions.


I don't have that feeling.

For instance, we have a constructor for directly creating Drinfeld modules without passing through the parent/category. (I agree that such constructors exist elsewhere in sage, e.g. `matrix`, but they are not that common.) Also, as Antoine already said, we plan to implement `Hom(phi, psi)` when `phi` and `psi` are Drinfeld modules.

We override `__call__` for the convenience of the user, but if you don't like this, we can probably just get rid of this.



---

archive/issue_comments_672030.json:
```json
{
    "body": "<a id='comment:47'></a>\nReplying to [antoine-leudiere](#comment%3A45):\n> Replying to [tscrim](#comment%3A44):\n> \n> > There is no reason anyone should be making a deep copy.\n\n> \n> My whole point is that we do not know that. Let us move on.\n\n\nYes, we do. See my comments above. I also have a little bit of experience with this that tells me this is the right thing to do.\n\n> > You have fixed `\\Fq[X]` and `L\\{\\tau\\}`, right? So the category is just the parent `H = \\Hom(\\Fq[X], L\\{\\tau})`.\n\n> \n> `\\Fq[X]` and `L\\{\\tau\\}` indeed are fixed; do not forget also to fix `\\omega \\in L^\\times`. There are other conditions to be fulfilled for an element of your `H` to be a Drinfeld module, you may refer to the definition I gave in my original post.\n> \n> > Then the set of morphisms is a subalgebra(?) of the Ore polynomials.\n\n> \n> No. You can add morphisms, you can compose them with endomorphisms, but you cannot multiply them. The set of morphisms `\\phi \\to \\psi` is a left `\\End(\\psi)`-submodule (or a right `\\End(\\phi)`-submodule) of `L\\{\\tau\\}`. This implies that it is an `\\Fq[X]`-left (or right) module whose elements live in `\\L\\{\\tau\\}`.\n\n\nOkay, thank you for the explanation. I am guessing there isn\u2019t anything known about the dimension or generators/basis?\n\n> > Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?\n\n> \n> I did --- they form a category.\n\n\nThat is not a structure of the objects. Essentially anything can be objects in a category, just like anything can be in a set. The elements of a ring form a perfectly nice category with on the identity morphism on each object (a discrete category).\n\n> I have not heard of any other (meaningful) structure.\n\n\nThat is what I wanted to know.\n\n> > Can you explain a bit more of your reasoning/overall design?\n\n> \n> As I said, the idea is that we manipulate Drinfeld modules as much as we manipulate their morphisms (isogenies) and endomorphisms. When defining the category `DrinfeldModules` and making `FiniteDrinfeldModule` inheriting `CategoryObject`, we achieve basically two things:\n> * we can manipulate morphisms and isogenies using nice syntax like `Hom(phi, psi)`;\n> * we can delegate the management of the fixed objects (esp. the characteristic, which originally was the cause of long boilerplate code) to the category.\n\n\nI am going to respond to Xavier\u2019s post for this. However, I am skeptical of the second point.\n\n> > Speed, speed, and speed. When you are working internally, even in subclasses, I think it is better to use the attributes.\n\n> \n> Getters are safer. I don't think the cost of calling \n> \n> ```python\n> def polring(self):\n>     return self._polring\n> ```\n> is that bad.\n\n\nIt adds up quite a lot, much more than you think it does. Python is slow compared to C.\n\n> > The code might be trying to speak to you a bit here. It isn't quite a matter of syntax, but of overall design.\n\n> \n> Yeah, that's why Xavier and I thought about implementing the category and the homspaces. The syntax `i in Hom(phi, psi)` to test if `i` is a morphism is neat.\n\n\nI also read your post very carefully and responded with that in mind to make a point. Indeed, I am agreeing with you that there does need to be an object for the set of morphisms. It is not the syntax, but the object that is the important point to me.\n\n> It literally was in the part of the post you replied to.\n\n\nI am trying to not be snarky in my replies, but I don\u2019t appreciate the tone of your comment here.",
    "created_at": "2022-06-18T05:27:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672030",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:47'></a>
Replying to [antoine-leudiere](#comment%3A45):
> Replying to [tscrim](#comment%3A44):
> 
> > There is no reason anyone should be making a deep copy.

> 
> My whole point is that we do not know that. Let us move on.


Yes, we do. See my comments above. I also have a little bit of experience with this that tells me this is the right thing to do.

> > You have fixed `\Fq[X]` and `L\{\tau\}`, right? So the category is just the parent `H = \Hom(\Fq[X], L\{\tau})`.

> 
> `\Fq[X]` and `L\{\tau\}` indeed are fixed; do not forget also to fix `\omega \in L^\times`. There are other conditions to be fulfilled for an element of your `H` to be a Drinfeld module, you may refer to the definition I gave in my original post.
> 
> > Then the set of morphisms is a subalgebra(?) of the Ore polynomials.

> 
> No. You can add morphisms, you can compose them with endomorphisms, but you cannot multiply them. The set of morphisms `\phi \to \psi` is a left `\End(\psi)`-submodule (or a right `\End(\phi)`-submodule) of `L\{\tau\}`. This implies that it is an `\Fq[X]`-left (or right) module whose elements live in `\L\{\tau\}`.


Okay, thank you for the explanation. I am guessing there isn’t anything known about the dimension or generators/basis?

> > Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?

> 
> I did --- they form a category.


That is not a structure of the objects. Essentially anything can be objects in a category, just like anything can be in a set. The elements of a ring form a perfectly nice category with on the identity morphism on each object (a discrete category).

> I have not heard of any other (meaningful) structure.


That is what I wanted to know.

> > Can you explain a bit more of your reasoning/overall design?

> 
> As I said, the idea is that we manipulate Drinfeld modules as much as we manipulate their morphisms (isogenies) and endomorphisms. When defining the category `DrinfeldModules` and making `FiniteDrinfeldModule` inheriting `CategoryObject`, we achieve basically two things:
> * we can manipulate morphisms and isogenies using nice syntax like `Hom(phi, psi)`;
> * we can delegate the management of the fixed objects (esp. the characteristic, which originally was the cause of long boilerplate code) to the category.


I am going to respond to Xavier’s post for this. However, I am skeptical of the second point.

> > Speed, speed, and speed. When you are working internally, even in subclasses, I think it is better to use the attributes.

> 
> Getters are safer. I don't think the cost of calling 
> 
> ```python
> def polring(self):
>     return self._polring
> ```
> is that bad.


It adds up quite a lot, much more than you think it does. Python is slow compared to C.

> > The code might be trying to speak to you a bit here. It isn't quite a matter of syntax, but of overall design.

> 
> Yeah, that's why Xavier and I thought about implementing the category and the homspaces. The syntax `i in Hom(phi, psi)` to test if `i` is a morphism is neat.


I also read your post very carefully and responded with that in mind to make a point. Indeed, I am agreeing with you that there does need to be an object for the set of morphisms. It is not the syntax, but the object that is the important point to me.

> It literally was in the part of the post you replied to.


I am trying to not be snarky in my replies, but I don’t appreciate the tone of your comment here.



---

archive/issue_comments_672031.json:
```json
{
    "body": "<a id='comment:48'></a>\nReplying to [caruso](#comment%3A46):\n> Replying to [tscrim](#comment%3A44):\n> > > We've been thinking about this with Xavier (who I visited this week), and we\n> > > wrote a different implementation that inherits `CategoryObject` instead of\n> > > `RingHomomorphism_im_gens`.\n\n> > \n> > Can you explain a bit more of your reasoning/overall design?\n\n> \n> As I tried to argue before, the overall idea is that, although Drinfeld modules are defined as ring homomorphisms, we usually treat them more as parents than as elements. In particular, the category of Drinfeld modules is quite meaningful while adding/multiplying Drinfeld modules does not make sense. On the other hand, Drinfeld modules do not have elements (as Antoine underlined, they are not modules in the usual sense). This is the main abstract reason why we believe that implementing them as category objects is a solution. Besides, in practice, we realized that the framework is also convenient (e.g. it makes easier the creation of Drinfeld modules).\n\n\nI don\u2019t really see how this makes the creation any easier, at least from a user point of view. The input is the input. There is perhaps one less parent that you need to create when implementing them. Although if there is truly less data (other than the homset), then I would suspect you are treating them as very different objects than ring morphisms. Or am I missing something?\n\nTo that effect, one big disadvantage of them not being a ring morphism is that you cannot use them as such. If you overrode the `__call__` to have them act as a morphism, that is basically the point I was making that they are behaving like elements.\n\nAlso, ideals are something in the other direction: parent like objects that are also elements.\n\n> Previously, I clumsily compared Drinfeld modules with representations; it's certainly better to compare them with elliptic curves (which are the objects they are supposed in mimic in the context of function fields). By definition, an elliptic curve is the datum of a Weierstrass equation (i.e. an equation of the form `y^2 = x^3 + a*x + b`, at least in characteristic different from 2 and 3); however, nobody considers seriously to implement them as elements in the ring of bivariate polynomials. One reason is that adding/multiplying Weierstrass equations is not meaningful.\n\n\nI am guessing you mean as an ideal of bivariate polynomials since polynomials themselves cannot have equality? However, this doesn\u2019t have a choice of base ring fixed, right? If so, then the parallel is lost a bit on me.\n\n> Besides, we do not really want an abstract elliptic curve to have elements. (Of course, their sets of points over some fields have elements; one can maybe argue that, when considered as a scheme, the elements of an elliptic curve are the prime ideals of the quotient ring `K[x,y]/(y^2 - x^3 - a*x - b)` but this is probably not really what is expected by the user.)\n> \n> In [SageMath](SageMath), elliptic curves are parents:\n> \n> ```\n> sage: E = EllipticCurve(u'389a')\n> sage: E\n> Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field\n> sage: isinstance(E, Parent)\n> True\n> ```\n> \n> However, `E` does not have elements:\n> \n> ```\n> sage: E._element_constructor_\n> Traceback (most recent call last):\n> ...\n> AttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute '_element_constructor_'\n> \n> sage: E.element_class\n> Traceback (most recent call last):\n> ...\n> AttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute 'element_class'\n> ```\n> \n> and the method `__call__` has been overriden to create set of points:\n> \n> ```\n> sage: E(QQ)\n> Abelian group of points on Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field\n> ```\n> \n> We somehow decided to follow the same pattern for Drinfeld modules, except that, given that they do have not elements, we found that `CategoryObject` was better suited. (I assume that the class `CategoryObject` was not already introduced when elliptic curves were first implemented in [SageMath](SageMath).)\n\n\nAlthough that suggests that an elliptic curve might be better considered as a functor from Rings to Sets would you say?\n\nI am a little more convinced that this could be reasonable, but it seems a bit like you have to ignore some of the fundamental mathematical definition to make this fit.\n\n> > You are using the category like a parent and the parents like elements. Your code also reflects this with implementing methods that you were expected to overload with non-generic versions.\n\n> \n> I don't have that feeling.\n> \n> For instance, we have a constructor for directly creating Drinfeld modules without passing through the parent/category. (I agree that such constructors exist elsewhere in sage, e.g. `matrix`, but they are not that common.) Also, as Antoine already said, we plan to implement `Hom(phi, psi)` when `phi` and `psi` are Drinfeld modules.\n\n\nIt actually is somewhat common as another example is `polygen` and is done a lot in the combinatorics code. Having it be a `CategoryObject` instead of a subclass of `Element` doesn\u2019t make a difference to me for the main entry point. It is equivalent to rebranding something in my mind.\n\n> We override `__call__` for the convenience of the user, but if you don't like this, we can probably just get rid of this.\n\n\nI think there will have to be some overriding of things to make it convenient.\n\nI am slightly worried that convenience (say, not getting the Ore polynomial ring for constructing the morphisms) is being prioritized at the sake of the mathematical description. It starts making things a little less flexible.\n\nI should also state for the record I am not opposed to using `CategoryObject`, nor do I have too much stake in this as it is (clearly) outside of my main mathematical areas. I am just trying to see if there is a better framework for this implementation.",
    "created_at": "2022-06-18T06:01:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672031",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:48'></a>
Replying to [caruso](#comment%3A46):
> Replying to [tscrim](#comment%3A44):
> > > We've been thinking about this with Xavier (who I visited this week), and we
> > > wrote a different implementation that inherits `CategoryObject` instead of
> > > `RingHomomorphism_im_gens`.

> > 
> > Can you explain a bit more of your reasoning/overall design?

> 
> As I tried to argue before, the overall idea is that, although Drinfeld modules are defined as ring homomorphisms, we usually treat them more as parents than as elements. In particular, the category of Drinfeld modules is quite meaningful while adding/multiplying Drinfeld modules does not make sense. On the other hand, Drinfeld modules do not have elements (as Antoine underlined, they are not modules in the usual sense). This is the main abstract reason why we believe that implementing them as category objects is a solution. Besides, in practice, we realized that the framework is also convenient (e.g. it makes easier the creation of Drinfeld modules).


I don’t really see how this makes the creation any easier, at least from a user point of view. The input is the input. There is perhaps one less parent that you need to create when implementing them. Although if there is truly less data (other than the homset), then I would suspect you are treating them as very different objects than ring morphisms. Or am I missing something?

To that effect, one big disadvantage of them not being a ring morphism is that you cannot use them as such. If you overrode the `__call__` to have them act as a morphism, that is basically the point I was making that they are behaving like elements.

Also, ideals are something in the other direction: parent like objects that are also elements.

> Previously, I clumsily compared Drinfeld modules with representations; it's certainly better to compare them with elliptic curves (which are the objects they are supposed in mimic in the context of function fields). By definition, an elliptic curve is the datum of a Weierstrass equation (i.e. an equation of the form `y^2 = x^3 + a*x + b`, at least in characteristic different from 2 and 3); however, nobody considers seriously to implement them as elements in the ring of bivariate polynomials. One reason is that adding/multiplying Weierstrass equations is not meaningful.


I am guessing you mean as an ideal of bivariate polynomials since polynomials themselves cannot have equality? However, this doesn’t have a choice of base ring fixed, right? If so, then the parallel is lost a bit on me.

> Besides, we do not really want an abstract elliptic curve to have elements. (Of course, their sets of points over some fields have elements; one can maybe argue that, when considered as a scheme, the elements of an elliptic curve are the prime ideals of the quotient ring `K[x,y]/(y^2 - x^3 - a*x - b)` but this is probably not really what is expected by the user.)
> 
> In [SageMath](SageMath), elliptic curves are parents:
> 
> ```
> sage: E = EllipticCurve(u'389a')
> sage: E
> Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
> sage: isinstance(E, Parent)
> True
> ```
> 
> However, `E` does not have elements:
> 
> ```
> sage: E._element_constructor_
> Traceback (most recent call last):
> ...
> AttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute '_element_constructor_'
> 
> sage: E.element_class
> Traceback (most recent call last):
> ...
> AttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute 'element_class'
> ```
> 
> and the method `__call__` has been overriden to create set of points:
> 
> ```
> sage: E(QQ)
> Abelian group of points on Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
> ```
> 
> We somehow decided to follow the same pattern for Drinfeld modules, except that, given that they do have not elements, we found that `CategoryObject` was better suited. (I assume that the class `CategoryObject` was not already introduced when elliptic curves were first implemented in [SageMath](SageMath).)


Although that suggests that an elliptic curve might be better considered as a functor from Rings to Sets would you say?

I am a little more convinced that this could be reasonable, but it seems a bit like you have to ignore some of the fundamental mathematical definition to make this fit.

> > You are using the category like a parent and the parents like elements. Your code also reflects this with implementing methods that you were expected to overload with non-generic versions.

> 
> I don't have that feeling.
> 
> For instance, we have a constructor for directly creating Drinfeld modules without passing through the parent/category. (I agree that such constructors exist elsewhere in sage, e.g. `matrix`, but they are not that common.) Also, as Antoine already said, we plan to implement `Hom(phi, psi)` when `phi` and `psi` are Drinfeld modules.


It actually is somewhat common as another example is `polygen` and is done a lot in the combinatorics code. Having it be a `CategoryObject` instead of a subclass of `Element` doesn’t make a difference to me for the main entry point. It is equivalent to rebranding something in my mind.

> We override `__call__` for the convenience of the user, but if you don't like this, we can probably just get rid of this.


I think there will have to be some overriding of things to make it convenient.

I am slightly worried that convenience (say, not getting the Ore polynomial ring for constructing the morphisms) is being prioritized at the sake of the mathematical description. It starts making things a little less flexible.

I should also state for the record I am not opposed to using `CategoryObject`, nor do I have too much stake in this as it is (clearly) outside of my main mathematical areas. I am just trying to see if there is a better framework for this implementation.



---

archive/issue_comments_672032.json:
```json
{
    "body": "<a id='comment:49'></a>\nReplying to [tscrim](#comment%3A48):\n> I don\u2019t really see how this makes the creation any easier, at least from a user point of view. The input is the input. There is perhaps one less parent that you need to create when implementing them. Although if there is truly less data (other than the homset), then I would suspect you are treating them as very different objects than ring morphisms. Or am I missing something?\n\n\nYou're right, the data are always the same.\n\nHowever, the standard way to define a morphism in sage is first to create the domain (here `Fq[X]`) and the codomain (here `L{tau}` which is a skew polynomial ring) and then to give the image of the generator (namely `X`). And, it is indeed the approach which was originally followed by Antoine.\nThen David complains, saying that it was maybe too complicated for the user.\n\nAt first, I rather disagreed but then I realized that the twisting morphism `tau` is entirely determined by the other data: it is the Frobenius map `x |-> x^q` (where q is the cardinality of `Fq`). So one can actually let the software build the codomain `L{tau}`, which is a huge simplification regarding the interface: the user only has to construct `Fq[X]`, `L` and then to pass in the coefficients of the image of `X`.\n\nOf course, I agree that it is not a strong argument because the above simplification can be equally \nimplemented in both models (morphism and category object). However, I would say that it looks less natural in the first case because it somehow \"breaks\" the classical method to define morphisms in sage.\n\n> To that effect, one big disadvantage of them not being a ring morphism is that you cannot use them as such. If you overrode the `__call__` to have them act as a morphism, that is basically the point I was making that they are behaving like elements.\n\n\nI agree that it is a disadvantage.\nBut I think that there are (maybe more) similar disadvantages in the other direction. I've mentioned for instance the creation of hom spaces between Drinfeld modules, which might look a bit weird if Drinfeld modules are themselves morphisms (and not parents). In a similar fashion, the methods `rank`, `characteristic`, `frobenius_charpoly`, etc. belong to the lexical field of modules and not to that of ring homomorphisms. Actually, I do not blame Drinfeld for choosing the word module for designing those object; I believe that calling them Drinfeld morphisms would cause more confusion.\n\n> I am guessing you mean as an ideal of bivariate polynomials since polynomials themselves cannot have equality?\n\n\nActually, I was thinking of the difference `y^2 - x^3 - a*x - b` but, you're right, ideals are better here.\n\n> However, this doesn\u2019t have a choice of base ring fixed, right? If so, then the parallel is lost a bit on me.\n\n\nI'm not sure to understand your point. In general, a base ring is fixed when we talk about an elliptic curve (this is a ring containing the parameters `a` and `b`), even though we then allows ourselves to look at points over extensions. We have the same behaviour for polynomials: they have coefficients in a fixed base, but we allow ourselves to consider roots in extensions. And the same is true for Drinfeld modules: the coefficients defining them lie in a base field `L` but we let it act not only on `L` but on its extensions as well.\n\n> Although that suggests that an elliptic curve might be better considered as a functor from Rings to Sets would you say?\n\n\nThere are (at least) three different points of view on ellptic curves (or, more generally, on algebraic varieties) which are, I think, equally good (or, depending on your philosophy, equally bad because they all only capture one portion of the complexity of the situation):\n- a defining polynomial (or a defining ideal),\n- a scheme, *i.e.* a space endowed with the Zariski topology (and maybe additional structures like a sheaf),\n- a functor from the category of `A`-algebras (if `A` is the base ring over which the elliptic curve is defined) to the category of sets.\n\nI don't think we have to favor one of this point of view in the implementation. On the contrary, one option is to implement elliptic curves as abstract objects in some category and provide general categorical methods together with more specific methods related to the viewpoints listed above.\n\n> I am a little more convinced that this could be reasonable, but it seems a bit like you have to ignore some of the fundamental mathematical definition to make this fit.\n\n\nIn my understanding, the fact that Drinfeld modules are defined as homomorphisms between some rings in a kind of accidents (I'm not sure but I think, for instance, that they could also be defined as actions of a certain type `Fq[X]` on `Fqbar`). What is important is that they exhibit many similar properties to elliptic curves.\n\n> I should also state for the record I am not opposed to using `CategoryObject`, nor do I have too much stake in this as it is (clearly) outside of my main mathematical areas. I am just trying to see if there is a better framework for this implementation.\n\n\nWell, I don't know either what is the best solution for this implementation. And I'm clearly very happy to discuss this with you who has a different understanding of the mathematical background.",
    "created_at": "2022-06-19T13:15:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672032",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:49'></a>
Replying to [tscrim](#comment%3A48):
> I don’t really see how this makes the creation any easier, at least from a user point of view. The input is the input. There is perhaps one less parent that you need to create when implementing them. Although if there is truly less data (other than the homset), then I would suspect you are treating them as very different objects than ring morphisms. Or am I missing something?


You're right, the data are always the same.

However, the standard way to define a morphism in sage is first to create the domain (here `Fq[X]`) and the codomain (here `L{tau}` which is a skew polynomial ring) and then to give the image of the generator (namely `X`). And, it is indeed the approach which was originally followed by Antoine.
Then David complains, saying that it was maybe too complicated for the user.

At first, I rather disagreed but then I realized that the twisting morphism `tau` is entirely determined by the other data: it is the Frobenius map `x |-> x^q` (where q is the cardinality of `Fq`). So one can actually let the software build the codomain `L{tau}`, which is a huge simplification regarding the interface: the user only has to construct `Fq[X]`, `L` and then to pass in the coefficients of the image of `X`.

Of course, I agree that it is not a strong argument because the above simplification can be equally 
implemented in both models (morphism and category object). However, I would say that it looks less natural in the first case because it somehow "breaks" the classical method to define morphisms in sage.

> To that effect, one big disadvantage of them not being a ring morphism is that you cannot use them as such. If you overrode the `__call__` to have them act as a morphism, that is basically the point I was making that they are behaving like elements.


I agree that it is a disadvantage.
But I think that there are (maybe more) similar disadvantages in the other direction. I've mentioned for instance the creation of hom spaces between Drinfeld modules, which might look a bit weird if Drinfeld modules are themselves morphisms (and not parents). In a similar fashion, the methods `rank`, `characteristic`, `frobenius_charpoly`, etc. belong to the lexical field of modules and not to that of ring homomorphisms. Actually, I do not blame Drinfeld for choosing the word module for designing those object; I believe that calling them Drinfeld morphisms would cause more confusion.

> I am guessing you mean as an ideal of bivariate polynomials since polynomials themselves cannot have equality?


Actually, I was thinking of the difference `y^2 - x^3 - a*x - b` but, you're right, ideals are better here.

> However, this doesn’t have a choice of base ring fixed, right? If so, then the parallel is lost a bit on me.


I'm not sure to understand your point. In general, a base ring is fixed when we talk about an elliptic curve (this is a ring containing the parameters `a` and `b`), even though we then allows ourselves to look at points over extensions. We have the same behaviour for polynomials: they have coefficients in a fixed base, but we allow ourselves to consider roots in extensions. And the same is true for Drinfeld modules: the coefficients defining them lie in a base field `L` but we let it act not only on `L` but on its extensions as well.

> Although that suggests that an elliptic curve might be better considered as a functor from Rings to Sets would you say?


There are (at least) three different points of view on ellptic curves (or, more generally, on algebraic varieties) which are, I think, equally good (or, depending on your philosophy, equally bad because they all only capture one portion of the complexity of the situation):
- a defining polynomial (or a defining ideal),
- a scheme, *i.e.* a space endowed with the Zariski topology (and maybe additional structures like a sheaf),
- a functor from the category of `A`-algebras (if `A` is the base ring over which the elliptic curve is defined) to the category of sets.

I don't think we have to favor one of this point of view in the implementation. On the contrary, one option is to implement elliptic curves as abstract objects in some category and provide general categorical methods together with more specific methods related to the viewpoints listed above.

> I am a little more convinced that this could be reasonable, but it seems a bit like you have to ignore some of the fundamental mathematical definition to make this fit.


In my understanding, the fact that Drinfeld modules are defined as homomorphisms between some rings in a kind of accidents (I'm not sure but I think, for instance, that they could also be defined as actions of a certain type `Fq[X]` on `Fqbar`). What is important is that they exhibit many similar properties to elliptic curves.

> I should also state for the record I am not opposed to using `CategoryObject`, nor do I have too much stake in this as it is (clearly) outside of my main mathematical areas. I am just trying to see if there is a better framework for this implementation.


Well, I don't know either what is the best solution for this implementation. And I'm clearly very happy to discuss this with you who has a different understanding of the mathematical background.



---

archive/issue_comments_672033.json:
```json
{
    "body": "<a id='comment:50'></a>\nReplying to [tscrim](#comment%3A47):\n\n> Yes, we do. See my comments above. I also have a little bit of experience with this that tells me this is the right thing to do.\n\n\n> Okay, thank you for the explanation. I am guessing there isn\u2019t anything known about the dimension or generators/basis?\n\n\nActually, we might have some results on this. The easy case is when isogenies\nare endomorphisms. Here, Drinfeld modules would behave as elliptic curves, and\nthe theory of complex multiplications provides us with many results regarding\nthe structure of endomorphisms as free modules. See [Goss 1998, ''Basic\nstructures of function field arithmetic'', Section 4.7].\n\nIf the isogenies are not endomorphisms, we can look at isogenies that have\nfixed `\\tau`-degree. There is only a finite number of those, which makes them a\nfinite `\\Fq`-vector space. We have not looked at anything here, but it is\nplausible that one could find some structure.\n\n\n\n> > > Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?\n\n> > \n> > I did --- they form a category.\n\n> \n> That is not a structure of the objects. Essentially anything can be objects in a category, just like anything can be in a set. The elements of a ring form a perfectly nice category with on the identity morphism on each object (a discrete category).\n> \n> > I have not heard of any other (meaningful) structure.\n\n> \n> That is what I wanted to know.\n\n\nThank you for letting me know. As I have trouble precisely understanding what\nyou have in mind, could you next time be more precise? As I think many answers\nwere already given in my previous posts, this is probably the best way not to\nwaste both our time, wouldn't you agree?\n\n\n> > It literally was in the part of the post you replied to.\n\n> \n> I am trying to not be snarky in my replies, but I don\u2019t appreciate the tone of your comment here.\n\n\nApologies for this. Rereading the discussion I acknowledge that my phrasing\nmade me sound more cutting than diplomatically acceptable. Next time let us ask\nquestions with more details, as to avoid those miscommunications.",
    "created_at": "2022-06-20T22:09:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672033",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:50'></a>
Replying to [tscrim](#comment%3A47):

> Yes, we do. See my comments above. I also have a little bit of experience with this that tells me this is the right thing to do.


> Okay, thank you for the explanation. I am guessing there isn’t anything known about the dimension or generators/basis?


Actually, we might have some results on this. The easy case is when isogenies
are endomorphisms. Here, Drinfeld modules would behave as elliptic curves, and
the theory of complex multiplications provides us with many results regarding
the structure of endomorphisms as free modules. See [Goss 1998, ''Basic
structures of function field arithmetic'', Section 4.7].

If the isogenies are not endomorphisms, we can look at isogenies that have
fixed `\tau`-degree. There is only a finite number of those, which makes them a
finite `\Fq`-vector space. We have not looked at anything here, but it is
plausible that one could find some structure.



> > > Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?

> > 
> > I did --- they form a category.

> 
> That is not a structure of the objects. Essentially anything can be objects in a category, just like anything can be in a set. The elements of a ring form a perfectly nice category with on the identity morphism on each object (a discrete category).
> 
> > I have not heard of any other (meaningful) structure.

> 
> That is what I wanted to know.


Thank you for letting me know. As I have trouble precisely understanding what
you have in mind, could you next time be more precise? As I think many answers
were already given in my previous posts, this is probably the best way not to
waste both our time, wouldn't you agree?


> > It literally was in the part of the post you replied to.

> 
> I am trying to not be snarky in my replies, but I don’t appreciate the tone of your comment here.


Apologies for this. Rereading the discussion I acknowledge that my phrasing
made me sound more cutting than diplomatically acceptable. Next time let us ask
questions with more details, as to avoid those miscommunications.



---

archive/issue_comments_672034.json:
```json
{
    "body": "<a id='comment:51'></a>\nReplying to [caruso](#comment%3A49):\n\n> \n> You're right, the data are always the same.\n> \n> However, the standard way to define a morphism in sage is first to create the domain (here `Fq[X]`) and the codomain (here `L{tau}` which is a skew polynomial ring) and then to give the image of the generator (namely `X`). And, it is indeed the approach which was originally followed by Antoine.\n> Then David complains, saying that it was maybe too complicated for the user.\n> \n> At first, I rather disagreed but then I realized that the twisting morphism `tau` is entirely determined by the other data: it is the Frobenius map `x |-> x^q` (where q is the cardinality of `Fq`). So one can actually let the software build the codomain `L{tau}`, which is a huge simplification regarding the interface: the user only has to construct `Fq[X]`, `L` and then to pass in the coefficients of the image of `X`.\n\n\nI would also add that, in fact, we do not even need to build `\\Fq[X]`. Its\nconstruction (as is the one of `L\\{\\tau\\}`) can be delegated to the constructor\nof the Drinfeld module. We would come to something like this:\n\n```python\nsage: Fq = GF(5^2)\nsage: L.<omega> = GF(5^6)\nsage: phi = FiniteDrinfeldModule(Fq, [omega, 1, 1])\n```\n\nWhat would be your opinion on this?\n\n> I don't think we have to favor one of this point of view in the implementation. On the contrary, one option is to implement elliptic curves as abstract objects in some category and provide general categorical methods together with more specific methods related to the viewpoints listed above.\n\n\nTo add up to the discussion regarding the creation of a category and\nimplementing the Drinfeld modules as `CategoryObject`, I think that the example\nof the `\\Fq[X]`-characteristic is quite relevant.\n\nLet us recall the general analogy of finite `\\Fq[X]`-Drinfeld modules and\nelliptic curves defined other finite fields. Finite fields have a\ncharacteristic, which is an integer `p \\in \\N`. This object does not depend on\nany elliptic curve; it is intrinsic to the finite field. However, the\ncharacteristic of the finite field *does* have strong implications on\nelliptic curves defined on the field. The most famous example is the fact that\nthe `p`-torsion is either trivial or `(\\Z/p\\Z)^\\times`.\n\nIt turns out that the *characteristic* associated to Drinfeld modules (which\nI will now be referring to as the *`\\Fq[X]`-characteristic*) I mentioned many\ntimes earlier is exactly the analogue, for Drinfeld modules, of the standard\ncharacteristic in finite fields. In fact, it is a polynomial in `\\Fq[X]` that\nis intrinsic to the setting, which is given by `Fq`, `L`, and `omega`. In this\ncontext, the `\\Fq[X]-characteristic` can exactly be defined as the minimal\npolynomial of `omega` over `Fq`, where `\\omega` is the constant term of\n`\\phi(X)` for any Drinfeld module `\\phi` in the category. See [Goss, Definition\n3.6.1].\n\nI believe you would never make the characteristic of a finite field a property\nof an elliptic curve. Therefore, we should not make the `\\Fq[X}`-characteristic\na property of the Drinfeld modules. It is a mistake on my side for doing it\nearlier, and I am sorry if this led to misunderstandings.\n\nXavier was right to suggest the creation of the category, as it would\nencapsulate all those fixed parameters: `\\Fq[X]`, `L\\{\\tau\\}` and `omega`/the\n`\\Fq[X]`-characteristic.",
    "created_at": "2022-06-20T22:13:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672034",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:51'></a>
Replying to [caruso](#comment%3A49):

> 
> You're right, the data are always the same.
> 
> However, the standard way to define a morphism in sage is first to create the domain (here `Fq[X]`) and the codomain (here `L{tau}` which is a skew polynomial ring) and then to give the image of the generator (namely `X`). And, it is indeed the approach which was originally followed by Antoine.
> Then David complains, saying that it was maybe too complicated for the user.
> 
> At first, I rather disagreed but then I realized that the twisting morphism `tau` is entirely determined by the other data: it is the Frobenius map `x |-> x^q` (where q is the cardinality of `Fq`). So one can actually let the software build the codomain `L{tau}`, which is a huge simplification regarding the interface: the user only has to construct `Fq[X]`, `L` and then to pass in the coefficients of the image of `X`.


I would also add that, in fact, we do not even need to build `\Fq[X]`. Its
construction (as is the one of `L\{\tau\}`) can be delegated to the constructor
of the Drinfeld module. We would come to something like this:

```python
sage: Fq = GF(5^2)
sage: L.<omega> = GF(5^6)
sage: phi = FiniteDrinfeldModule(Fq, [omega, 1, 1])
```

What would be your opinion on this?

> I don't think we have to favor one of this point of view in the implementation. On the contrary, one option is to implement elliptic curves as abstract objects in some category and provide general categorical methods together with more specific methods related to the viewpoints listed above.


To add up to the discussion regarding the creation of a category and
implementing the Drinfeld modules as `CategoryObject`, I think that the example
of the `\Fq[X]`-characteristic is quite relevant.

Let us recall the general analogy of finite `\Fq[X]`-Drinfeld modules and
elliptic curves defined other finite fields. Finite fields have a
characteristic, which is an integer `p \in \N`. This object does not depend on
any elliptic curve; it is intrinsic to the finite field. However, the
characteristic of the finite field *does* have strong implications on
elliptic curves defined on the field. The most famous example is the fact that
the `p`-torsion is either trivial or `(\Z/p\Z)^\times`.

It turns out that the *characteristic* associated to Drinfeld modules (which
I will now be referring to as the *`\Fq[X]`-characteristic*) I mentioned many
times earlier is exactly the analogue, for Drinfeld modules, of the standard
characteristic in finite fields. In fact, it is a polynomial in `\Fq[X]` that
is intrinsic to the setting, which is given by `Fq`, `L`, and `omega`. In this
context, the `\Fq[X]-characteristic` can exactly be defined as the minimal
polynomial of `omega` over `Fq`, where `\omega` is the constant term of
`\phi(X)` for any Drinfeld module `\phi` in the category. See [Goss, Definition
3.6.1].

I believe you would never make the characteristic of a finite field a property
of an elliptic curve. Therefore, we should not make the `\Fq[X}`-characteristic
a property of the Drinfeld modules. It is a mistake on my side for doing it
earlier, and I am sorry if this led to misunderstandings.

Xavier was right to suggest the creation of the category, as it would
encapsulate all those fixed parameters: `\Fq[X]`, `L\{\tau\}` and `omega`/the
`\Fq[X]`-characteristic.



---

archive/issue_comments_672035.json:
```json
{
    "body": "<a id='comment:52'></a>\nReplying to [antoine-leudiere](#comment%3A51):\n> I would also add that, in fact, we do not even need to build `\\Fq[X]`. Its\n> construction (as is the one of `L\\{\\tau\\}`) can be delegated to the constructor\n> of the Drinfeld module. We would come to something like this:\n> \n> ```python\n> sage: Fq = GF(5^2)\n> sage: L.<omega> = GF(5^6)\n> sage: phi = FiniteDrinfeldModule(Fq, [omega, 1, 1])\n> ```\n> \n> What would be your opinion on this?\n\n\nI'm not sure because, in full generality, Drinfeld modules are \"defined\" over more general rings that `Fq[x]`. Thus, if in the future, we want to implement more general Drinfeld, I think that making the confusion now between `Fq` and `Fq[x]` would cause much trouble.",
    "created_at": "2022-06-21T07:31:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672035",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:52'></a>
Replying to [antoine-leudiere](#comment%3A51):
> I would also add that, in fact, we do not even need to build `\Fq[X]`. Its
> construction (as is the one of `L\{\tau\}`) can be delegated to the constructor
> of the Drinfeld module. We would come to something like this:
> 
> ```python
> sage: Fq = GF(5^2)
> sage: L.<omega> = GF(5^6)
> sage: phi = FiniteDrinfeldModule(Fq, [omega, 1, 1])
> ```
> 
> What would be your opinion on this?


I'm not sure because, in full generality, Drinfeld modules are "defined" over more general rings that `Fq[x]`. Thus, if in the future, we want to implement more general Drinfeld, I think that making the confusion now between `Fq` and `Fq[x]` would cause much trouble.



---

archive/issue_comments_672036.json:
```json
{
    "body": "<a id='comment:53'></a>\nReplying to [caruso](#comment%3A52):\n> Replying to [antoine-leudiere](#comment%3A51):\n> > I would also add that, in fact, we do not even need to build `\\Fq[X]`. Its\n> > construction (as is the one of `L\\{\\tau\\}`) can be delegated to the constructor\n> > of the Drinfeld module. We would come to something like this:\n> > \n> > ```python\n> > sage: Fq = GF(5^2)\n> > sage: L.<omega> = GF(5^6)\n> > sage: phi = FiniteDrinfeldModule(Fq, [omega, 1, 1])\n> > ```\n> > \n> > What would be your opinion on this?\n\n> \n> I'm not sure because, in full generality, Drinfeld modules are \"defined\" over more general rings that `Fq[x]`. Thus, if in the future, we want to implement more general Drinfeld, I think that making the confusion now between `Fq` and `Fq[x]` would can much trouble.\n\n\nOk, that's fine for me.",
    "created_at": "2022-06-21T08:48:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672036",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:53'></a>
Replying to [caruso](#comment%3A52):
> Replying to [antoine-leudiere](#comment%3A51):
> > I would also add that, in fact, we do not even need to build `\Fq[X]`. Its
> > construction (as is the one of `L\{\tau\}`) can be delegated to the constructor
> > of the Drinfeld module. We would come to something like this:
> > 
> > ```python
> > sage: Fq = GF(5^2)
> > sage: L.<omega> = GF(5^6)
> > sage: phi = FiniteDrinfeldModule(Fq, [omega, 1, 1])
> > ```
> > 
> > What would be your opinion on this?

> 
> I'm not sure because, in full generality, Drinfeld modules are "defined" over more general rings that `Fq[x]`. Thus, if in the future, we want to implement more general Drinfeld, I think that making the confusion now between `Fq` and `Fq[x]` would can much trouble.


Ok, that's fine for me.



---

archive/issue_comments_672037.json:
```json
{
    "body": "<a id='comment:54'></a>\nOther small comments:\n- I think that your constructor should not be `FiniteDrinfeldModule` but just `DrinfeldModule`; it can decide by itself if the Drinfeld module is finite or not (and then instantiate the correct class accordingly).\n- IMHO, your `_repr_` method is a bit too verbose; I think that `Drinfeld module X |--> t^2 + t + w` is enough.\n- I'm not sure that `sage.rings.function_field` is the right place for your module; indeed, Drinfeld modules are not function fields, and even rings. (However, I don't know where it should go instead.)",
    "created_at": "2022-06-21T09:07:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672037",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:54'></a>
Other small comments:
- I think that your constructor should not be `FiniteDrinfeldModule` but just `DrinfeldModule`; it can decide by itself if the Drinfeld module is finite or not (and then instantiate the correct class accordingly).
- IMHO, your `_repr_` method is a bit too verbose; I think that `Drinfeld module X |--> t^2 + t + w` is enough.
- I'm not sure that `sage.rings.function_field` is the right place for your module; indeed, Drinfeld modules are not function fields, and even rings. (However, I don't know where it should go instead.)



---

archive/issue_comments_672038.json:
```json
{
    "body": "<a id='comment:55'></a>\nReplying to [caruso](#comment%3A54):\n> I'm not sure because, in full generality, Drinfeld modules are \"defined\" over more general rings that `Fq[x]`. Thus, if in the future, we want to implement more general Drinfeld, I think that making the confusion now between `Fq` and `Fq[x]` would cause much trouble.\n\n\nI also agree. I think that it is important to note that Drinfeld module are usually defined over two things: a ring a functions (denoted here by `A`) regular outside a closed point of some smooth curve over `Fq` AND a `A`-field `L` (a field with a fixed morphism `A --> L`). In FULL generality, a Drinfeld module is defined over a `A`-scheme `S`, and this implementation focus on the special case `S = Spec(L)`. `A` here plays the same role as the integers `Z` and `L` would play the role of the field of definition of an elliptic curve. However, in the function field setting, we have more rings representing the ring of integers.\n\n> - I think that your constructor should not be `FiniteDrinfeldModule` but just `DrinfeldModule`; it can decide by itself if the Drinfeld module is finite or not (and then instantiate the correct class accordingly).\n\n\n+1\n\n> - IMHO, your `_repr_` method is a bit too verbose; I think that `Drinfeld module X |--> t^2 + t + w` is enough.\n\n\nSuggestion:\n\n`Drinfeld Module defined by X |--> t^2 + t + w over Finite Field in w of size 5^6`\n\nThis would, in my opinion, agree with most string representation of multiple objects in [SageMath](SageMath). For example, for an elliptic curve we have:\n\n`Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field`\n\n\n> - I'm not sure that `sage.rings.function_field` is the right place for your module; indeed, Drinfeld modules are not function fields, and even rings. (However, I don't know where it should go instead.)\n\n\nI don't know too, but maybe it would be better to simply place it in a new directory: `sage.drinfeld_modules`. The other closest directory in my opinion would be `sage.schemes`, but this would be wrong because Drinfeld modules are not schemes.",
    "created_at": "2022-06-21T18:14:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672038",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:55'></a>
Replying to [caruso](#comment%3A54):
> I'm not sure because, in full generality, Drinfeld modules are "defined" over more general rings that `Fq[x]`. Thus, if in the future, we want to implement more general Drinfeld, I think that making the confusion now between `Fq` and `Fq[x]` would cause much trouble.


I also agree. I think that it is important to note that Drinfeld module are usually defined over two things: a ring a functions (denoted here by `A`) regular outside a closed point of some smooth curve over `Fq` AND a `A`-field `L` (a field with a fixed morphism `A --> L`). In FULL generality, a Drinfeld module is defined over a `A`-scheme `S`, and this implementation focus on the special case `S = Spec(L)`. `A` here plays the same role as the integers `Z` and `L` would play the role of the field of definition of an elliptic curve. However, in the function field setting, we have more rings representing the ring of integers.

> - I think that your constructor should not be `FiniteDrinfeldModule` but just `DrinfeldModule`; it can decide by itself if the Drinfeld module is finite or not (and then instantiate the correct class accordingly).


+1

> - IMHO, your `_repr_` method is a bit too verbose; I think that `Drinfeld module X |--> t^2 + t + w` is enough.


Suggestion:

`Drinfeld Module defined by X |--> t^2 + t + w over Finite Field in w of size 5^6`

This would, in my opinion, agree with most string representation of multiple objects in [SageMath](SageMath). For example, for an elliptic curve we have:

`Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field`


> - I'm not sure that `sage.rings.function_field` is the right place for your module; indeed, Drinfeld modules are not function fields, and even rings. (However, I don't know where it should go instead.)


I don't know too, but maybe it would be better to simply place it in a new directory: `sage.drinfeld_modules`. The other closest directory in my opinion would be `sage.schemes`, but this would be wrong because Drinfeld modules are not schemes.



---

archive/issue_comments_672039.json:
```json
{
    "body": "<a id='comment:56'></a>\nAlso: should this implementation use the function field functionalities already implemented in [SageMath](SageMath)? For example, we have:\n\n```\nsage: K.<X> = FunctionField(GF(5**3)); K\nRational function field in X over Finite Field in z3 of size 5^3\nsage: O = K.order(1/X); O\nOrder in Rational function field in X over Finite Field in z3 of size 5^3\nsage: X in O\nTrue\nsage: 1/X in O\nFalse\n```\n\nI have to admit that I'm a little bit on the fence on this, because this would, in my opinion, be a little bit more mathematically precise, however, I don't think that it would be good for computational purpose. What do you all think of this?",
    "created_at": "2022-06-21T18:31:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672039",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:56'></a>
Also: should this implementation use the function field functionalities already implemented in [SageMath](SageMath)? For example, we have:

```
sage: K.<X> = FunctionField(GF(5**3)); K
Rational function field in X over Finite Field in z3 of size 5^3
sage: O = K.order(1/X); O
Order in Rational function field in X over Finite Field in z3 of size 5^3
sage: X in O
True
sage: 1/X in O
False
```

I have to admit that I'm a little bit on the fence on this, because this would, in my opinion, be a little bit more mathematically precise, however, I don't think that it would be good for computational purpose. What do you all think of this?



---

archive/issue_comments_672040.json:
```json
{
    "body": "<a id='comment:57'></a>\nThank you all for your comments and explanations.\n\n---\n\nThis is a picture of my understanding (using `t = \\tau`) of the mathematics.\n\nThe main object/category we are considering is\n\n```\nDM <=  Hom(Fq[x], L{t})\n```\nwhere `DM` is the set of Drinfeld modules, `<=` is subset`, and `L{t}` is the ring of Ore polynomials.\nThen taking the `Hom(f,g)` of two elements/objects in `DM`, we get a subset `S` of `L{t}` that has the structure of an `End(g)`-module and `End(g)` is the centralizer of `g(X)` in `L{t}`.\n\nNow we don't really know that much about what is in `DM` or `S`. So it doesn't make so much sense to non-generic implementations for them.\n\nNo matter if you think of `DM` as a category or as a `Parent`, the set `S` would still be a `Hom` subclass with a natural coercion to `L{t}` since `S <= L{t}` (as `End(g)`-modules).\n\n---\n\nIt is perfectly reasonable to have an entry point `DrinfeldModule` that constructs the `DM` and other associated objects, along with convenience methods to not have the user get these intermediate objects. There are lots of examples of this in the Sage library. Basically `DM` would store the relevant information, such as `Fq[X]` and `L{t}`, which is more aligned with the mathematics. This is what you are calling a category, but it would be just as natural to be a `Parent` IMO.\n\nThe biggest justification for using `CategoryObject` to implement Drinfeld modules is that it plugs in naturally with the Sage code `Hom(f, g)`, which you cannot do with ring morphisms. Although this can be worked around with `f.Hom(g)` or something similar. The counterpoint would be it loses the ring morphism knowledge, the data for which you are creating anyways. Also, categories in Sage are not really meant to be used as a substitute `Parent` with a special type of object (i.e., element) class. They are flexible enough to handle this I think, but the general principle is any information they provide should work for generic implementations of the objects.\n\nIt might also be possible to trick `Hom` into working (via ducktyping) with setting the right methods to make a `Parent` `DM` behave like a category and the individual Drinfeld modules behave like a `CategoryObject`.\n\nI guess what I am asking is what do you see as the programming/implementation benefits to using `CategoryObject`? I am not looking for something with the API or that it is closer to how you mathematically think about it, but the underlying code. I guess I am arguing above that the code and design of `Parent` and `Element` match more of your actual implementation.\n\n---\n\nI am a strong +1 on having the main entry point `DrinfeldModule` for future code.\n\nI am -1 on a new top-level folder at this point. Given that they are ring morphisms, `rings.drinfeld_modules` (possibly with that as a subfolder) would be a natural place to me. I don't like the precedent of \"it is kind of like this but not quite so we put just a few things in a new top-level directory.\" It could lead to making our source tree very wide. Another option might be `sets`. If we want to think of them as `Fq[X]`-representations on `Fqbar`, then `modules` would also be natural (even if they are not implemented as such). From what I understand, one of the big things you are after is the set of morphisms between Drinfeld modules, which has a module structure.",
    "created_at": "2022-06-22T03:30:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672040",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:57'></a>
Thank you all for your comments and explanations.

---

This is a picture of my understanding (using `t = \tau`) of the mathematics.

The main object/category we are considering is

```
DM <=  Hom(Fq[x], L{t})
```
where `DM` is the set of Drinfeld modules, `<=` is subset`, and `L{t}` is the ring of Ore polynomials.
Then taking the `Hom(f,g)` of two elements/objects in `DM`, we get a subset `S` of `L{t}` that has the structure of an `End(g)`-module and `End(g)` is the centralizer of `g(X)` in `L{t}`.

Now we don't really know that much about what is in `DM` or `S`. So it doesn't make so much sense to non-generic implementations for them.

No matter if you think of `DM` as a category or as a `Parent`, the set `S` would still be a `Hom` subclass with a natural coercion to `L{t}` since `S <= L{t}` (as `End(g)`-modules).

---

It is perfectly reasonable to have an entry point `DrinfeldModule` that constructs the `DM` and other associated objects, along with convenience methods to not have the user get these intermediate objects. There are lots of examples of this in the Sage library. Basically `DM` would store the relevant information, such as `Fq[X]` and `L{t}`, which is more aligned with the mathematics. This is what you are calling a category, but it would be just as natural to be a `Parent` IMO.

The biggest justification for using `CategoryObject` to implement Drinfeld modules is that it plugs in naturally with the Sage code `Hom(f, g)`, which you cannot do with ring morphisms. Although this can be worked around with `f.Hom(g)` or something similar. The counterpoint would be it loses the ring morphism knowledge, the data for which you are creating anyways. Also, categories in Sage are not really meant to be used as a substitute `Parent` with a special type of object (i.e., element) class. They are flexible enough to handle this I think, but the general principle is any information they provide should work for generic implementations of the objects.

It might also be possible to trick `Hom` into working (via ducktyping) with setting the right methods to make a `Parent` `DM` behave like a category and the individual Drinfeld modules behave like a `CategoryObject`.

I guess what I am asking is what do you see as the programming/implementation benefits to using `CategoryObject`? I am not looking for something with the API or that it is closer to how you mathematically think about it, but the underlying code. I guess I am arguing above that the code and design of `Parent` and `Element` match more of your actual implementation.

---

I am a strong +1 on having the main entry point `DrinfeldModule` for future code.

I am -1 on a new top-level folder at this point. Given that they are ring morphisms, `rings.drinfeld_modules` (possibly with that as a subfolder) would be a natural place to me. I don't like the precedent of "it is kind of like this but not quite so we put just a few things in a new top-level directory." It could lead to making our source tree very wide. Another option might be `sets`. If we want to think of them as `Fq[X]`-representations on `Fqbar`, then `modules` would also be natural (even if they are not implemented as such). From what I understand, one of the big things you are after is the set of morphisms between Drinfeld modules, which has a module structure.



---

archive/issue_comments_672041.json:
```json
{
    "body": "<a id='comment:58'></a>\n---\n**Constructor name**\n\nOk for `DrinfeldModule` instead of `FiniteDrinfeldModule`.\n\n---\n**`_repr_` output**\n\nI do not have a strong opinion on this. I always prefer to have all the\ninformation, so I would encline to use David's suggestion.\n\n---\n**Directory in `sage/`**\n\nI agree with Travis. Although `rings.drinfeld_modules` is not ideal, Drinfeld\nmodules will probably interest a few only. In this sense, they probably do not\ndeserve their own directory.\n\nThat being said, L-functions have their own top directory (which can be the\nprecedent that Travis rightfully fears).\n\n---\n**`Parent` vs `CategoryObject` vs something else**\n\nBeing a novice when it comes to [SageMath](SageMath) development, some of your\nconsiderations are a bit far of reach for me at the moment. In particular, I do\nnot have a strong opinion on `Parent` vs `CategoryObject`, and I won't help\nmuch with Travis' interrogation:\n\n> I am not looking for something with the API or that it is closer to how you mathematically think about it, but the underlying code.\n\n\nOne thing is sure, as the main maintener and author of the code, I want to\navoid tricks and workarounds as much as possible. I am not (nor will I ever be)\nworking full time on the code, and I need the codebase to be as straightforward\nas possible to maintain and enrich it.\n\nIt seems to me however that `CategoryObject` (or `Parent`) might be better than\ninheriting `RingHomomorphism`. As Travis pointed out, it plugs naturally with\n`Hom` and `Category`. Creating the morphism, keeping it as an attribute, and\noverloading `__call__` looks reasonable. Double inheritance is also an option,\neven though we all know that it can get tricky.\n\n---\n\nReplying to [gh-DavidAyotte](#comment%3A56):\n> \n> I have to admit that I'm a little bit on the fence on this, because this would, in my opinion, be a little bit more mathematically precise, however, I don't think that it would be good for computational purpose. What do you all think of this?\n\n\nAt some point we will want to use them, if only to extend capabilities of\n`DrinfeldModule`. At the moment, I feel like we should stick to basics (i.e.\nfinite Drinfeld modules over `\\Fq[X]`) and finish this first version (I still\nhave the documentation to write, and probably the `Hom` class to write from\nscratch). Those capabilities, even if basics, will surely come out as very\nhelpful when extending from finite fields to, say, extensions of `\\Fq(X)`.\n\nI realize that I forgot to reply to your comment [comment:43]. My bad, David.\nTo answer: no, I was not planning to open a ticket for the category. As of now,\nthe discussion is centralized and already attracted some people.\n\n\n---\nReplying to [tscrim](#comment%3A57):\n> \n> This is a picture of my understanding (using `t = \\tau`) of the mathematics.\n> \n> The main object/category we are considering is\n> \n> ```\n> DM <=  Hom(Fq[x], L{t})\n> ```\n> where `DM` is the set of Drinfeld modules, `<=` is subset`, and `L{t}` is the ring of Ore polynomials.\n> Then taking the `Hom(f,g)` of two elements/objects in `DM`, we get a subset `S` of `L{t}` that has the structure of an `End(g)`-module and `End(g)` is the centralizer of `g(X)` in `L{t}`.\n\n\nYour understanding is correct.\n\n> Now we don't really know that much about what is in `DM` or `S`. So it doesn't make so much sense to non-generic implementations for them.\n\n\nI am not sure to understand what you mean by 'non-generic implementation'.\n  \n> No matter if you think of `DM` as a category or as a `Parent`, the set `S` would still be a `Hom` subclass with a natural coercion to `L{t}` since `S <= L{t}` (as `End(g)`-modules).\n\n\nWhy would `S` be a `Hom` subclass? It looks as being just a subset of `L{t}`\n(which itself can be seen as a `Hom(Fqbar, Fqbar)` for the structure of\n`Fq`-vector space).",
    "created_at": "2022-06-22T11:04:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672041",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:58'></a>
---
**Constructor name**

Ok for `DrinfeldModule` instead of `FiniteDrinfeldModule`.

---
**`_repr_` output**

I do not have a strong opinion on this. I always prefer to have all the
information, so I would encline to use David's suggestion.

---
**Directory in `sage/`**

I agree with Travis. Although `rings.drinfeld_modules` is not ideal, Drinfeld
modules will probably interest a few only. In this sense, they probably do not
deserve their own directory.

That being said, L-functions have their own top directory (which can be the
precedent that Travis rightfully fears).

---
**`Parent` vs `CategoryObject` vs something else**

Being a novice when it comes to [SageMath](SageMath) development, some of your
considerations are a bit far of reach for me at the moment. In particular, I do
not have a strong opinion on `Parent` vs `CategoryObject`, and I won't help
much with Travis' interrogation:

> I am not looking for something with the API or that it is closer to how you mathematically think about it, but the underlying code.


One thing is sure, as the main maintener and author of the code, I want to
avoid tricks and workarounds as much as possible. I am not (nor will I ever be)
working full time on the code, and I need the codebase to be as straightforward
as possible to maintain and enrich it.

It seems to me however that `CategoryObject` (or `Parent`) might be better than
inheriting `RingHomomorphism`. As Travis pointed out, it plugs naturally with
`Hom` and `Category`. Creating the morphism, keeping it as an attribute, and
overloading `__call__` looks reasonable. Double inheritance is also an option,
even though we all know that it can get tricky.

---

Replying to [gh-DavidAyotte](#comment%3A56):
> 
> I have to admit that I'm a little bit on the fence on this, because this would, in my opinion, be a little bit more mathematically precise, however, I don't think that it would be good for computational purpose. What do you all think of this?


At some point we will want to use them, if only to extend capabilities of
`DrinfeldModule`. At the moment, I feel like we should stick to basics (i.e.
finite Drinfeld modules over `\Fq[X]`) and finish this first version (I still
have the documentation to write, and probably the `Hom` class to write from
scratch). Those capabilities, even if basics, will surely come out as very
helpful when extending from finite fields to, say, extensions of `\Fq(X)`.

I realize that I forgot to reply to your comment [comment:43]. My bad, David.
To answer: no, I was not planning to open a ticket for the category. As of now,
the discussion is centralized and already attracted some people.


---
Replying to [tscrim](#comment%3A57):
> 
> This is a picture of my understanding (using `t = \tau`) of the mathematics.
> 
> The main object/category we are considering is
> 
> ```
> DM <=  Hom(Fq[x], L{t})
> ```
> where `DM` is the set of Drinfeld modules, `<=` is subset`, and `L{t}` is the ring of Ore polynomials.
> Then taking the `Hom(f,g)` of two elements/objects in `DM`, we get a subset `S` of `L{t}` that has the structure of an `End(g)`-module and `End(g)` is the centralizer of `g(X)` in `L{t}`.


Your understanding is correct.

> Now we don't really know that much about what is in `DM` or `S`. So it doesn't make so much sense to non-generic implementations for them.


I am not sure to understand what you mean by 'non-generic implementation'.
  
> No matter if you think of `DM` as a category or as a `Parent`, the set `S` would still be a `Hom` subclass with a natural coercion to `L{t}` since `S <= L{t}` (as `End(g)`-modules).


Why would `S` be a `Hom` subclass? It looks as being just a subset of `L{t}`
(which itself can be seen as a `Hom(Fqbar, Fqbar)` for the structure of
`Fq`-vector space).



---

archive/issue_comments_672042.json:
```json
{
    "body": "<a id='comment:59'></a>\nAbout the directory: I would be okay with `sage.modules.drinfeld_modules`. After some thought, this would be the most natural choice for Drinfeld modules. If we really want to think far ahead, the directory name could be `sage.modules.t_modules.drinfeld_modules`. In short, a *t-module* is the higher dimensional theory of Drinfeld modules (just like what abelian variety is for elliptic curves). If someone in the future wants such object in [SageMath](SageMath), the name would already be there without the need of renaming and deprecating any imports. But, again I guess that I'm thinking very far ahead and I don't know how likely someone will implement this...\n\nEDIT: a *t-module* is sometime called an *Anderson t-motive* in the litterature.",
    "created_at": "2022-06-22T14:43:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672042",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:59'></a>
About the directory: I would be okay with `sage.modules.drinfeld_modules`. After some thought, this would be the most natural choice for Drinfeld modules. If we really want to think far ahead, the directory name could be `sage.modules.t_modules.drinfeld_modules`. In short, a *t-module* is the higher dimensional theory of Drinfeld modules (just like what abelian variety is for elliptic curves). If someone in the future wants such object in [SageMath](SageMath), the name would already be there without the need of renaming and deprecating any imports. But, again I guess that I'm thinking very far ahead and I don't know how likely someone will implement this...

EDIT: a *t-module* is sometime called an *Anderson t-motive* in the litterature.



---

archive/issue_comments_672043.json:
```json
{
    "body": "<a id='comment:60'></a>\nReplying to [gh-DavidAyotte](#comment%3A59):\n> About the directory: I would be okay with `sage.modules.drinfeld_modules`. After some thought, this would be the most natural choice for Drinfeld modules. If we really want to think far ahead, the directory name could be `sage.modules.t_modules.drinfeld_modules`. In short, a *t-module* is the higher dimensional theory of Drinfeld modules (just like what abelian variety is for elliptic curves). If someone in the future wants such object in [SageMath](SageMath), the name would already be there without the need of renaming and deprecating any imports. But, again I guess that I'm thinking very far ahead and I don't know how likely someone will implement this...\n> \n> EDIT: a *t-module* is sometime called an *Anderson t-motive* in the litterature.\n\n\nI fear that putting it in `sage.modules.t_modules.drinfeld_modules` could be very premature. That being said, I do not have a strong opinion on where the class should be defined.",
    "created_at": "2022-06-22T17:36:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672043",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:60'></a>
Replying to [gh-DavidAyotte](#comment%3A59):
> About the directory: I would be okay with `sage.modules.drinfeld_modules`. After some thought, this would be the most natural choice for Drinfeld modules. If we really want to think far ahead, the directory name could be `sage.modules.t_modules.drinfeld_modules`. In short, a *t-module* is the higher dimensional theory of Drinfeld modules (just like what abelian variety is for elliptic curves). If someone in the future wants such object in [SageMath](SageMath), the name would already be there without the need of renaming and deprecating any imports. But, again I guess that I'm thinking very far ahead and I don't know how likely someone will implement this...
> 
> EDIT: a *t-module* is sometime called an *Anderson t-motive* in the litterature.


I fear that putting it in `sage.modules.t_modules.drinfeld_modules` could be very premature. That being said, I do not have a strong opinion on where the class should be defined.



---

archive/issue_comments_672044.json:
```json
{
    "body": "<a id='comment:61'></a>\n> I fear that putting it in sage.modules.t_modules.drinfeld_modules could be very premature. That being said, I do not have a strong opinion on where the class should be defined.\n\n\nI have the same feeling, let's forget that and see how this implementation first evolves in the future.",
    "created_at": "2022-06-22T17:40:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672044",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:61'></a>
> I fear that putting it in sage.modules.t_modules.drinfeld_modules could be very premature. That being said, I do not have a strong opinion on where the class should be defined.


I have the same feeling, let's forget that and see how this implementation first evolves in the future.



---

archive/issue_comments_672045.json:
```json
{
    "body": "<a id='comment:62'></a>\nI implemented `Hom` stuff for our Drinfeld modules. Reminder, this is done on\nbranch `u/antoine-leudiere/finite_drinfeld_modules-category_object`. I think we\ncan now merge it to the main branch.\n\n**Warning.** *I really do not know what I'm doing*. It is highly possible that I made something not the way it should be done. If so, please correct me, and explain how I should proceed.\n\nBriefly, I created the class `DrinfeldModuleHomset`, that inherits\n`sage.categories.homset`. To have the `Hom(phi, psi)` syntax (somehow) working,\nI defined methods `Homsets` and `Endsets` for the category `DrinfeldModules`\n(they both return the category `Homsets`) \u2014 really no idea if this is sound\nor not. I also defined methods `Hom` and `End` for `DrinfeldModule`.\n\nFinally, I did some clean up on the code, which is now less ugly.\n\nSee the `git log` for more information.",
    "created_at": "2022-06-22T17:48:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672045",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:62'></a>
I implemented `Hom` stuff for our Drinfeld modules. Reminder, this is done on
branch `u/antoine-leudiere/finite_drinfeld_modules-category_object`. I think we
can now merge it to the main branch.

**Warning.** *I really do not know what I'm doing*. It is highly possible that I made something not the way it should be done. If so, please correct me, and explain how I should proceed.

Briefly, I created the class `DrinfeldModuleHomset`, that inherits
`sage.categories.homset`. To have the `Hom(phi, psi)` syntax (somehow) working,
I defined methods `Homsets` and `Endsets` for the category `DrinfeldModules`
(they both return the category `Homsets`) — really no idea if this is sound
or not. I also defined methods `Hom` and `End` for `DrinfeldModule`.

Finally, I did some clean up on the code, which is now less ugly.

See the `git log` for more information.



---

archive/issue_comments_672046.json:
```json
{
    "body": "<a id='comment:63'></a>\n> **Warning.** I really do not know what I'm doing. It is highly possible that I made something not the way it should be done. If so, please correct me, explain explain how I should proceed.\n\n\nI think that you should start pushing some code to this ticket. Remember, not everything is perfect the first time and a lot of learning is done through trial and errors.",
    "created_at": "2022-06-22T17:57:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672046",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:63'></a>
> **Warning.** I really do not know what I'm doing. It is highly possible that I made something not the way it should be done. If so, please correct me, explain explain how I should proceed.


I think that you should start pushing some code to this ticket. Remember, not everything is perfect the first time and a lot of learning is done through trial and errors.



---

archive/issue_comments_672047.json:
```json
{
    "body": "<a id='comment:64'></a>\nReplying to [gh-DavidAyotte](#comment%3A63):\n> > **Warning.** I really do not know what I'm doing. It is highly possible that I made something not the way it should be done. If so, please correct me, explain explain how I should proceed.\n\n> \n> I think that you should start pushing some code to this ticket. Remember, not everything is perfect the first time and a lot of learning is done through trial and errors.\n\n\nHahaha thank you David. Fair enough. I'll do it tomorrow or the day after tomorrow if nobody objects to it.",
    "created_at": "2022-06-22T18:05:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672047",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:64'></a>
Replying to [gh-DavidAyotte](#comment%3A63):
> > **Warning.** I really do not know what I'm doing. It is highly possible that I made something not the way it should be done. If so, please correct me, explain explain how I should proceed.

> 
> I think that you should start pushing some code to this ticket. Remember, not everything is perfect the first time and a lot of learning is done through trial and errors.


Hahaha thank you David. Fair enough. I'll do it tomorrow or the day after tomorrow if nobody objects to it.



---

archive/issue_comments_672048.json:
```json
{
    "body": "<a id='comment:65'></a>\nMy preferences at the moment:\n- I still have a clear preference for `CategoryObject` because I think that it is more meaningful mathematically (and I do not see a clear benefit with using `Parent`) but I'm also fine with using `Parent` and I will not complain if we retain this solution at the end.\n- For the location, I like `sage.modules.drinfeld_modules.drinfeld_modules`, i.e. creating a directory `sage/modules/drinfeld_modules` and put a file `drinfeld_modules.py` in it. (I think it was not proposed so far.)",
    "created_at": "2022-06-22T18:53:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672048",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:65'></a>
My preferences at the moment:
- I still have a clear preference for `CategoryObject` because I think that it is more meaningful mathematically (and I do not see a clear benefit with using `Parent`) but I'm also fine with using `Parent` and I will not complain if we retain this solution at the end.
- For the location, I like `sage.modules.drinfeld_modules.drinfeld_modules`, i.e. creating a directory `sage/modules/drinfeld_modules` and put a file `drinfeld_modules.py` in it. (I think it was not proposed so far.)



---

archive/issue_comments_672049.json:
```json
{
    "body": "<a id='comment:66'></a>\nReplying to [caruso](#comment%3A65):\n> My preferences at the moment:\n> - I still have a clear preference for `CategoryObject` because I think that it is more meaningful mathematically (and I do not see a clear benefit with using `Parent`) but I'm also fine with using `Parent` and I will not complain if we retain this solution at the end.\n> - For the location, I like `sage.modules.drinfeld_modules.drinfeld_modules`, i.e. creating a directory `sage/modules/drinfeld_modules` and put a file `drinfeld_modules.py` in it. (I think it was not proposed so far.)\n\n\nNoted.",
    "created_at": "2022-06-23T08:34:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672049",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:66'></a>
Replying to [caruso](#comment%3A65):
> My preferences at the moment:
> - I still have a clear preference for `CategoryObject` because I think that it is more meaningful mathematically (and I do not see a clear benefit with using `Parent`) but I'm also fine with using `Parent` and I will not complain if we retain this solution at the end.
> - For the location, I like `sage.modules.drinfeld_modules.drinfeld_modules`, i.e. creating a directory `sage/modules/drinfeld_modules` and put a file `drinfeld_modules.py` in it. (I think it was not proposed so far.)


Noted.



---

archive/issue_comments_672050.json:
```json
{
    "body": "**Changing branch** from \"[u/antoine-leudiere/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/antoine-leudiere/finite_drinfeld_modules)\" to \"[u/caruso/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/caruso/finite_drinfeld_modules)\".",
    "created_at": "2022-06-23T10:00:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672050",
    "user": "https://github.com/xcaruso"
}
```


**Changing branch** from "[u/antoine-leudiere/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/antoine-leudiere/finite_drinfeld_modules)" to "[u/caruso/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/caruso/finite_drinfeld_modules)".



---

archive/issue_comments_672051.json:
```json
{
    "body": "<a id='comment:68'></a>\nI've splitted the code into several files and add a method `__classcall_private__` for distinguishing between general Drinfeld modules and finite ones.\n\nSo far, all the files are in `sage/rings/functions_field/drinfeld_modules` but this can be changed easily.\n\nFinally, for hom sets, I think we need to create a class for morphisms as well. I'll try to do it next week if you haven't done it before.",
    "created_at": "2022-06-23T10:06:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672051",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:68'></a>
I've splitted the code into several files and add a method `__classcall_private__` for distinguishing between general Drinfeld modules and finite ones.

So far, all the files are in `sage/rings/functions_field/drinfeld_modules` but this can be changed easily.

Finally, for hom sets, I think we need to create a class for morphisms as well. I'll try to do it next week if you haven't done it before.



---

archive/issue_comments_672052.json:
```json
{
    "body": "**Changing branch** from \"[u/caruso/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/caruso/finite_drinfeld_modules)\" to \"[u/antoine-leudiere/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/antoine-leudiere/finite_drinfeld_modules)\".",
    "created_at": "2022-06-23T10:06:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672052",
    "user": "https://github.com/xcaruso"
}
```


**Changing branch** from "[u/caruso/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/caruso/finite_drinfeld_modules)" to "[u/antoine-leudiere/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/antoine-leudiere/finite_drinfeld_modules)".



---

archive/issue_comments_672053.json:
```json
{
    "body": "**Changing commit** from \"[9bcadf21f86e8e4e6fda8e151ecb33db7acd6552](https://github.com/sagemath/sagetrac-mirror/commit/9bcadf21f86e8e4e6fda8e151ecb33db7acd6552)\" to \"[b26c8138ca4cf610880efb25e19ac0037825e9c8](https://github.com/sagemath/sagetrac-mirror/commit/b26c8138ca4cf610880efb25e19ac0037825e9c8)\".",
    "created_at": "2022-06-23T10:07:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672053",
    "user": "https://github.com/xcaruso"
}
```


**Changing commit** from "[9bcadf21f86e8e4e6fda8e151ecb33db7acd6552](https://github.com/sagemath/sagetrac-mirror/commit/9bcadf21f86e8e4e6fda8e151ecb33db7acd6552)" to "[b26c8138ca4cf610880efb25e19ac0037825e9c8](https://github.com/sagemath/sagetrac-mirror/commit/b26c8138ca4cf610880efb25e19ac0037825e9c8)".



---

archive/issue_comments_672054.json:
```json
{
    "body": "**Changing branch** from \"[u/antoine-leudiere/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/antoine-leudiere/finite_drinfeld_modules)\" to \"[u/caruso/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/caruso/finite_drinfeld_modules)\".",
    "created_at": "2022-06-23T10:07:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672054",
    "user": "https://github.com/xcaruso"
}
```


**Changing branch** from "[u/antoine-leudiere/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/antoine-leudiere/finite_drinfeld_modules)" to "[u/caruso/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/caruso/finite_drinfeld_modules)".



---

archive/issue_comments_672055.json:
```json
{
    "body": "**Changing branch** from \"[u/caruso/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/caruso/finite_drinfeld_modules)\" to \"[public/drinfeld_module](https://github.com/sagemath/sagetrac-mirror/tree/public/drinfeld_module)\".",
    "created_at": "2022-06-23T11:44:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672055",
    "user": "https://github.com/antoine-leudiere"
}
```


**Changing branch** from "[u/caruso/finite_drinfeld_modules](https://github.com/sagemath/sagetrac-mirror/tree/u/caruso/finite_drinfeld_modules)" to "[public/drinfeld_module](https://github.com/sagemath/sagetrac-mirror/tree/public/drinfeld_module)".



---

archive/issue_comments_672056.json:
```json
{
    "body": "<a id='comment:70'></a>\n**Last 10 new commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/94bad90cd43c800227f5cbdf62595ee67a02c61c\">94bad90</a></td><td><code>characteristic polynomial of Frobenius in all rank</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3b47737b087305806a6d07d5f2da595f0183fef0\">3b47737</a></td><td><code>Change FiniteDrinfeldModule to DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/45be70180e9cc59760943399dd9758b81ac47217\">45be701</a></td><td><code>Clean DrinfeldModules category</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0ccdf26500825e2b778258831466f16939ac74dd\">0ccdf26</a></td><td><code>Clean DrinfeldModule constructor</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/92b9e68c04a9f39180236428099bd4a9d22b84b7\">92b9e68</a></td><td><code>Change polring to functions_ring in DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2b01218c051d92d84f0b85b25e73c479b2e8ec7d\">2b01218</a></td><td><code>Create morphisms for DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b823a5721884dd04c0d50557bb2d31b30af47d6d\">b823a57</a></td><td><code>Remove is_morphism, etc, methods of DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/61e931234dc8bd543cd67ed0f02672a6ae2ed0bc\">61e9312</a></td><td><code>Merge branch 'u/antoine-leudiere/finite_drinfeld_modules-category_object' of git://trac.sagemath.org/sage into drinfeld_modules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c01845237b3ea2b1f9a07edc3df2bad283a75b75\">c018452</a></td><td><code>refactor code + classcall_private</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b26c8138ca4cf610880efb25e19ac0037825e9c8\">b26c813</a></td><td><code>with all files</code></td></tr></table>\n",
    "created_at": "2022-06-23T11:44:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672056",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:70'></a>
**Last 10 new commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/94bad90cd43c800227f5cbdf62595ee67a02c61c">94bad90</a></td><td><code>characteristic polynomial of Frobenius in all rank</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3b47737b087305806a6d07d5f2da595f0183fef0">3b47737</a></td><td><code>Change FiniteDrinfeldModule to DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/45be70180e9cc59760943399dd9758b81ac47217">45be701</a></td><td><code>Clean DrinfeldModules category</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0ccdf26500825e2b778258831466f16939ac74dd">0ccdf26</a></td><td><code>Clean DrinfeldModule constructor</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/92b9e68c04a9f39180236428099bd4a9d22b84b7">92b9e68</a></td><td><code>Change polring to functions_ring in DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2b01218c051d92d84f0b85b25e73c479b2e8ec7d">2b01218</a></td><td><code>Create morphisms for DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b823a5721884dd04c0d50557bb2d31b30af47d6d">b823a57</a></td><td><code>Remove is_morphism, etc, methods of DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/61e931234dc8bd543cd67ed0f02672a6ae2ed0bc">61e9312</a></td><td><code>Merge branch 'u/antoine-leudiere/finite_drinfeld_modules-category_object' of git://trac.sagemath.org/sage into drinfeld_modules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c01845237b3ea2b1f9a07edc3df2bad283a75b75">c018452</a></td><td><code>refactor code + classcall_private</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b26c8138ca4cf610880efb25e19ac0037825e9c8">b26c813</a></td><td><code>with all files</code></td></tr></table>




---

archive/issue_comments_672057.json:
```json
{
    "body": "<a id='comment:71'></a>\nThank you Xavier for your work.\n\nReplying to [caruso](#comment%3A68):\n> Finally, for hom sets, I think to create a class for morphisms as well. I'll try to do it next week if you haven't done it before.\n\n\nI would very much like to do it at the beginning of next week (I am in doctoral school training today and tomorrow).\n\nBesides this, we should soon after focus on polishing and doctesting the code, so as to submit a first version for review.",
    "created_at": "2022-06-23T11:57:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672057",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:71'></a>
Thank you Xavier for your work.

Replying to [caruso](#comment%3A68):
> Finally, for hom sets, I think to create a class for morphisms as well. I'll try to do it next week if you haven't done it before.


I would very much like to do it at the beginning of next week (I am in doctoral school training today and tomorrow).

Besides this, we should soon after focus on polishing and doctesting the code, so as to submit a first version for review.



---

archive/issue_comments_672058.json:
```json
{
    "body": "<a id='comment:72'></a>\nReplying to [antoine-leudiere](#comment%3A71):\n> I would very much like to do it at the beginning of next week (I am in doctoral school training today and tomorrow).\n\n\nGreat!",
    "created_at": "2022-06-23T12:59:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672058",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:72'></a>
Replying to [antoine-leudiere](#comment%3A71):
> I would very much like to do it at the beginning of next week (I am in doctoral school training today and tomorrow).


Great!



---

archive/issue_comments_672059.json:
```json
{
    "body": "<a id='comment:73'></a>\nRunning into some trouble. It seems that instantiating `Morphism(phi, psi)` requies `phi`\nand `psi` to be parents.\n\n```python\nsage: from sage.categories.morphism import Morphism\nsage: Fq = GF(3^2)\nsage: FqX.<X> = Fq[]\nsage: L = Fq.extension(6)\nsage: phi = DrinfeldModule(FqX, [L.gen(), 1, 1])\nsage: Morphism(phi, phi)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n~/pro/code/finite_drinfeld_modules-sage/source/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/all_cmdline.py in <module>\n----> 1 Morphism(phi, phi)\n\n~/pro/code/finite_drinfeld_modules-sage/source/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/categories/map.pyx in sage.categories.map.Map.__init__ (build/cythonized/sage/categories/map.c:3942)()\n    130         C = parent.codomain()\n    131         self._category_for = parent.homset_category()\n--> 132         self._codomain = C\n    133         self.domain    = ConstantFunction(D)\n    134         self.codomain  = ConstantFunction(C)\n\nTypeError: Cannot convert FiniteDrinfeldModule to sage.structure.parent.Parent\n```\n\nThis is not surprising. `Morphism` inherits `Map`. The first parameter of the\n`Map` constructor must be a parent. Is this a reason to use `Parent` instead of\n`CategoryObject`?",
    "created_at": "2022-06-23T19:09:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672059",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:73'></a>
Running into some trouble. It seems that instantiating `Morphism(phi, psi)` requies `phi`
and `psi` to be parents.

```python
sage: from sage.categories.morphism import Morphism
sage: Fq = GF(3^2)
sage: FqX.<X> = Fq[]
sage: L = Fq.extension(6)
sage: phi = DrinfeldModule(FqX, [L.gen(), 1, 1])
sage: Morphism(phi, phi)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
~/pro/code/finite_drinfeld_modules-sage/source/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/all_cmdline.py in <module>
----> 1 Morphism(phi, phi)

~/pro/code/finite_drinfeld_modules-sage/source/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/categories/map.pyx in sage.categories.map.Map.__init__ (build/cythonized/sage/categories/map.c:3942)()
    130         C = parent.codomain()
    131         self._category_for = parent.homset_category()
--> 132         self._codomain = C
    133         self.domain    = ConstantFunction(D)
    134         self.codomain  = ConstantFunction(C)

TypeError: Cannot convert FiniteDrinfeldModule to sage.structure.parent.Parent
```

This is not surprising. `Morphism` inherits `Map`. The first parameter of the
`Map` constructor must be a parent. Is this a reason to use `Parent` instead of
`CategoryObject`?



---

archive/issue_comments_672060.json:
```json
{
    "body": "**Changing commit** from \"[b26c8138ca4cf610880efb25e19ac0037825e9c8](https://github.com/sagemath/sagetrac-mirror/commit/b26c8138ca4cf610880efb25e19ac0037825e9c8)\" to \"[a9848aec0fa50d13cfa47adb3729a22d7f543406](https://github.com/sagemath/sagetrac-mirror/commit/a9848aec0fa50d13cfa47adb3729a22d7f543406)\".",
    "created_at": "2022-06-23T19:59:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672060",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[b26c8138ca4cf610880efb25e19ac0037825e9c8](https://github.com/sagemath/sagetrac-mirror/commit/b26c8138ca4cf610880efb25e19ac0037825e9c8)" to "[a9848aec0fa50d13cfa47adb3729a22d7f543406](https://github.com/sagemath/sagetrac-mirror/commit/a9848aec0fa50d13cfa47adb3729a22d7f543406)".



---

archive/issue_comments_672061.json:
```json
{
    "body": "<a id='comment:74'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/22e4f83972f3e1f37c5f934a2cb851307834ced0\">22e4f83</a></td><td><code>Rename morphism.py to homset.py</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a9848aec0fa50d13cfa47adb3729a22d7f543406\">a9848ae</a></td><td><code>Fix DrinfeldModuleHomset import in DrinfeldModule</code></td></tr></table>\n",
    "created_at": "2022-06-23T19:59:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672061",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:74'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/22e4f83972f3e1f37c5f934a2cb851307834ced0">22e4f83</a></td><td><code>Rename morphism.py to homset.py</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a9848aec0fa50d13cfa47adb3729a22d7f543406">a9848ae</a></td><td><code>Fix DrinfeldModuleHomset import in DrinfeldModule</code></td></tr></table>




---

archive/issue_comments_672062.json:
```json
{
    "body": "<a id='comment:75'></a>\nHello Antoine, you probably already have plenty other stuff to do, but what do you think about implementing a `coefficient` method? This is what I have in mind:\n\n```python\ndef coefficient(n, a=None):\n    \"\"\"\n    Return the `n`-th coefficient of the `\\tau`-polynomial `\\phi_a(\\tau)`.\n\n    INPUT:\n\n    - ``n`` (Integer)\n    - ``a`` (polynomial, default: ``None``) -- if ``a`` is set to ``None``, this method\n      returns the `n`-th coefficient of `\\phi_T(\\tau)`\n    \"\"\"\n```\n(the docstring I wrote is not definitive, feel free to change it however you prefer)\n\n\nI believe that this method could replace your `g` and `delta` methods.\n \nSimilarly, you could have a `coefficients(a=None)` (observe the plural form) which would return a *list* of all the coefficients. If you don't have time for this, I can jump in and implement it, I'll be glad to do it.\n\n\nAlso, I created a stream on the official [SageMath](SageMath) Zulip platform: [drinfeld modules](https://sagemath.zulipchat.com/#narrow/stream/328988-drinfeld-modules). For people interested, I invite you to join it, it might faciliate communications!",
    "created_at": "2022-06-23T20:37:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672062",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:75'></a>
Hello Antoine, you probably already have plenty other stuff to do, but what do you think about implementing a `coefficient` method? This is what I have in mind:

```python
def coefficient(n, a=None):
    """
    Return the `n`-th coefficient of the `\tau`-polynomial `\phi_a(\tau)`.

    INPUT:

    - ``n`` (Integer)
    - ``a`` (polynomial, default: ``None``) -- if ``a`` is set to ``None``, this method
      returns the `n`-th coefficient of `\phi_T(\tau)`
    """
```
(the docstring I wrote is not definitive, feel free to change it however you prefer)


I believe that this method could replace your `g` and `delta` methods.
 
Similarly, you could have a `coefficients(a=None)` (observe the plural form) which would return a *list* of all the coefficients. If you don't have time for this, I can jump in and implement it, I'll be glad to do it.


Also, I created a stream on the official [SageMath](SageMath) Zulip platform: [drinfeld modules](https://sagemath.zulipchat.com/#narrow/stream/328988-drinfeld-modules). For people interested, I invite you to join it, it might faciliate communications!



---

archive/issue_comments_672063.json:
```json
{
    "body": "<a id='comment:76'></a>\nReplying to [antoine-leudiere](#comment%3A58):\n> \n> ---\n> **`_repr_` output**\n> \n> I do not have a strong opinion on this. I always prefer to have all the\n> information, so I would encline to use David's suggestion.\n\n\nThis is generally a bad philosophy. See large matrices, graphs, and other things that could require significant amount of information. The user can access some of the related attributes they want to distinguish between objects.\n\n> ---\n> **Directory in `sage/`**\n> \n> That being said, L-functions have their own top directory (which can be the\n> precedent that Travis rightfully fears).\n\n\nThis is also probably original code to Sage. `:)`\n\n> ---\n> **`Parent` vs `CategoryObject` vs something else**\n> \n> Being a novice when it comes to [SageMath](SageMath) development, some of your\n> considerations are a bit far of reach for me at the moment. In particular, I do\n> not have a strong opinion on `Parent` vs `CategoryObject`, and I won't help\n> much with Travis' interrogation:\n> \n> > I am not looking for something with the API or that it is closer to how you mathematically think about it, but the underlying code.\n\n> \n> One thing is sure, as the main maintainer and author of the code, I want to\n> avoid tricks and workarounds as much as possible. I am not (nor will I ever be)\n> working full time on the code,\n\n\nI don't think anyone here is either. `;)`\n\n> and I need the codebase to be as straightforward as possible to maintain and enrich it.\n\n\nYou are trying to make object of type `X` also be the same as (a fundamentally incompatible) type `Y`. This does not work really well in programming. This is basically what duck-typing in Python in for, and it is a very standard technique in the language. So something has to give.\n\n> It seems to me however that `CategoryObject` (or `Parent`) might be better than\n> inheriting `RingHomomorphism`.\n\n\nI am not suggesting that Drinfeld module should inherit from `Parent` (as it has no elements AFAICS). It is the *set* of all Drinfeld modules that I am advocating for to be a subclass of `Parent` rather than a subclass of `Category` as it has a natural set of elements.\n\n> As Travis pointed out, it plugs naturally with\n> `Hom` and `Category`. Creating the morphism, keeping it as an attribute, and\n> overloading `__call__` looks reasonable.\n\n\nI should point out that Sage also has a category for elements:\n\n```\nsage: 2.category()\nCategory of elements of Integer Ring\nsage: type(_)\n<class 'sage.categories.category_types.Elements_with_category'>\n```\nSo we might be able to get the best of both worlds for this if you want to think of the Drinfeld modules as objects in a category. I actually had thought you had tried `Hom` on a pair of elements and got errors. In fact, this works:\n\n```\nsage: Hom(2, 3)\nSet of Morphisms from 2 to 3 in Category of elements of Integer Ring\n```\nHence, nothing outside of the normal idioms in Sage should be needed, unlike what I thought in my previous post.\nBased on this, I am actually going to be a bit more forceful about having Drinfeld modules be ring homomorphisms rather than a subclass of `CategoryObject` as the infrastructure to have them be objects in a category is already handled by Sage.\n\n@caruso Thinking a little bit more about advantages, beyond the technical one of having a specific element class associated to `DM` (in particular, you won't have to write code that works if I come along with my own implementation of Drinfeld modules using a different programming model), I have some others:\n\nYou can implement functors (say, by changing the finite field or the Ore polynomial ring) as morphisms from `DM` to `DM'`, which you could naturally compose as morphisms. While functors in Sage can do this, it would not be possible to have this set as a coercion. You actually lose all possibility of using the coercion framework by having `DM` be a category. This also means you can do pushouts:\n\n```\nsage: R.<x> = QQ[]\nsage: S.<x,y> = ZZ[]\nsage: R.has_coerce_map_from(S)\nFalse\nsage: S.has_coerce_map_from(R)\nFalse\nsage: coercion_model.common_parent(R, S)\nMultivariate Polynomial Ring in x, y over Rational Field\n```\n\nAnyways, other than this message strongly recommending using `Parent` for `DM` instead of a category, I will stop my advocating now as I am not doing the implementation. If you still disagree that it is the right path forward, then I will defer to your judgement.\n\n> ---\n> Replying to [tscrim](#comment%3A57):\n> > Now we don't really know that much about what is in `DM` or `S`. So it doesn't make so much sense to non-generic implementations for them.\n\n> \n> I am not sure to understand what you mean by 'non-generic implementation'.\n\n\nThere are generic implementation of homsets and (sub)sets in Sage.\n\n```\nsage: Hom(ZZ, Partitions())\nSet of Morphisms from Integer Ring to Partitions in Category of infinite enumerated sets\nsage: type(_)\n<class 'sage.categories.homset.Homset_with_category'>\n```\n\n> > No matter if you think of `DM` as a category or as a `Parent`, the set `S` would still be a `Hom` subclass with a natural coercion to `L{t}` since `S <= L{t}` (as `End(g)`-modules).\n\n> \n> Why would `S` be a `Hom` subclass? It looks as being just a subset of `L{t}`\n> (which itself can be seen as a `Hom(Fqbar, Fqbar)` for the structure of\n> `Fq`-vector space).\n\n\nBecause it is a set of Drinfeld module morphisms from `f` to `g`. It comes with some default parameters that you would want, more so than `Parent` that you would use as a base class to model `S`.\n\n---\n\nFor[comment:75](#comment%3A75), that isn't right. You should be using `Hom`. `Morphism` is the base class for a morphism, the element in a homset. (See also `End`.) If you want a particular morphism, you need to create the homset (a parent) of `phi -> phi` and then pass the necessary data to construct the particular morphism you want.",
    "created_at": "2022-06-24T07:00:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672063",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:76'></a>
Replying to [antoine-leudiere](#comment%3A58):
> 
> ---
> **`_repr_` output**
> 
> I do not have a strong opinion on this. I always prefer to have all the
> information, so I would encline to use David's suggestion.


This is generally a bad philosophy. See large matrices, graphs, and other things that could require significant amount of information. The user can access some of the related attributes they want to distinguish between objects.

> ---
> **Directory in `sage/`**
> 
> That being said, L-functions have their own top directory (which can be the
> precedent that Travis rightfully fears).


This is also probably original code to Sage. `:)`

> ---
> **`Parent` vs `CategoryObject` vs something else**
> 
> Being a novice when it comes to [SageMath](SageMath) development, some of your
> considerations are a bit far of reach for me at the moment. In particular, I do
> not have a strong opinion on `Parent` vs `CategoryObject`, and I won't help
> much with Travis' interrogation:
> 
> > I am not looking for something with the API or that it is closer to how you mathematically think about it, but the underlying code.

> 
> One thing is sure, as the main maintainer and author of the code, I want to
> avoid tricks and workarounds as much as possible. I am not (nor will I ever be)
> working full time on the code,


I don't think anyone here is either. `;)`

> and I need the codebase to be as straightforward as possible to maintain and enrich it.


You are trying to make object of type `X` also be the same as (a fundamentally incompatible) type `Y`. This does not work really well in programming. This is basically what duck-typing in Python in for, and it is a very standard technique in the language. So something has to give.

> It seems to me however that `CategoryObject` (or `Parent`) might be better than
> inheriting `RingHomomorphism`.


I am not suggesting that Drinfeld module should inherit from `Parent` (as it has no elements AFAICS). It is the *set* of all Drinfeld modules that I am advocating for to be a subclass of `Parent` rather than a subclass of `Category` as it has a natural set of elements.

> As Travis pointed out, it plugs naturally with
> `Hom` and `Category`. Creating the morphism, keeping it as an attribute, and
> overloading `__call__` looks reasonable.


I should point out that Sage also has a category for elements:

```
sage: 2.category()
Category of elements of Integer Ring
sage: type(_)
<class 'sage.categories.category_types.Elements_with_category'>
```
So we might be able to get the best of both worlds for this if you want to think of the Drinfeld modules as objects in a category. I actually had thought you had tried `Hom` on a pair of elements and got errors. In fact, this works:

```
sage: Hom(2, 3)
Set of Morphisms from 2 to 3 in Category of elements of Integer Ring
```
Hence, nothing outside of the normal idioms in Sage should be needed, unlike what I thought in my previous post.
Based on this, I am actually going to be a bit more forceful about having Drinfeld modules be ring homomorphisms rather than a subclass of `CategoryObject` as the infrastructure to have them be objects in a category is already handled by Sage.

@caruso Thinking a little bit more about advantages, beyond the technical one of having a specific element class associated to `DM` (in particular, you won't have to write code that works if I come along with my own implementation of Drinfeld modules using a different programming model), I have some others:

You can implement functors (say, by changing the finite field or the Ore polynomial ring) as morphisms from `DM` to `DM'`, which you could naturally compose as morphisms. While functors in Sage can do this, it would not be possible to have this set as a coercion. You actually lose all possibility of using the coercion framework by having `DM` be a category. This also means you can do pushouts:

```
sage: R.<x> = QQ[]
sage: S.<x,y> = ZZ[]
sage: R.has_coerce_map_from(S)
False
sage: S.has_coerce_map_from(R)
False
sage: coercion_model.common_parent(R, S)
Multivariate Polynomial Ring in x, y over Rational Field
```

Anyways, other than this message strongly recommending using `Parent` for `DM` instead of a category, I will stop my advocating now as I am not doing the implementation. If you still disagree that it is the right path forward, then I will defer to your judgement.

> ---
> Replying to [tscrim](#comment%3A57):
> > Now we don't really know that much about what is in `DM` or `S`. So it doesn't make so much sense to non-generic implementations for them.

> 
> I am not sure to understand what you mean by 'non-generic implementation'.


There are generic implementation of homsets and (sub)sets in Sage.

```
sage: Hom(ZZ, Partitions())
Set of Morphisms from Integer Ring to Partitions in Category of infinite enumerated sets
sage: type(_)
<class 'sage.categories.homset.Homset_with_category'>
```

> > No matter if you think of `DM` as a category or as a `Parent`, the set `S` would still be a `Hom` subclass with a natural coercion to `L{t}` since `S <= L{t}` (as `End(g)`-modules).

> 
> Why would `S` be a `Hom` subclass? It looks as being just a subset of `L{t}`
> (which itself can be seen as a `Hom(Fqbar, Fqbar)` for the structure of
> `Fq`-vector space).


Because it is a set of Drinfeld module morphisms from `f` to `g`. It comes with some default parameters that you would want, more so than `Parent` that you would use as a base class to model `S`.

---

For[comment:75](#comment%3A75), that isn't right. You should be using `Hom`. `Morphism` is the base class for a morphism, the element in a homset. (See also `End`.) If you want a particular morphism, you need to create the homset (a parent) of `phi -> phi` and then pass the necessary data to construct the particular morphism you want.



---

archive/issue_comments_672064.json:
```json
{
    "body": "<a id='comment:77'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1bbad0c8d10a11bfcf006cd61bd64a29dee3aa58\">1bbad0c</a></td><td><code>Create DrinfeldModuleMorphism</code></td></tr></table>\n",
    "created_at": "2022-07-04T14:40:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672064",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:77'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1bbad0c8d10a11bfcf006cd61bd64a29dee3aa58">1bbad0c</a></td><td><code>Create DrinfeldModuleMorphism</code></td></tr></table>




---

archive/issue_comments_672065.json:
```json
{
    "body": "**Changing commit** from \"[a9848aec0fa50d13cfa47adb3729a22d7f543406](https://github.com/sagemath/sagetrac-mirror/commit/a9848aec0fa50d13cfa47adb3729a22d7f543406)\" to \"[1bbad0c8d10a11bfcf006cd61bd64a29dee3aa58](https://github.com/sagemath/sagetrac-mirror/commit/1bbad0c8d10a11bfcf006cd61bd64a29dee3aa58)\".",
    "created_at": "2022-07-04T14:40:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672065",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[a9848aec0fa50d13cfa47adb3729a22d7f543406](https://github.com/sagemath/sagetrac-mirror/commit/a9848aec0fa50d13cfa47adb3729a22d7f543406)" to "[1bbad0c8d10a11bfcf006cd61bd64a29dee3aa58](https://github.com/sagemath/sagetrac-mirror/commit/1bbad0c8d10a11bfcf006cd61bd64a29dee3aa58)".



---

archive/issue_comments_672066.json:
```json
{
    "body": "**Changing commit** from \"[1bbad0c8d10a11bfcf006cd61bd64a29dee3aa58](https://github.com/sagemath/sagetrac-mirror/commit/1bbad0c8d10a11bfcf006cd61bd64a29dee3aa58)\" to \"[a29334556c55b6ed88f433f61004d31f2fc09188](https://github.com/sagemath/sagetrac-mirror/commit/a29334556c55b6ed88f433f61004d31f2fc09188)\".",
    "created_at": "2022-08-08T22:00:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672066",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[1bbad0c8d10a11bfcf006cd61bd64a29dee3aa58](https://github.com/sagemath/sagetrac-mirror/commit/1bbad0c8d10a11bfcf006cd61bd64a29dee3aa58)" to "[a29334556c55b6ed88f433f61004d31f2fc09188](https://github.com/sagemath/sagetrac-mirror/commit/a29334556c55b6ed88f433f61004d31f2fc09188)".



---

archive/issue_comments_672067.json:
```json
{
    "body": "<a id='comment:78'></a>\n**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d4eddc8346f69058d3b9f958e2ea24e8c9a659b0\">d4eddc8</a></td><td><code>_Minor change</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4d9e5a096f73e7d78195e36e1b64f4a592a6e26a\">4d9e5a0</a></td><td><code>Create __eq__ method in DrinfeldModuleMorphism</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fbddd9c5b1bb2ad5a2787693bcddd084169c9edc\">fbddd9c</a></td><td><code>Create is_finite method in DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9ef98d313cc78827c8dfd88a4323e8098ef3e945\">9ef98d3</a></td><td><code>Create is_isomorphism method in DrinfeldModuleMorphism</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f4bb02d7d13ce42a0849c82e0c07241f65cb9b72\">f4bb02d</a></td><td><code>Refactor _repr_ method in DrinfeldModuleHomset</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a21e5260e793600dbb61aabd5a58ed036c8a8d55\">a21e526</a></td><td><code>Remove _check_base_fields function from drinfeld_module.py</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a7c48a41addcc77880d4eaa90d8817f1758cc6ec\">a7c48a4</a></td><td><code>Fix __eq__ method in DrinfeldModuleMorphism</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a77f850a0da081228f32377b74f7d43cb9742cc5\">a77f850</a></td><td><code>Refactor exception messages in DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a60bede03b545fd0d9c3e36c645511c0eb382b40\">a60bede</a></td><td><code>Rewrite DrinfeldModule docstring</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a29334556c55b6ed88f433f61004d31f2fc09188\">a293345</a></td><td><code>Add classic Drinfeld module references to bib. master file</code></td></tr></table>\n",
    "created_at": "2022-08-08T22:00:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672067",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:78'></a>
**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d4eddc8346f69058d3b9f958e2ea24e8c9a659b0">d4eddc8</a></td><td><code>_Minor change</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4d9e5a096f73e7d78195e36e1b64f4a592a6e26a">4d9e5a0</a></td><td><code>Create __eq__ method in DrinfeldModuleMorphism</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fbddd9c5b1bb2ad5a2787693bcddd084169c9edc">fbddd9c</a></td><td><code>Create is_finite method in DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9ef98d313cc78827c8dfd88a4323e8098ef3e945">9ef98d3</a></td><td><code>Create is_isomorphism method in DrinfeldModuleMorphism</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f4bb02d7d13ce42a0849c82e0c07241f65cb9b72">f4bb02d</a></td><td><code>Refactor _repr_ method in DrinfeldModuleHomset</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a21e5260e793600dbb61aabd5a58ed036c8a8d55">a21e526</a></td><td><code>Remove _check_base_fields function from drinfeld_module.py</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a7c48a41addcc77880d4eaa90d8817f1758cc6ec">a7c48a4</a></td><td><code>Fix __eq__ method in DrinfeldModuleMorphism</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a77f850a0da081228f32377b74f7d43cb9742cc5">a77f850</a></td><td><code>Refactor exception messages in DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a60bede03b545fd0d9c3e36c645511c0eb382b40">a60bede</a></td><td><code>Rewrite DrinfeldModule docstring</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a29334556c55b6ed88f433f61004d31f2fc09188">a293345</a></td><td><code>Add classic Drinfeld module references to bib. master file</code></td></tr></table>




---

archive/issue_comments_672068.json:
```json
{
    "body": "**Changing commit** from \"[a29334556c55b6ed88f433f61004d31f2fc09188](https://github.com/sagemath/sagetrac-mirror/commit/a29334556c55b6ed88f433f61004d31f2fc09188)\" to \"[64be056aeb3369ef0c1fd56d6cd52c1ca33ce160](https://github.com/sagemath/sagetrac-mirror/commit/64be056aeb3369ef0c1fd56d6cd52c1ca33ce160)\".",
    "created_at": "2022-08-08T22:40:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672068",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[a29334556c55b6ed88f433f61004d31f2fc09188](https://github.com/sagemath/sagetrac-mirror/commit/a29334556c55b6ed88f433f61004d31f2fc09188)" to "[64be056aeb3369ef0c1fd56d6cd52c1ca33ce160](https://github.com/sagemath/sagetrac-mirror/commit/64be056aeb3369ef0c1fd56d6cd52c1ca33ce160)".



---

archive/issue_comments_672069.json:
```json
{
    "body": "<a id='comment:79'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/64be056aeb3369ef0c1fd56d6cd52c1ca33ce160\">64be056</a></td><td><code>Merge branch 'develop' into public/drinfeld_module</code></td></tr></table>\n",
    "created_at": "2022-08-08T22:40:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672069",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:79'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/64be056aeb3369ef0c1fd56d6cd52c1ca33ce160">64be056</a></td><td><code>Merge branch 'develop' into public/drinfeld_module</code></td></tr></table>




---

archive/issue_comments_672070.json:
```json
{
    "body": "<a id='comment:80'></a>\nThanks for the updates! Some comments and suggestions:\n\n* A small rephrasing suggestion:\n\n```diff\n     .. NOTE::\n \n         Drinfeld modules are defined in a larger setting, in which\n         `\\Fq[X]` is replaced by a more general ring: the ring of\n         functions in `k` that are regular outside `\\infty`, where `k` is\n+        a function field over `\\Fq` with transcendance degree `1`\n+        and `\\infty` is a fixed place of `k`. This is out of the scope\n+        of this implementation.\n-        a function field whose constant field is `\\Fq` and with\n-        transcendance degree `1`, and `\\infty` is a fixed place of `k`.\n-        This is out of the scope of this implementation.\n```\n* A typo:\n\n```diff\n     .. RUBRIC:: Morphisms, isogenies\n \n     A *morphism of Drinfeld modules `\\phi \\to \\psi`* is an Ore\n     polynomial `f \\in K\\{\\tau\\}` such that `f \\phi_a = \\psi_a f` for\n+    every `a \\in \\Fq[X]`. In our case, this is equivalent to verifying\n-    every $a \\in \\Fq[X]`. In our case, this is equivalent to verifying\n```\n* In order to be consistent with your notation:\n\n```diff\n+    Given an Ore polynomial that equals `\\phi_a` for some `a \\in\n-    Given an Ore polynomial that equals `\\phi(a)` for some `a \\in\n     \\Fq[X]`, we can retrieve `a` (as a morphism, a Drinfeld\n     module is injective, see [Gos1998]_, cor. 4.5.2.)::\n```\n* In commit a77f850, you made the following change:\n\n```diff\n\ndiff --git a/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py b/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py\nindex 337f507..52fceff 100644\n--- a/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py\n+++ b/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py\n@@ -44,8 +44,9 @@ class DrinfeldModule(UniqueRepresentation, CategoryObject):\n             ore_polring = None\n             ore_polring_base = Sequence(gen).universe()\n         else:\n-            raise TypeError('generator must be a list of coefficients '\\\n-                    'or an Ore polynomial')\n+\n+            raise TypeError('generator must be list of coefficients or an ' \\\n+                    'Ore polynomial')\n```\n   I think the original phrasing is the correct way of writting this.\n\n* Some docstrings of some methods should start with `Return...`. For example:\n\n```diff\n     def j(self):\n         r\"\"\"\n+        Return the j-invariant of the Drinfeld module; if the rank\n+        is not two, raise an exception.\n-        If the rank is two, return the j-invariant of the Drinfeld\n-        module; if the rank is not two, raise an exception.\n```\n* The two rank 2 specific methods `g` and `delta` could be generalized to higher ranks in only one method (see my[comment:75](#comment%3A75) ). Therefore, I would suggest to not include `g` and `delta` (so that they wont have to be deprecated in the future).",
    "created_at": "2022-08-09T14:01:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672070",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:80'></a>
Thanks for the updates! Some comments and suggestions:

* A small rephrasing suggestion:

```diff
     .. NOTE::
 
         Drinfeld modules are defined in a larger setting, in which
         `\Fq[X]` is replaced by a more general ring: the ring of
         functions in `k` that are regular outside `\infty`, where `k` is
+        a function field over `\Fq` with transcendance degree `1`
+        and `\infty` is a fixed place of `k`. This is out of the scope
+        of this implementation.
-        a function field whose constant field is `\Fq` and with
-        transcendance degree `1`, and `\infty` is a fixed place of `k`.
-        This is out of the scope of this implementation.
```
* A typo:

```diff
     .. RUBRIC:: Morphisms, isogenies
 
     A *morphism of Drinfeld modules `\phi \to \psi`* is an Ore
     polynomial `f \in K\{\tau\}` such that `f \phi_a = \psi_a f` for
+    every `a \in \Fq[X]`. In our case, this is equivalent to verifying
-    every $a \in \Fq[X]`. In our case, this is equivalent to verifying
```
* In order to be consistent with your notation:

```diff
+    Given an Ore polynomial that equals `\phi_a` for some `a \in
-    Given an Ore polynomial that equals `\phi(a)` for some `a \in
     \Fq[X]`, we can retrieve `a` (as a morphism, a Drinfeld
     module is injective, see [Gos1998]_, cor. 4.5.2.)::
```
* In commit a77f850, you made the following change:

```diff

diff --git a/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py b/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py
index 337f507..52fceff 100644
--- a/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py
+++ b/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py
@@ -44,8 +44,9 @@ class DrinfeldModule(UniqueRepresentation, CategoryObject):
             ore_polring = None
             ore_polring_base = Sequence(gen).universe()
         else:
-            raise TypeError('generator must be a list of coefficients '\
-                    'or an Ore polynomial')
+
+            raise TypeError('generator must be list of coefficients or an ' \
+                    'Ore polynomial')
```
   I think the original phrasing is the correct way of writting this.

* Some docstrings of some methods should start with `Return...`. For example:

```diff
     def j(self):
         r"""
+        Return the j-invariant of the Drinfeld module; if the rank
+        is not two, raise an exception.
-        If the rank is two, return the j-invariant of the Drinfeld
-        module; if the rank is not two, raise an exception.
```
* The two rank 2 specific methods `g` and `delta` could be generalized to higher ranks in only one method (see my[comment:75](#comment%3A75) ). Therefore, I would suggest to not include `g` and `delta` (so that they wont have to be deprecated in the future).



---

archive/issue_comments_672071.json:
```json
{
    "body": "<a id='comment:81'></a>\nSome quick comments about equality checking:\n\nIt is very dangerous to implement an `__eq__` without a `__ne__`. This can lead to *very* subtle bugs. I have had `x == y` and `x != y` both be `True` and both be `False` because of not doing this.\n\nHowever, subclasses of `Element` have an easier mechanism for implementing comparisons: `_richcmp_(self, other, op)`, where `op` is an integer telling which type of comparison is being done (there is also an `enum` (effectively) somewhere that you can import that makes it human-readable).\n\nIf you want to use `UniqueRepresentation`, then the inputs must uniquely distinguish the object for how to want to define equality (this doesn't have to mean isomorphic).",
    "created_at": "2022-08-10T00:21:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672071",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:81'></a>
Some quick comments about equality checking:

It is very dangerous to implement an `__eq__` without a `__ne__`. This can lead to *very* subtle bugs. I have had `x == y` and `x != y` both be `True` and both be `False` because of not doing this.

However, subclasses of `Element` have an easier mechanism for implementing comparisons: `_richcmp_(self, other, op)`, where `op` is an integer telling which type of comparison is being done (there is also an `enum` (effectively) somewhere that you can import that makes it human-readable).

If you want to use `UniqueRepresentation`, then the inputs must uniquely distinguish the object for how to want to define equality (this doesn't have to mean isomorphic).



---

archive/issue_comments_672072.json:
```json
{
    "body": "**Changing commit** from \"[64be056aeb3369ef0c1fd56d6cd52c1ca33ce160](https://github.com/sagemath/sagetrac-mirror/commit/64be056aeb3369ef0c1fd56d6cd52c1ca33ce160)\" to \"[d61a0cf2e8330f8d8bacb6c7c3bf52bd2c5a6988](https://github.com/sagemath/sagetrac-mirror/commit/d61a0cf2e8330f8d8bacb6c7c3bf52bd2c5a6988)\".",
    "created_at": "2022-08-16T17:02:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672072",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[64be056aeb3369ef0c1fd56d6cd52c1ca33ce160](https://github.com/sagemath/sagetrac-mirror/commit/64be056aeb3369ef0c1fd56d6cd52c1ca33ce160)" to "[d61a0cf2e8330f8d8bacb6c7c3bf52bd2c5a6988](https://github.com/sagemath/sagetrac-mirror/commit/d61a0cf2e8330f8d8bacb6c7c3bf52bd2c5a6988)".



---

archive/issue_comments_672073.json:
```json
{
    "body": "<a id='comment:82'></a>\n**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/96776b71af5144fc6ee5ae869ce69c5e4cf22263\">96776b7</a></td><td><code>Fix change_ring method in DrinfeldModule class</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5a640835045f561d74dcedc449cd94cf9bf5daea\">5a64083</a></td><td><code>Add polcast flag to build Drinfeld modules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/750d797641ec0cc00436737eabc1ba9a29f13977\">750d797</a></td><td><code>(minor) Fix comment in DrinfeldModule constructor</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ab02ba1ff7e97555284c458897895bb5e06bea91\">ab02ba1</a></td><td><code>Add name flag to change_ring method in DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4c9b81dfc492384b07d5fdf1eab4eeac08c2c7e5\">4c9b81d</a></td><td><code>Add examples in DrinfeldModule doc and rewrite docstrings</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ec1d6bd1c598177f1bea4cc59a570143067a97fd\">ec1d6bd</a></td><td><code>Refactor invert method in DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/dca2f7964e11e9999196a90dcfcb7dce590c5aa9\">dca2f79</a></td><td><code>Create method random_element in DrinfeldModules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ad98d81dba0cfe02572d3369ad2e6a27a1df0d25\">ad98d81</a></td><td><code>Create method constant_coefficient in DrinfeldModules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/20e2eadfb1460fdf3cafff08ab7ae7bc4c7973d2\">20e2ead</a></td><td><code>Refactor _repr_ method in DrinfeldModuleHomset</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d61a0cf2e8330f8d8bacb6c7c3bf52bd2c5a6988\">d61a0cf</a></td><td><code>Apply David's suggestions (ticket 33713 comment 80)</code></td></tr></table>\n",
    "created_at": "2022-08-16T17:02:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672073",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:82'></a>
**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/96776b71af5144fc6ee5ae869ce69c5e4cf22263">96776b7</a></td><td><code>Fix change_ring method in DrinfeldModule class</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5a640835045f561d74dcedc449cd94cf9bf5daea">5a64083</a></td><td><code>Add polcast flag to build Drinfeld modules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/750d797641ec0cc00436737eabc1ba9a29f13977">750d797</a></td><td><code>(minor) Fix comment in DrinfeldModule constructor</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ab02ba1ff7e97555284c458897895bb5e06bea91">ab02ba1</a></td><td><code>Add name flag to change_ring method in DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4c9b81dfc492384b07d5fdf1eab4eeac08c2c7e5">4c9b81d</a></td><td><code>Add examples in DrinfeldModule doc and rewrite docstrings</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ec1d6bd1c598177f1bea4cc59a570143067a97fd">ec1d6bd</a></td><td><code>Refactor invert method in DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/dca2f7964e11e9999196a90dcfcb7dce590c5aa9">dca2f79</a></td><td><code>Create method random_element in DrinfeldModules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ad98d81dba0cfe02572d3369ad2e6a27a1df0d25">ad98d81</a></td><td><code>Create method constant_coefficient in DrinfeldModules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/20e2eadfb1460fdf3cafff08ab7ae7bc4c7973d2">20e2ead</a></td><td><code>Refactor _repr_ method in DrinfeldModuleHomset</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d61a0cf2e8330f8d8bacb6c7c3bf52bd2c5a6988">d61a0cf</a></td><td><code>Apply David's suggestions (ticket 33713 comment 80)</code></td></tr></table>




---

archive/issue_comments_672074.json:
```json
{
    "body": "<a id='comment:83'></a>\nThanks to both of you. I implemented David's suggestions.\n\nReplying to [tscrim](#comment%3A81):\n> If you want to use `UniqueRepresentation`, then the inputs must uniquely distinguish the object for how to want to define equality (this doesn't have to mean isomorphic).\n\n\nNoted. I think `DrinfeldModuleMorphism` should inherit `UniqueRepresentation`, but my code doesn't work. More in Zulip.",
    "created_at": "2022-08-16T17:14:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672074",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:83'></a>
Thanks to both of you. I implemented David's suggestions.

Replying to [tscrim](#comment%3A81):
> If you want to use `UniqueRepresentation`, then the inputs must uniquely distinguish the object for how to want to define equality (this doesn't have to mean isomorphic).


Noted. I think `DrinfeldModuleMorphism` should inherit `UniqueRepresentation`, but my code doesn't work. More in Zulip.



---

archive/issue_comments_672075.json:
```json
{
    "body": "<a id='comment:84'></a>\nI replied in Zulip. Although as much as possible, I would like to have just one centralized place for coding issues (mainly here).",
    "created_at": "2022-08-16T23:53:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672075",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:84'></a>
I replied in Zulip. Although as much as possible, I would like to have just one centralized place for coding issues (mainly here).



---

archive/issue_comments_672076.json:
```json
{
    "body": "<a id='comment:85'></a>\n**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/999a0aefcd1fb0abfb14c799428e71061feb04c4\">999a0ae</a></td><td><code>Fix function_fields imports</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/942a9c8d95c0c59115ef55e533cd3f6ac999590c\">942a9c8</a></td><td><code>Fix DrinfeldModuleAction</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/721f3072209d05e89fd3587b9bd0f2b4aee9f5c7\">721f307</a></td><td><code>Use super().__init__(...) for Drinfeld modules (esp. DrinfeldModuleMorphism)</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/919cf5ed1360e5f65ade295ac4326d4066fb4a94\">919cf5e</a></td><td><code>Create _latex_ method in DrinfeldModuleHomset</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/70c215aec33c26379d45000b9d65a76645ab8af7\">70c215a</a></td><td><code>Write docstrings for DrinfeldModuleHomset</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c9bfc054383b828e118fb79a4ee5cae60535d7d5\">c9bfc05</a></td><td><code>(minor) Delete a blank line in DrinfeldModules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/394d0f5edd4941727f6420b8c76081bdad5269cb\">394d0f5</a></td><td><code>(minor) Change a sentence in DrinfeldModuleMorphism</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0f869f2345c2e071023dc5a7832b1776e1ed71be\">0f869f2</a></td><td><code>(minor) Change first sentences of Drinfeld module classes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/14f98aa4effbbea9a1e1f2e72aee31bc12988085\">14f98aa</a></td><td><code>Change _get_action_ to action in DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b014a199f9c25b30234d672cc9ca8e2e9292ba25\">b014a19</a></td><td><code>Reorder methods in DrinfeldModule</code></td></tr></table>\n",
    "created_at": "2022-08-19T15:29:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672076",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:85'></a>
**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/999a0aefcd1fb0abfb14c799428e71061feb04c4">999a0ae</a></td><td><code>Fix function_fields imports</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/942a9c8d95c0c59115ef55e533cd3f6ac999590c">942a9c8</a></td><td><code>Fix DrinfeldModuleAction</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/721f3072209d05e89fd3587b9bd0f2b4aee9f5c7">721f307</a></td><td><code>Use super().__init__(...) for Drinfeld modules (esp. DrinfeldModuleMorphism)</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/919cf5ed1360e5f65ade295ac4326d4066fb4a94">919cf5e</a></td><td><code>Create _latex_ method in DrinfeldModuleHomset</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/70c215aec33c26379d45000b9d65a76645ab8af7">70c215a</a></td><td><code>Write docstrings for DrinfeldModuleHomset</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c9bfc054383b828e118fb79a4ee5cae60535d7d5">c9bfc05</a></td><td><code>(minor) Delete a blank line in DrinfeldModules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/394d0f5edd4941727f6420b8c76081bdad5269cb">394d0f5</a></td><td><code>(minor) Change a sentence in DrinfeldModuleMorphism</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0f869f2345c2e071023dc5a7832b1776e1ed71be">0f869f2</a></td><td><code>(minor) Change first sentences of Drinfeld module classes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/14f98aa4effbbea9a1e1f2e72aee31bc12988085">14f98aa</a></td><td><code>Change _get_action_ to action in DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b014a199f9c25b30234d672cc9ca8e2e9292ba25">b014a19</a></td><td><code>Reorder methods in DrinfeldModule</code></td></tr></table>




---

archive/issue_comments_672077.json:
```json
{
    "body": "**Changing commit** from \"[d61a0cf2e8330f8d8bacb6c7c3bf52bd2c5a6988](https://github.com/sagemath/sagetrac-mirror/commit/d61a0cf2e8330f8d8bacb6c7c3bf52bd2c5a6988)\" to \"[b014a199f9c25b30234d672cc9ca8e2e9292ba25](https://github.com/sagemath/sagetrac-mirror/commit/b014a199f9c25b30234d672cc9ca8e2e9292ba25)\".",
    "created_at": "2022-08-19T15:29:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672077",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[d61a0cf2e8330f8d8bacb6c7c3bf52bd2c5a6988](https://github.com/sagemath/sagetrac-mirror/commit/d61a0cf2e8330f8d8bacb6c7c3bf52bd2c5a6988)" to "[b014a199f9c25b30234d672cc9ca8e2e9292ba25](https://github.com/sagemath/sagetrac-mirror/commit/b014a199f9c25b30234d672cc9ca8e2e9292ba25)".



---

archive/issue_comments_672078.json:
```json
{
    "body": "<a id='comment:86'></a>\nMany thanks Travis for the help, this was useful.\n\nThe work is progressing. I think the docstrings of `DrinfeldModule` can now be reviewed, even though they lack some `TESTS::` fields. I wrote many of the other docstrings as well, even though I did not re-read them.\n\nSome comments:\n- David, I don't think implementing the method `DrinfeldModule.coefficient` is useful, as the syntax `phi(X)[n]` is shorter and already there. I included all your other suggestions.\n- I renamed the method `DrinfeldModule._get_action_` to `DrinfeldModule.action`. Using representations does not seem appropriate nor standard when it comes to the study of Drinfeld modules.\n- I am not too qualified to work with metaclasses. If you review the code, be extra attentive with this aspect.",
    "created_at": "2022-08-19T15:31:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672078",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:86'></a>
Many thanks Travis for the help, this was useful.

The work is progressing. I think the docstrings of `DrinfeldModule` can now be reviewed, even though they lack some `TESTS::` fields. I wrote many of the other docstrings as well, even though I did not re-read them.

Some comments:
- David, I don't think implementing the method `DrinfeldModule.coefficient` is useful, as the syntax `phi(X)[n]` is shorter and already there. I included all your other suggestions.
- I renamed the method `DrinfeldModule._get_action_` to `DrinfeldModule.action`. Using representations does not seem appropriate nor standard when it comes to the study of Drinfeld modules.
- I am not too qualified to work with metaclasses. If you review the code, be extra attentive with this aspect.



---

archive/issue_comments_672079.json:
```json
{
    "body": "<a id='comment:87'></a>\n> David, I don't think implementing the method `DrinfeldModule.coefficient` is useful, as the syntax `phi(X)[n]` is shorter and already there. I included all your other suggestions.\n\n\nAt this point I don't really know if a `DrinfeldModule.coefficient` would be useful or not. Did you had any intention behind the methods `g` and `delta` in the rank two case?\n\n* Small suggestion: I don't think you need to reference the class you are currently documenting inside its own documentation. To me, it is clear enough that we are creating an instance of this class. \n\n```diff\n+    A Drinfeld module object is constructed as follows::\n-    A Drinfeld module object (class\n-    :class:`sage.rings.function_field.drinfeld_module.drinfeld_module.DrinfeldModule`)\n-    is constructed as follows::\n```\n\n* Reformulation:\n\n```diff\n         sage: ore_polring = phi.ore_polring()\n+        sage: t = phi.ore_variable()  # same as ore_polring.gen()\n-        sage: t = phi.ore_variable()  # Is ore_polring.gen()\n```\n\n* Personnal opinion, but I don't think this remark is really important:\n\n```\n     Naturally, the input is checked, and exceptions are raised when the\n     input is invalid.\n```\n\n* Some rephrasing:\n\n```diff\n+    The function ring must be a univariate polynomial ring over `\\Fq`::\n-    The function ring must be an `\\Fq[X]`::\n\n         sage: DrinfeldModule(K, [z, 1, 1])\n         Traceback (most recent call last):\n         ...\n         NotImplementedError: function ring must be a polynomial ring\n \n         sage: FqXY.<Y> = FqX[]\n         sage: DrinfeldModule(FqXY, [z, 1, 1])\n         Traceback (most recent call last):\n         ...\n+        TypeError: the base ring of the function ring must be a finite field\n-        TypeError: function ring base must be a finite field\n```\n\n* The methods `DrinfeldModule._repr_`, `DrinfeldModule._latex_` and `DrinfeldModule.action` are still not documented.\n\n* For the `OUTPUT` field, I don't think you need to put a hyphen everytime, since there is generally only one output.\n\nI haven't read everything yet, but I will continue at a later time.",
    "created_at": "2022-08-19T17:00:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672079",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:87'></a>
> David, I don't think implementing the method `DrinfeldModule.coefficient` is useful, as the syntax `phi(X)[n]` is shorter and already there. I included all your other suggestions.


At this point I don't really know if a `DrinfeldModule.coefficient` would be useful or not. Did you had any intention behind the methods `g` and `delta` in the rank two case?

* Small suggestion: I don't think you need to reference the class you are currently documenting inside its own documentation. To me, it is clear enough that we are creating an instance of this class. 

```diff
+    A Drinfeld module object is constructed as follows::
-    A Drinfeld module object (class
-    :class:`sage.rings.function_field.drinfeld_module.drinfeld_module.DrinfeldModule`)
-    is constructed as follows::
```

* Reformulation:

```diff
         sage: ore_polring = phi.ore_polring()
+        sage: t = phi.ore_variable()  # same as ore_polring.gen()
-        sage: t = phi.ore_variable()  # Is ore_polring.gen()
```

* Personnal opinion, but I don't think this remark is really important:

```
     Naturally, the input is checked, and exceptions are raised when the
     input is invalid.
```

* Some rephrasing:

```diff
+    The function ring must be a univariate polynomial ring over `\Fq`::
-    The function ring must be an `\Fq[X]`::

         sage: DrinfeldModule(K, [z, 1, 1])
         Traceback (most recent call last):
         ...
         NotImplementedError: function ring must be a polynomial ring
 
         sage: FqXY.<Y> = FqX[]
         sage: DrinfeldModule(FqXY, [z, 1, 1])
         Traceback (most recent call last):
         ...
+        TypeError: the base ring of the function ring must be a finite field
-        TypeError: function ring base must be a finite field
```

* The methods `DrinfeldModule._repr_`, `DrinfeldModule._latex_` and `DrinfeldModule.action` are still not documented.

* For the `OUTPUT` field, I don't think you need to put a hyphen everytime, since there is generally only one output.

I haven't read everything yet, but I will continue at a later time.



---

archive/issue_comments_672080.json:
```json
{
    "body": "<a id='comment:88'></a>\n* On lines 471-474, I don't think that this `if` statement is necessary:\n\n```\n        # Check gen as Ore polynomial\n        if ore_polring not in (None, category.ore_polring()):\n            raise ValueError(f'generator must lie in {category.ore_polring()}')\n        ore_polring = category.ore_polring()  # Sanity cast\n```\n    However, the \"sanity cast\" at line 474 is necessary (otherwise `ore_polring` could be `None`)\n\n* Typo on line 1163, col. 54:\n\n```diff\n+                1. The degree of the characteristic divides the height\n-                1. The degree of the characteristic devides the height\n```\n\n* For the method `DrinfeldModule.velu`, why do you choose return `None` instead of raising an exception (\"not an isogeny\")?",
    "created_at": "2022-08-19T20:30:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672080",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:88'></a>
* On lines 471-474, I don't think that this `if` statement is necessary:

```
        # Check gen as Ore polynomial
        if ore_polring not in (None, category.ore_polring()):
            raise ValueError(f'generator must lie in {category.ore_polring()}')
        ore_polring = category.ore_polring()  # Sanity cast
```
    However, the "sanity cast" at line 474 is necessary (otherwise `ore_polring` could be `None`)

* Typo on line 1163, col. 54:

```diff
+                1. The degree of the characteristic divides the height
-                1. The degree of the characteristic devides the height
```

* For the method `DrinfeldModule.velu`, why do you choose return `None` instead of raising an exception ("not an isogeny")?



---

archive/issue_comments_672081.json:
```json
{
    "body": "<a id='comment:89'></a>\nReplying to [antoine-leudiere](#comment%3A86):\n\n> - David, I don't think implementing the method `DrinfeldModule.coefficient` is useful, as the syntax `phi(X)[n]` is shorter and already there. I included all your other suggestions.\n\n\nI would say that having both is okay; for instance, it is what we have for polynomials.",
    "created_at": "2022-08-21T15:46:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672081",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:89'></a>
Replying to [antoine-leudiere](#comment%3A86):

> - David, I don't think implementing the method `DrinfeldModule.coefficient` is useful, as the syntax `phi(X)[n]` is shorter and already there. I included all your other suggestions.


I would say that having both is okay; for instance, it is what we have for polynomials.



---

archive/issue_comments_672082.json:
```json
{
    "body": "<a id='comment:90'></a>\nI basically agree with all of David's suggestions. Although I would actually change the \"sanity cast\":\n\n```diff\n         # Check gen as Ore polynomial\n-        if ore_polring not in (None, category.ore_polring()):\n+        if ore_polring is not None and ore_polring != category.ore_polring():\n             raise ValueError(f'generator must lie in {category.ore_polring()}')\n         ore_polring = category.ore_polring()  # Sanity cast\n```\nsince you are checking user input.\n\nPersonal opinion, but I prefer\n\n```diff\n         # Instantiate the appropriate class\n         if ore_polring_base.is_finite():\n             from sage.rings.function_field.drinfeld_modules.finite_drinfeld_module import FiniteDrinfeldModule\n             return FiniteDrinfeldModule(gen, category)\n-        else:\n-            return cls.__classcall__(cls, gen, category)\n+        return cls.__classcall__(cls, gen, category)\n```\n\nI would probably rename the very generic name `j()` to `j_invariant()` for Drinfeld modules.\n\nNote also that categories do not have \"elements\" but \"objects,\" so `random_element()` should be `random_object()` (although, being a broken record, this suggests you are treating it as a `Parent`).",
    "created_at": "2022-08-22T03:36:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672082",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:90'></a>
I basically agree with all of David's suggestions. Although I would actually change the "sanity cast":

```diff
         # Check gen as Ore polynomial
-        if ore_polring not in (None, category.ore_polring()):
+        if ore_polring is not None and ore_polring != category.ore_polring():
             raise ValueError(f'generator must lie in {category.ore_polring()}')
         ore_polring = category.ore_polring()  # Sanity cast
```
since you are checking user input.

Personal opinion, but I prefer

```diff
         # Instantiate the appropriate class
         if ore_polring_base.is_finite():
             from sage.rings.function_field.drinfeld_modules.finite_drinfeld_module import FiniteDrinfeldModule
             return FiniteDrinfeldModule(gen, category)
-        else:
-            return cls.__classcall__(cls, gen, category)
+        return cls.__classcall__(cls, gen, category)
```

I would probably rename the very generic name `j()` to `j_invariant()` for Drinfeld modules.

Note also that categories do not have "elements" but "objects," so `random_element()` should be `random_object()` (although, being a broken record, this suggests you are treating it as a `Parent`).



---

archive/issue_comments_672083.json:
```json
{
    "body": "<a id='comment:91'></a>\n* +1 for renaming `DrinfeldModule.j` into `DrinfeldModule.j_invariant`\n\nSome minor corrections: \n\n* A duplicate word at line 779:\n\n```diff\n    def gen(self):\n        r\"\"\"\n        Return the generator of the Drinfeld module, i.e. `\\phi_X`.\n\n        This method makes sense because, in our case, the function ring\n+       `\\Fq[X]`, which is `\\Fq`-generated by a single element whose,\n+       image characterizes the Drinfeld module.\n-       `\\Fq[X]`, which is `\\Fq`-generated by a single element element,\n-       whose image characterizes the Drinfeld module.\n```\n* Line 822:\n\n```diff\n+    Return the preimage of the input under the Drinfeld module;\n-    Return the pre-image of the input under the Drinfeld module;\n```\n* Small suggestion:\n\n```diff\n    def is_finite(self):\n        r\"\"\"\n+       Return ``True`` whether the Drinfeld module is finite.\n-       Return ``True`` if the Drinfeld module is finite; return\n-       ``False`` otherwise.\n```\n* Lines 316-317:\n\n```diff\n+    Use the ``in`` syntax to test if an Ore polynomial defines a\n+    morphism::\n-    Use the ``in`` syntax to test if an Ore polynomial defines an\n-    isogeny::\n```\n* Line 380:\n\n```diff\n+    Let ``ore_pol`` be a non-zero Ore polynomial. For\n-    Let ``ore_pol`` be a non-zero Ore polynomial ``ore_pol``. For\n```",
    "created_at": "2022-08-22T14:45:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672083",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:91'></a>
* +1 for renaming `DrinfeldModule.j` into `DrinfeldModule.j_invariant`

Some minor corrections: 

* A duplicate word at line 779:

```diff
    def gen(self):
        r"""
        Return the generator of the Drinfeld module, i.e. `\phi_X`.

        This method makes sense because, in our case, the function ring
+       `\Fq[X]`, which is `\Fq`-generated by a single element whose,
+       image characterizes the Drinfeld module.
-       `\Fq[X]`, which is `\Fq`-generated by a single element element,
-       whose image characterizes the Drinfeld module.
```
* Line 822:

```diff
+    Return the preimage of the input under the Drinfeld module;
-    Return the pre-image of the input under the Drinfeld module;
```
* Small suggestion:

```diff
    def is_finite(self):
        r"""
+       Return ``True`` whether the Drinfeld module is finite.
-       Return ``True`` if the Drinfeld module is finite; return
-       ``False`` otherwise.
```
* Lines 316-317:

```diff
+    Use the ``in`` syntax to test if an Ore polynomial defines a
+    morphism::
-    Use the ``in`` syntax to test if an Ore polynomial defines an
-    isogeny::
```
* Line 380:

```diff
+    Let ``ore_pol`` be a non-zero Ore polynomial. For
-    Let ``ore_pol`` be a non-zero Ore polynomial ``ore_pol``. For
```



---

archive/issue_comments_672084.json:
```json
{
    "body": "<a id='comment:92'></a>\n**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e50a5caab8c6dcfacc1c1a96338f28782c677457\">e50a5ca</a></td><td><code>Handle some zero Fq[X]-characteristic special cases in DrinfeldModules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f5aa48906702e0a42c01c63374072e5a9874861d\">f5aa489</a></td><td><code>Create _base attribute in DrinfeldModules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/386efec427689989407aae7f788ad4f0d05b6cac\">386efec</a></td><td><code>Write docstrings in DrinfeldModules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e80ed4b20d381b60171dc22548a355e7869fc0f7\">e80ed4b</a></td><td><code>Make OUTPUT: fields oneliners in Drinfeld modules classes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3962e10587ebd857759b8ee18e0d5a81bcccfc30\">3962e10</a></td><td><code>Raise an exception if invalid input for velu method in DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5f8c0050392027b4a49b90a3aad75306d621e1e9\">5f8c005</a></td><td><code>Add _latex_ and _repr_ docstrings in Drinfeld modules classes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/83c728ebf5fb752f5e36cc2693ac1f1ff37636f4\">83c728e</a></td><td><code>Rename j method to j_invariant in DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/53088a9d7f981d6bd5dba9fa60405c975de583a9\">53088a9</a></td><td><code>Add various docstrings in Drinfeld module classes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/261ab62cdd20badc99fbcb1ddf59bfcf56073ed0\">261ab62</a></td><td><code>Include final comments (87-90) from Ticket</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c6aaebdedd3a65cf0ba352bba0c713711ca3458d\">c6aaebd</a></td><td><code>Add coefficients methods in DrinfeldModule</code></td></tr></table>\n",
    "created_at": "2022-08-22T18:00:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672084",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:92'></a>
**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e50a5caab8c6dcfacc1c1a96338f28782c677457">e50a5ca</a></td><td><code>Handle some zero Fq[X]-characteristic special cases in DrinfeldModules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f5aa48906702e0a42c01c63374072e5a9874861d">f5aa489</a></td><td><code>Create _base attribute in DrinfeldModules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/386efec427689989407aae7f788ad4f0d05b6cac">386efec</a></td><td><code>Write docstrings in DrinfeldModules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e80ed4b20d381b60171dc22548a355e7869fc0f7">e80ed4b</a></td><td><code>Make OUTPUT: fields oneliners in Drinfeld modules classes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3962e10587ebd857759b8ee18e0d5a81bcccfc30">3962e10</a></td><td><code>Raise an exception if invalid input for velu method in DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5f8c0050392027b4a49b90a3aad75306d621e1e9">5f8c005</a></td><td><code>Add _latex_ and _repr_ docstrings in Drinfeld modules classes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/83c728ebf5fb752f5e36cc2693ac1f1ff37636f4">83c728e</a></td><td><code>Rename j method to j_invariant in DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/53088a9d7f981d6bd5dba9fa60405c975de583a9">53088a9</a></td><td><code>Add various docstrings in Drinfeld module classes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/261ab62cdd20badc99fbcb1ddf59bfcf56073ed0">261ab62</a></td><td><code>Include final comments (87-90) from Ticket</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c6aaebdedd3a65cf0ba352bba0c713711ca3458d">c6aaebd</a></td><td><code>Add coefficients methods in DrinfeldModule</code></td></tr></table>




---

archive/issue_comments_672085.json:
```json
{
    "body": "**Changing commit** from \"[b014a199f9c25b30234d672cc9ca8e2e9292ba25](https://github.com/sagemath/sagetrac-mirror/commit/b014a199f9c25b30234d672cc9ca8e2e9292ba25)\" to \"[c6aaebdedd3a65cf0ba352bba0c713711ca3458d](https://github.com/sagemath/sagetrac-mirror/commit/c6aaebdedd3a65cf0ba352bba0c713711ca3458d)\".",
    "created_at": "2022-08-22T18:00:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672085",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[b014a199f9c25b30234d672cc9ca8e2e9292ba25](https://github.com/sagemath/sagetrac-mirror/commit/b014a199f9c25b30234d672cc9ca8e2e9292ba25)" to "[c6aaebdedd3a65cf0ba352bba0c713711ca3458d](https://github.com/sagemath/sagetrac-mirror/commit/c6aaebdedd3a65cf0ba352bba0c713711ca3458d)".



---

archive/issue_comments_672086.json:
```json
{
    "body": "<a id='comment:93'></a>\nMany thanks to all of you for the quality feedback.\n\nAll documentation is basically written; I will write further tests tomorrow. After your review, I will perform a final proofread, lint the code and mark it as experimental. Then, the code will be ready for 'official' review.\n\nI am still a bit skeptical about `rings.function_field.drinfeld_modules`, even though I don't have any better proposal.\n\nI basically added all suggestions, except this one:\n\n> * Some rephrasing:\n> \n> ```diff\n> +    The function ring must be a univariate polynomial ring over `\\Fq`::\n> -    The function ring must be an `\\Fq[X]`::\n> \n>          sage: DrinfeldModule(K, [z, 1, 1])\n>          Traceback (most recent call last):\n>          ...\n>          NotImplementedError: function ring must be a polynomial ring\n>  \n>          sage: FqXY.<Y> = FqX[]\n>          sage: DrinfeldModule(FqXY, [z, 1, 1])\n>          Traceback (most recent call last):\n>          ...\n> +        TypeError: the base ring of the function ring must be a finite field\n> -        TypeError: function ring base must be a finite field\n> ```\n\n\nThe first proposal is hard to parse; the second does not seem easier, yet it is longer.\n\n> Note also that categories do not have \"elements\" but \"objects,\" so `random_element()` should be `random_object()` (although, being a broken record, this suggests you are treating it as a `Parent`).\n\n\nI feel that Xavier now has a solid math. understanding of Drinfeld modules, as I gave him a talk on the subject and we have been working on some computational aspects. As he furthermore is a proven [SageMath](SageMath) dev., I am more enclined to following his advice of using `CategoryObject`.",
    "created_at": "2022-08-22T18:01:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672086",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:93'></a>
Many thanks to all of you for the quality feedback.

All documentation is basically written; I will write further tests tomorrow. After your review, I will perform a final proofread, lint the code and mark it as experimental. Then, the code will be ready for 'official' review.

I am still a bit skeptical about `rings.function_field.drinfeld_modules`, even though I don't have any better proposal.

I basically added all suggestions, except this one:

> * Some rephrasing:
> 
> ```diff
> +    The function ring must be a univariate polynomial ring over `\Fq`::
> -    The function ring must be an `\Fq[X]`::
> 
>          sage: DrinfeldModule(K, [z, 1, 1])
>          Traceback (most recent call last):
>          ...
>          NotImplementedError: function ring must be a polynomial ring
>  
>          sage: FqXY.<Y> = FqX[]
>          sage: DrinfeldModule(FqXY, [z, 1, 1])
>          Traceback (most recent call last):
>          ...
> +        TypeError: the base ring of the function ring must be a finite field
> -        TypeError: function ring base must be a finite field
> ```


The first proposal is hard to parse; the second does not seem easier, yet it is longer.

> Note also that categories do not have "elements" but "objects," so `random_element()` should be `random_object()` (although, being a broken record, this suggests you are treating it as a `Parent`).


I feel that Xavier now has a solid math. understanding of Drinfeld modules, as I gave him a talk on the subject and we have been working on some computational aspects. As he furthermore is a proven [SageMath](SageMath) dev., I am more enclined to following his advice of using `CategoryObject`.



---

archive/issue_comments_672087.json:
```json
{
    "body": "<a id='comment:94'></a>\nI'm not sure to understand what you mean by \"hard to parse\". \n\nAlso, why do you want to mark the code as experimental?",
    "created_at": "2022-08-22T18:45:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672087",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:94'></a>
I'm not sure to understand what you mean by "hard to parse". 

Also, why do you want to mark the code as experimental?



---

archive/issue_comments_672088.json:
```json
{
    "body": "<a id='comment:95'></a>\nReplying to [antoine-leudiere](#comment%3A93):\n> I feel that Xavier now has a solid math. understanding of Drinfeld modules, as I gave him a talk on the subject and we have been working on some computational aspects. As he furthermore is a proven [SageMath](SageMath) dev., I am more enclined to following his advice of using `CategoryObject`.\n\n\nTravis' suggestion was just to rename `random_element` to `random_object` and I think he's right.\n\nAlso, like David, I think that your code does not need to be marked as experimental. The experimental decorator allows for changing the interface without a decrecation delay; however, in this particular case, I think that we are all more or less satisfied with the current interface and that there is no reason that it will change in a near future.",
    "created_at": "2022-08-22T19:08:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672088",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:95'></a>
Replying to [antoine-leudiere](#comment%3A93):
> I feel that Xavier now has a solid math. understanding of Drinfeld modules, as I gave him a talk on the subject and we have been working on some computational aspects. As he furthermore is a proven [SageMath](SageMath) dev., I am more enclined to following his advice of using `CategoryObject`.


Travis' suggestion was just to rename `random_element` to `random_object` and I think he's right.

Also, like David, I think that your code does not need to be marked as experimental. The experimental decorator allows for changing the interface without a decrecation delay; however, in this particular case, I think that we are all more or less satisfied with the current interface and that there is no reason that it will change in a near future.



---

archive/issue_comments_672089.json:
```json
{
    "body": "<a id='comment:96'></a>\nAlso, quick comment, in many places in your docstrings you write `\\Fq[X]`, for example:\n\n```\nOUTPUT: a polynomial in `\\Fq[X]`\n```\nHowever, I might be picky with this, but I'm don't think that it's the best formulation as someone might use an other variable name for the `\\Fq`-generator of the function ring (for example `\"T\"`), making most of these docstrings misleading. In particular, this is why I proposed before to change the structure of some sentences into something a little bit more \"wordy\".",
    "created_at": "2022-08-22T21:08:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672089",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:96'></a>
Also, quick comment, in many places in your docstrings you write `\Fq[X]`, for example:

```
OUTPUT: a polynomial in `\Fq[X]`
```
However, I might be picky with this, but I'm don't think that it's the best formulation as someone might use an other variable name for the `\Fq`-generator of the function ring (for example `"T"`), making most of these docstrings misleading. In particular, this is why I proposed before to change the structure of some sentences into something a little bit more "wordy".



---

archive/issue_comments_672090.json:
```json
{
    "body": "<a id='comment:97'></a>\nReplying to [caruso](#comment%3A95):\n> Replying to [antoine-leudiere](#comment%3A93):\n> > I feel that Xavier now has a solid math. understanding of Drinfeld modules, as I gave him a talk on the subject and we have been working on some computational aspects.\n\n> \n> Travis' suggestion was just to rename `random_element` to `random_object` and I think he's right.\n\n\nIndeed, that was my suggestion.\n\nHowever, I would like to know what Xavier thinks about[comment:76](#comment%3A76). The more I see and understand the code, the more I am convinced that you should follow the standard `Parent`-`Element` framework (instead of `Category`-`CategoryObject`). Briefly rereading the above discussion, I am not sure there are any advantages of the current approach other than mathematically the set is generally considered to be a category (which I don't think should play too heavily on the implementation details).\n\n> As he furthermore is a proven [SageMath](SageMath) dev., I am more enclined to following his advice of using `CategoryObject`.\n\n\nThis rankled me a bit since David and I are both \"proven [SageMath](SageMath) developers\" in any sense of the phrase.\n\n> Also, like David, I think that your code does not need to be marked as experimental. The experimental decorator allows for changing the interface without a decrecation delay; however, in this particular case, I think that we are all more or less satisfied with the current interface and that there is no reason that it will change in a near future.\n\n\nI also agree with this.",
    "created_at": "2022-08-23T02:25:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672090",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:97'></a>
Replying to [caruso](#comment%3A95):
> Replying to [antoine-leudiere](#comment%3A93):
> > I feel that Xavier now has a solid math. understanding of Drinfeld modules, as I gave him a talk on the subject and we have been working on some computational aspects.

> 
> Travis' suggestion was just to rename `random_element` to `random_object` and I think he's right.


Indeed, that was my suggestion.

However, I would like to know what Xavier thinks about[comment:76](#comment%3A76). The more I see and understand the code, the more I am convinced that you should follow the standard `Parent`-`Element` framework (instead of `Category`-`CategoryObject`). Briefly rereading the above discussion, I am not sure there are any advantages of the current approach other than mathematically the set is generally considered to be a category (which I don't think should play too heavily on the implementation details).

> As he furthermore is a proven [SageMath](SageMath) dev., I am more enclined to following his advice of using `CategoryObject`.


This rankled me a bit since David and I are both "proven [SageMath](SageMath) developers" in any sense of the phrase.

> Also, like David, I think that your code does not need to be marked as experimental. The experimental decorator allows for changing the interface without a decrecation delay; however, in this particular case, I think that we are all more or less satisfied with the current interface and that there is no reason that it will change in a near future.


I also agree with this.



---

archive/issue_comments_672091.json:
```json
{
    "body": "**Changing commit** from \"[c6aaebdedd3a65cf0ba352bba0c713711ca3458d](https://github.com/sagemath/sagetrac-mirror/commit/c6aaebdedd3a65cf0ba352bba0c713711ca3458d)\" to \"[fd9126ca9b005b7f5aaec033cd767769d57b6e2f](https://github.com/sagemath/sagetrac-mirror/commit/fd9126ca9b005b7f5aaec033cd767769d57b6e2f)\".",
    "created_at": "2022-08-25T14:27:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672091",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[c6aaebdedd3a65cf0ba352bba0c713711ca3458d](https://github.com/sagemath/sagetrac-mirror/commit/c6aaebdedd3a65cf0ba352bba0c713711ca3458d)" to "[fd9126ca9b005b7f5aaec033cd767769d57b6e2f](https://github.com/sagemath/sagetrac-mirror/commit/fd9126ca9b005b7f5aaec033cd767769d57b6e2f)".



---

archive/issue_comments_672092.json:
```json
{
    "body": "<a id='comment:98'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/529f5ec6b7757a7451d0dfeeaf51a910a9650dc2\">529f5ec</a></td><td><code>Use Fq[X] notation as little as possible in Drinfeld modules classes (comment 96)</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8b890f4639cdf841a9e54ecea43be942b381c6ef\">8b890f4</a></td><td><code>Change an exception text in DrinfeldModules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3f542d8d72e398e7e6110402a656243ee04dda9a\">3f542d8</a></td><td><code>Check morphism is non zero in DrinfeldModules</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fd9126ca9b005b7f5aaec033cd767769d57b6e2f\">fd9126c</a></td><td><code>Add various TESTS: in Drinfeld modules classes</code></td></tr></table>\n",
    "created_at": "2022-08-25T14:27:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672092",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:98'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/529f5ec6b7757a7451d0dfeeaf51a910a9650dc2">529f5ec</a></td><td><code>Use Fq[X] notation as little as possible in Drinfeld modules classes (comment 96)</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8b890f4639cdf841a9e54ecea43be942b381c6ef">8b890f4</a></td><td><code>Change an exception text in DrinfeldModules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3f542d8d72e398e7e6110402a656243ee04dda9a">3f542d8</a></td><td><code>Check morphism is non zero in DrinfeldModules</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fd9126ca9b005b7f5aaec033cd767769d57b6e2f">fd9126c</a></td><td><code>Add various TESTS: in Drinfeld modules classes</code></td></tr></table>




---

archive/issue_comments_672093.json:
```json
{
    "body": "<a id='comment:99'></a>\nI spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: \"Ok, this is new, this may change, and the author wants complete freedom for doing so\". The way I see it, there are almost no benefits in not using it, but we may on the other hand end up very relieved.\n\nBtw, `random_element` was changed to `random_object` before my reply.",
    "created_at": "2022-08-25T14:28:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672093",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:99'></a>
I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: "Ok, this is new, this may change, and the author wants complete freedom for doing so". The way I see it, there are almost no benefits in not using it, but we may on the other hand end up very relieved.

Btw, `random_element` was changed to `random_object` before my reply.



---

archive/issue_comments_672094.json:
```json
{
    "body": "<a id='comment:0'></a>\n>I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: \"Ok, this is new, this may change, and the author wants complete freedom for doing so\".\n\n\nI believe that this would be a bad practice for [SageMath](SageMath) and, more generally, for software development. Our common goal here is to develop a robust end product that the general user can conveniently use. Moreover we want that so called end product to be scalable and last over the time (if not, what's the point?).\n\nFrom a quick glance, I found a small typo:\n\n```diff\n+    The constant coefficient must be non zero::\n-    The constant coefficient mudt be non zero::\n```\nI'll check the rest later.",
    "created_at": "2022-08-25T14:52:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672094",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:0'></a>
>I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: "Ok, this is new, this may change, and the author wants complete freedom for doing so".


I believe that this would be a bad practice for [SageMath](SageMath) and, more generally, for software development. Our common goal here is to develop a robust end product that the general user can conveniently use. Moreover we want that so called end product to be scalable and last over the time (if not, what's the point?).

From a quick glance, I found a small typo:

```diff
+    The constant coefficient must be non zero::
-    The constant coefficient mudt be non zero::
```
I'll check the rest later.



---

archive/issue_comments_672095.json:
```json
{
    "body": "<a id='comment:101'></a>\nReplying to [tscrim](#comment%3A97):\n> However, I would like to know what Xavier thinks about[comment:76](#comment%3A76). The more I see and understand the code, the more I am convinced that you should follow the standard `Parent`-`Element` framework (instead of `Category`-`CategoryObject`). Briefly rereading the above discussion, I am not sure there are any advantages of the current approach other than mathematically the set is generally considered to be a category (which I don't think should play too heavily on the implementation details).\n\n\nSorry, because of the holidays, I missed your message.\n\nI'm actually not sure that allowing for implicit coercion is desirable here (and, in any case, it won't probably be useful because we have no addition/multiplication on Drinfeld modules). On the other hand, according to me, it is quite important that the implementation reflects as well as possible the mathematical nature/properties of the objects. So I'm still in favour of using `CategoryObject` and not `Parent`.\nBut, as I said, if there is a clear preference for the other option, it will be okay with me.\n\nBtw, I'm not sure to understand this argument:\n>beyond the technical one of having a specific element class associated to DM (in particular, you won't have to write code that works if I come along with my own implementation of Drinfeld modules using a different programming model),\n",
    "created_at": "2022-08-25T14:58:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672095",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:101'></a>
Replying to [tscrim](#comment%3A97):
> However, I would like to know what Xavier thinks about[comment:76](#comment%3A76). The more I see and understand the code, the more I am convinced that you should follow the standard `Parent`-`Element` framework (instead of `Category`-`CategoryObject`). Briefly rereading the above discussion, I am not sure there are any advantages of the current approach other than mathematically the set is generally considered to be a category (which I don't think should play too heavily on the implementation details).


Sorry, because of the holidays, I missed your message.

I'm actually not sure that allowing for implicit coercion is desirable here (and, in any case, it won't probably be useful because we have no addition/multiplication on Drinfeld modules). On the other hand, according to me, it is quite important that the implementation reflects as well as possible the mathematical nature/properties of the objects. So I'm still in favour of using `CategoryObject` and not `Parent`.
But, as I said, if there is a clear preference for the other option, it will be okay with me.

Btw, I'm not sure to understand this argument:
>beyond the technical one of having a specific element class associated to DM (in particular, you won't have to write code that works if I come along with my own implementation of Drinfeld modules using a different programming model),




---

archive/issue_comments_672096.json:
```json
{
    "body": "<a id='comment:102'></a>\nReplying to [gh-DavidAyotte](#comment%3A100):\n> >I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: \"Ok, this is new, this may change, and the author wants complete freedom for doing so\".\n\n> \n> I believe that this would be a bad practice for [SageMath](SageMath) and, more generally, for software development. Our common goal here is to develop a robust end product that the general user can conveniently use. Moreover we want that so called end product to be scalable and last over the time (if not, what's the point?).\n\n\n\nI apologize for omitting this: the tag would be temporary (e.g. up to a year).\nWe agree on the goal; I want to make sure that the first version is as robust\nand scalable as we think it is, which is quite tricky to judge without having\ntested the module in real life for a few months.",
    "created_at": "2022-08-25T16:21:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672096",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:102'></a>
Replying to [gh-DavidAyotte](#comment%3A100):
> >I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: "Ok, this is new, this may change, and the author wants complete freedom for doing so".

> 
> I believe that this would be a bad practice for [SageMath](SageMath) and, more generally, for software development. Our common goal here is to develop a robust end product that the general user can conveniently use. Moreover we want that so called end product to be scalable and last over the time (if not, what's the point?).



I apologize for omitting this: the tag would be temporary (e.g. up to a year).
We agree on the goal; I want to make sure that the first version is as robust
and scalable as we think it is, which is quite tricky to judge without having
tested the module in real life for a few months.



---

archive/issue_comments_672097.json:
```json
{
    "body": "<a id='comment:103'></a>\nReplying to [caruso](#comment%3A101):\n> Replying to [tscrim](#comment%3A97):\n> > However, I would like to know what Xavier thinks about[comment:76](#comment%3A76). The more I see and understand the code, the more I am convinced that you should follow the standard `Parent`-`Element` framework (instead of `Category`-`CategoryObject`). Briefly rereading the above discussion, I am not sure there are any advantages of the current approach other than mathematically the set is generally considered to be a category (which I don't think should play too heavily on the implementation details).\n\n> \n> Sorry, because of the holidays, I missed your message.\n\n\nNo problem.\n\n> I'm actually not sure that allowing for implicit coercion is desirable here (and, in any case, it won't probably be useful because we have no addition/multiplication on Drinfeld modules).\n\n\nIt can help for things like equality (perhaps there is a canonical way to extend something between sets of Drinfeld modules; although I am not sure how this exactly plays with the `UniqueRepresentation`) and conversion (like if it input to a function).\n\n> On the other hand, according to me, it is quite important that the implementation reflects as well as possible the mathematical nature/properties of the objects. So I'm still in favour of using `CategoryObject` and not `Parent`.\n\n\nI find this argument to be fairly weak overall as you can also think of them as ring homomorphisms (which is the preference of the current documentation), there is a clear set (yes, a small category) of such objects as a subset of another, and there is a category of elements implemented in Sage too. However, I tend to defer to what the code is saying. To me, DrinfeldModule is saying \"I want to be an `Element` subclass that belongs to a `Parent` of `DrinfeldModules`\" because it is not implementing any of the usual stuff that a category implements but has pushed it up. For example, the comment `# Somehow required for the class definition` is telling. Basically all other `Category` subclasses in Sage are very lightweight objects (in terms of user implementation), but yours is significantly heavier (like a `Parent`) with lots of attributes and getter methods, a fairly distinguished object (i.e. `Element`) class, and lots of references to properties of the category from the object to name some.\n\n> But, as I said, if there is a clear preference for the other option, it will be okay with me.\n\n\nAnyways, if you aren't convinced, as I promised, I will (try really hard to) stop pushing for it. I just feel it really doesn't reflect what the code is meant to model.\n\n> Btw, I'm not sure to understand this argument:\n> >beyond the technical one of having a specific element class associated to DM (in particular, you won't have to write code that works if I come along with my own implementation of Drinfeld modules using a different programming model),\n\n\nBy being a category, it should allow for me to come along with my own implementation of a Drinfeld module and put it in the category and everything in the category should just work. In other words, there should be no dependency on the implementation of the objects of the category (with the necessary prerequisite implementations be marked as `@abstract_method`).",
    "created_at": "2022-08-26T02:24:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672097",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:103'></a>
Replying to [caruso](#comment%3A101):
> Replying to [tscrim](#comment%3A97):
> > However, I would like to know what Xavier thinks about[comment:76](#comment%3A76). The more I see and understand the code, the more I am convinced that you should follow the standard `Parent`-`Element` framework (instead of `Category`-`CategoryObject`). Briefly rereading the above discussion, I am not sure there are any advantages of the current approach other than mathematically the set is generally considered to be a category (which I don't think should play too heavily on the implementation details).

> 
> Sorry, because of the holidays, I missed your message.


No problem.

> I'm actually not sure that allowing for implicit coercion is desirable here (and, in any case, it won't probably be useful because we have no addition/multiplication on Drinfeld modules).


It can help for things like equality (perhaps there is a canonical way to extend something between sets of Drinfeld modules; although I am not sure how this exactly plays with the `UniqueRepresentation`) and conversion (like if it input to a function).

> On the other hand, according to me, it is quite important that the implementation reflects as well as possible the mathematical nature/properties of the objects. So I'm still in favour of using `CategoryObject` and not `Parent`.


I find this argument to be fairly weak overall as you can also think of them as ring homomorphisms (which is the preference of the current documentation), there is a clear set (yes, a small category) of such objects as a subset of another, and there is a category of elements implemented in Sage too. However, I tend to defer to what the code is saying. To me, DrinfeldModule is saying "I want to be an `Element` subclass that belongs to a `Parent` of `DrinfeldModules`" because it is not implementing any of the usual stuff that a category implements but has pushed it up. For example, the comment `# Somehow required for the class definition` is telling. Basically all other `Category` subclasses in Sage are very lightweight objects (in terms of user implementation), but yours is significantly heavier (like a `Parent`) with lots of attributes and getter methods, a fairly distinguished object (i.e. `Element`) class, and lots of references to properties of the category from the object to name some.

> But, as I said, if there is a clear preference for the other option, it will be okay with me.


Anyways, if you aren't convinced, as I promised, I will (try really hard to) stop pushing for it. I just feel it really doesn't reflect what the code is meant to model.

> Btw, I'm not sure to understand this argument:
> >beyond the technical one of having a specific element class associated to DM (in particular, you won't have to write code that works if I come along with my own implementation of Drinfeld modules using a different programming model),


By being a category, it should allow for me to come along with my own implementation of a Drinfeld module and put it in the category and everything in the category should just work. In other words, there should be no dependency on the implementation of the objects of the category (with the necessary prerequisite implementations be marked as `@abstract_method`).



---

archive/issue_comments_672098.json:
```json
{
    "body": "<a id='comment:104'></a>\nReplying to [antoine-leudiere](#comment%3A102):\n> Replying to [gh-DavidAyotte](#comment%3A100):\n> > >I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: \"Ok, this is new, this may change, and the author wants complete freedom for doing so\".\n\n> > \n> > I believe that this would be a bad practice for [SageMath](SageMath) and, more generally, for software development. Our common goal here is to develop a robust end product that the general user can conveniently use. Moreover we want that so called end product to be scalable and last over the time (if not, what's the point?).\n\n> \n> \n> I apologize for omitting this: the tag would be temporary (e.g. up to a year).\n> We agree on the goal; I want to make sure that the first version is as robust\n> and scalable as we think it is, which is quite tricky to judge without having\n> tested the module in real life for a few months.\n\n\nI also very strongly agree with David on this. These tags, even if temporary (experience tells me people's memory is not that good), is a very bad programming practice. We have standard practices within the community here to deal with API changes to the code. Internal changes can just be changed without warning (all software development basically follows this). If you still feel to need complete freedom to change stuff after a long time developing it, then your development process has a deficiency somewhere.\n\nTL;DR I think one needs a extremely good reason for having production code marked as experimental. You have not provided any justification other than \"it needs to be tested\" (which it is our job, both developers and reviewers, to do so).",
    "created_at": "2022-08-26T02:30:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672098",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:104'></a>
Replying to [antoine-leudiere](#comment%3A102):
> Replying to [gh-DavidAyotte](#comment%3A100):
> > >I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: "Ok, this is new, this may change, and the author wants complete freedom for doing so".

> > 
> > I believe that this would be a bad practice for [SageMath](SageMath) and, more generally, for software development. Our common goal here is to develop a robust end product that the general user can conveniently use. Moreover we want that so called end product to be scalable and last over the time (if not, what's the point?).

> 
> 
> I apologize for omitting this: the tag would be temporary (e.g. up to a year).
> We agree on the goal; I want to make sure that the first version is as robust
> and scalable as we think it is, which is quite tricky to judge without having
> tested the module in real life for a few months.


I also very strongly agree with David on this. These tags, even if temporary (experience tells me people's memory is not that good), is a very bad programming practice. We have standard practices within the community here to deal with API changes to the code. Internal changes can just be changed without warning (all software development basically follows this). If you still feel to need complete freedom to change stuff after a long time developing it, then your development process has a deficiency somewhere.

TL;DR I think one needs a extremely good reason for having production code marked as experimental. You have not provided any justification other than "it needs to be tested" (which it is our job, both developers and reviewers, to do so).



---

archive/issue_comments_672099.json:
```json
{
    "body": "<a id='comment:5'></a>\nAlright.",
    "created_at": "2022-08-26T16:55:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672099",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:5'></a>
Alright.



---

archive/issue_comments_672100.json:
```json
{
    "body": "**Changing commit** from \"[fd9126ca9b005b7f5aaec033cd767769d57b6e2f](https://github.com/sagemath/sagetrac-mirror/commit/fd9126ca9b005b7f5aaec033cd767769d57b6e2f)\" to \"[43c430f273a372e316a0061646f8bd4830837895](https://github.com/sagemath/sagetrac-mirror/commit/43c430f273a372e316a0061646f8bd4830837895)\".",
    "created_at": "2022-08-30T10:35:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672100",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[fd9126ca9b005b7f5aaec033cd767769d57b6e2f](https://github.com/sagemath/sagetrac-mirror/commit/fd9126ca9b005b7f5aaec033cd767769d57b6e2f)" to "[43c430f273a372e316a0061646f8bd4830837895](https://github.com/sagemath/sagetrac-mirror/commit/43c430f273a372e316a0061646f8bd4830837895)".



---

archive/issue_comments_672101.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a9152b7874836e39df5fe0f70b5e0c7009afc3cb\">a9152b7</a></td><td><code>Change validity test in DrinfeldModules method __call__</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/52cb56719bdf0fd54e50424e394cee48ed19f316\">52cb567</a></td><td><code>Remove method __getitem__ in DrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0f3d19ce271008ba521496bdf3db633831ca093a\">0f3d19c</a></td><td><code>Proofread docs in Drinfeld module classes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ea4a843f7832515cd008587e5f1747624f8bee2c\">ea4a843</a></td><td><code>Lint Drinfeld modules code</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5d21c5432cb4386d126b3da1098c7dde40d47683\">5d21c54</a></td><td><code>Change sage.categories.drinfeld_modules title</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/43c430f273a372e316a0061646f8bd4830837895\">43c430f</a></td><td><code>Refactor Drinfeld modules in reference</code></td></tr></table>\n",
    "created_at": "2022-08-30T10:35:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672101",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a9152b7874836e39df5fe0f70b5e0c7009afc3cb">a9152b7</a></td><td><code>Change validity test in DrinfeldModules method __call__</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/52cb56719bdf0fd54e50424e394cee48ed19f316">52cb567</a></td><td><code>Remove method __getitem__ in DrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0f3d19ce271008ba521496bdf3db633831ca093a">0f3d19c</a></td><td><code>Proofread docs in Drinfeld module classes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ea4a843f7832515cd008587e5f1747624f8bee2c">ea4a843</a></td><td><code>Lint Drinfeld modules code</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5d21c5432cb4386d126b3da1098c7dde40d47683">5d21c54</a></td><td><code>Change sage.categories.drinfeld_modules title</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/43c430f273a372e316a0061646f8bd4830837895">43c430f</a></td><td><code>Refactor Drinfeld modules in reference</code></td></tr></table>




---

archive/issue_comments_672102.json:
```json
{
    "body": "<a id='comment:7'></a>\nProofreading, linting and testing are done. Unless further developments on the `Parent` vs `Category` discussion, I think the code can now be reviewed.",
    "created_at": "2022-08-30T10:36:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672102",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:7'></a>
Proofreading, linting and testing are done. Unless further developments on the `Parent` vs `Category` discussion, I think the code can now be reviewed.



---

archive/issue_comments_672103.json:
```json
{
    "body": "<a id='comment:8'></a>\nI only had a chance to take a brief look at the code, but I agree with Travis that this should be `Parent`/`Element`. Nothing much to add to what he explains in[comment:103](#comment%3A103), except to emphasize that `Category` in Sage is a technical framework for managing dynamic `Parent` and `Element` classes. `CategoryObject` is just a low-level technical class - an object that has the notion of a distinguished category and delegates attribute look ups (as in method calls) to that category. Sage is not prepared for `Category` to take on the role of general mathematical categories.",
    "created_at": "2022-08-30T15:54:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672103",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:8'></a>
I only had a chance to take a brief look at the code, but I agree with Travis that this should be `Parent`/`Element`. Nothing much to add to what he explains in[comment:103](#comment%3A103), except to emphasize that `Category` in Sage is a technical framework for managing dynamic `Parent` and `Element` classes. `CategoryObject` is just a low-level technical class - an object that has the notion of a distinguished category and delegates attribute look ups (as in method calls) to that category. Sage is not prepared for `Category` to take on the role of general mathematical categories.



---

archive/issue_comments_672104.json:
```json
{
    "body": "<a id='comment:109'></a>\nReplying to [tscrim](#comment%3A103):\n> It can help for things like equality (perhaps there is a canonical way to extend something between sets of Drinfeld modules; although I am not sure how this exactly plays with the `UniqueRepresentation`) and conversion (like if it input to a function).\n\n\nAgain, I'm not sure that having automatic coercion for equality is a good idea here, in a similar fashion that we don't want to implicitely identify an elliptic curve over `QQ` with its scalar extension to some number field.\n\nBut, as I said, if you all believe that `Parent`/`Element` is better, let switch back to this, I won't argue more.",
    "created_at": "2022-08-30T21:26:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672104",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:109'></a>
Replying to [tscrim](#comment%3A103):
> It can help for things like equality (perhaps there is a canonical way to extend something between sets of Drinfeld modules; although I am not sure how this exactly plays with the `UniqueRepresentation`) and conversion (like if it input to a function).


Again, I'm not sure that having automatic coercion for equality is a good idea here, in a similar fashion that we don't want to implicitely identify an elliptic curve over `QQ` with its scalar extension to some number field.

But, as I said, if you all believe that `Parent`/`Element` is better, let switch back to this, I won't argue more.



---

archive/issue_comments_672105.json:
```json
{
    "body": "<a id='comment:0'></a>\n`Parent`s and `Element`s usually stand for a set and an element in the set; to manipulate an element (`Element`) of the set, one would *first* instantiate the set (`Parent`), and then create elements from the set. This is what the average user expects.\n\nThis is not the way to appreciate Drinfeld modules. In fact, this would be the opposite: Drinfeld modules are instantiated without their category. In most cases, the user will never care about the category. I am sorry if the big list of getters in the category led you to believe otherwise; and the method `__call__` is meant to be for convenience, nothing else. And, we never consider *the set of Drinfeld modules*. This \"set\" is always *the category of Drinfeld modules*. Plus we don't want `phi.category()` to be any category (e.g. a category of ring morphisms); we want it to be the category of Drinfeld modules.\n\nIt is the same for elliptic curves: they are `Parent`s, not `Element`s. Drinfeld modules however do not have elements, hence `CategoryObject`. Many think about Drinfeld modules the same they think about elliptic curves, and rightfully so.\n\nTo me, the `Parent`-`Element` framework does not reflect the mathematical reality.",
    "created_at": "2022-08-31T16:32:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672105",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:0'></a>
`Parent`s and `Element`s usually stand for a set and an element in the set; to manipulate an element (`Element`) of the set, one would *first* instantiate the set (`Parent`), and then create elements from the set. This is what the average user expects.

This is not the way to appreciate Drinfeld modules. In fact, this would be the opposite: Drinfeld modules are instantiated without their category. In most cases, the user will never care about the category. I am sorry if the big list of getters in the category led you to believe otherwise; and the method `__call__` is meant to be for convenience, nothing else. And, we never consider *the set of Drinfeld modules*. This "set" is always *the category of Drinfeld modules*. Plus we don't want `phi.category()` to be any category (e.g. a category of ring morphisms); we want it to be the category of Drinfeld modules.

It is the same for elliptic curves: they are `Parent`s, not `Element`s. Drinfeld modules however do not have elements, hence `CategoryObject`. Many think about Drinfeld modules the same they think about elliptic curves, and rightfully so.

To me, the `Parent`-`Element` framework does not reflect the mathematical reality.



---

archive/issue_comments_672106.json:
```json
{
    "body": "<a id='comment:1'></a>\nIn Sage, a `Polyhedron` is also an `Element`, and their parent is only set up behind the scenes and never touched by users.",
    "created_at": "2022-08-31T16:38:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672106",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:1'></a>
In Sage, a `Polyhedron` is also an `Element`, and their parent is only set up behind the scenes and never touched by users.



---

archive/issue_comments_672107.json:
```json
{
    "body": "<a id='comment:112'></a>\nReplying to [antoine-leudiere](#comment%3A110):\n> `Parent`s and `Element`s usually stand for a set and an element in the set; to manipulate an element (`Element`) of the set, one would *first* instantiate the set (`Parent`), and then create elements from the set. This is what the average user expects.\n\n\nAs Matthias mentionned, there are examples in Sage where you can directly create an element. An other would be the function `Newform` which creates a modular form element:\n\n```\nsage: f = Newform('67a', names='a'); f\nq + 2*q^2 - 2*q^3 + 2*q^4 + 2*q^5 + O(q^6)\nsage: f.parent()\nCuspidal subspace of dimension 5 of Modular Forms space of dimension 6 for Congruence Subgroup Gamma0(67) of weight 2 over Rational Field\n```\nI would be in favor in using the already implemented `Parent`/`Element` framework, especially knowing that there is a category of elements in Sage (as mentionned by Travis in[comment:76](#comment%3A76)). Moreover, as Antoine pointed out, the user will probably never care about the category, so I don't see the advantages of implementing it.\n\nI think that the parent should be the set of all Drinfeld A-modules of rank r over a field F, where A is the function ring and F is an A-field.",
    "created_at": "2022-08-31T16:51:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672107",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:112'></a>
Replying to [antoine-leudiere](#comment%3A110):
> `Parent`s and `Element`s usually stand for a set and an element in the set; to manipulate an element (`Element`) of the set, one would *first* instantiate the set (`Parent`), and then create elements from the set. This is what the average user expects.


As Matthias mentionned, there are examples in Sage where you can directly create an element. An other would be the function `Newform` which creates a modular form element:

```
sage: f = Newform('67a', names='a'); f
q + 2*q^2 - 2*q^3 + 2*q^4 + 2*q^5 + O(q^6)
sage: f.parent()
Cuspidal subspace of dimension 5 of Modular Forms space of dimension 6 for Congruence Subgroup Gamma0(67) of weight 2 over Rational Field
```
I would be in favor in using the already implemented `Parent`/`Element` framework, especially knowing that there is a category of elements in Sage (as mentionned by Travis in[comment:76](#comment%3A76)). Moreover, as Antoine pointed out, the user will probably never care about the category, so I don't see the advantages of implementing it.

I think that the parent should be the set of all Drinfeld A-modules of rank r over a field F, where A is the function ring and F is an A-field.



---

archive/issue_comments_672108.json:
```json
{
    "body": "<a id='comment:113'></a>\nReplying to [antoine-leudiere](#comment%3A110):\n> [...] hence `CategoryObject`. \n\n\nI've explained in[comment:108](#comment%3A108) - `CategoryObject` is just a low-level implementation class, and despite its mathematical-sounding name, it does not model the notion of an \"object in a category\".\n \nIf you look for its uses in the Sage library, you'll see that there are exactly 2 direct uses of it (`IntegrableRepresentation`, `TopologicalVectorBundle`)... and both are mistakes.",
    "created_at": "2022-08-31T17:42:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672108",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:113'></a>
Replying to [antoine-leudiere](#comment%3A110):
> [...] hence `CategoryObject`. 


I've explained in[comment:108](#comment%3A108) - `CategoryObject` is just a low-level implementation class, and despite its mathematical-sounding name, it does not model the notion of an "object in a category".
 
If you look for its uses in the Sage library, you'll see that there are exactly 2 direct uses of it (`IntegrableRepresentation`, `TopologicalVectorBundle`)... and both are mistakes.



---

archive/issue_comments_672109.json:
```json
{
    "body": "<a id='comment:4'></a>\nAlright. `Parent`-`Element` still looks very inadequate; a mathematicians never consider the *category* of Drinfeld modules as a simple set, and would expect the category of Drinfeld modules to be represented as such. Further, having `phi.category()` being the category of elements (or anything else that is not the category of Drinfeld modules) would be quite poor. The adequation between the interface and the mathematical reality must remain a top priority.\n\nFor this reason, I propose `Category` for `DrinfeldModules` and `Parent` for `DrinfeldModule`; like for elliptic curves. I believe this helps with your technical concerns, and we end up with a framework that is representative of the mathematical reality.\n\nFor reference, this is what [SageMath](SageMath) does for elliptic curves:\n\n```\nsage: E = EllipticCurve(QQ, [1, 1])\nsage: E.category()\nCategory of schemes over Rational Field\nsage: isinstance(E.category(), Category)\nTrue\nsage: isinstance(E, Parent)\nTrue\n```",
    "created_at": "2022-09-01T09:38:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672109",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:4'></a>
Alright. `Parent`-`Element` still looks very inadequate; a mathematicians never consider the *category* of Drinfeld modules as a simple set, and would expect the category of Drinfeld modules to be represented as such. Further, having `phi.category()` being the category of elements (or anything else that is not the category of Drinfeld modules) would be quite poor. The adequation between the interface and the mathematical reality must remain a top priority.

For this reason, I propose `Category` for `DrinfeldModules` and `Parent` for `DrinfeldModule`; like for elliptic curves. I believe this helps with your technical concerns, and we end up with a framework that is representative of the mathematical reality.

For reference, this is what [SageMath](SageMath) does for elliptic curves:

```
sage: E = EllipticCurve(QQ, [1, 1])
sage: E.category()
Category of schemes over Rational Field
sage: isinstance(E.category(), Category)
True
sage: isinstance(E, Parent)
True
```



---

archive/issue_comments_672110.json:
```json
{
    "body": "<a id='comment:5'></a>\nAs I have said previously, every set can be made into a category (basically this is the category of elements in the specific `Parent`). Nothing is preventing you from adding stuff to the `Parent` (including in its documentation) to make it act like a category (what would that even be?), but IIRC, none of the actual operations/methods you implemented have it act like a `Category`. Moreover, by your own admission, nobody will likely directly manipulate the category, and thus I think the technical implementation aspects should dominate which base classes to use. As Matthias points out in[comment:108](#comment%3A108), the implementation of `Category` in Sage is not designed to model a general mathematical category.  There are also many things in Sage that play multiple roles; ideals come to mind as they are both `Parent`-like and `Element`-like; it is the latter one the following being an element in the monoid of ideals.\n\nThe combinatorics code also has lots of examples where you can directly create elements.\n\nThe category of elements **is** the category of Drinfeld modules (just with a funny default name). You will still have `isinstance(phi.category(), Category)` return `True`.\n\nElliptic curves is not something you should rely too much on as an example of what to do. IIRC, that is very old code when a lot of the structures that we have nowadays were not there (including categories).",
    "created_at": "2022-09-01T10:00:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672110",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:5'></a>
As I have said previously, every set can be made into a category (basically this is the category of elements in the specific `Parent`). Nothing is preventing you from adding stuff to the `Parent` (including in its documentation) to make it act like a category (what would that even be?), but IIRC, none of the actual operations/methods you implemented have it act like a `Category`. Moreover, by your own admission, nobody will likely directly manipulate the category, and thus I think the technical implementation aspects should dominate which base classes to use. As Matthias points out in[comment:108](#comment%3A108), the implementation of `Category` in Sage is not designed to model a general mathematical category.  There are also many things in Sage that play multiple roles; ideals come to mind as they are both `Parent`-like and `Element`-like; it is the latter one the following being an element in the monoid of ideals.

The combinatorics code also has lots of examples where you can directly create elements.

The category of elements **is** the category of Drinfeld modules (just with a funny default name). You will still have `isinstance(phi.category(), Category)` return `True`.

Elliptic curves is not something you should rely too much on as an example of what to do. IIRC, that is very old code when a lot of the structures that we have nowadays were not there (including categories).



---

archive/issue_comments_672111.json:
```json
{
    "body": "<a id='comment:116'></a>\nReplying to [tscrim](#comment%3A115):\n> As Matthias points out in[comment:108](#comment%3A108), the implementation of `Category` in Sage is not designed to model a general mathematical category.\n\n\nHowever, to be fair here, the Sage reference manual:\n\nhttps://doc.sagemath.org/html/en/reference/categories/sage/categories/primer.html\n\nexplicitely state:\n\n> The purpose of categories in Sage is to translate the mathematical concept of categories (category of groups, of vector spaces, \u2026) into a concrete software [...]\n\n\nand\n\n> A category is a Python instance modelling a mathematical category.\n\n\nNot that it necessarily change my opinion on this discussion, I would be curious in knowing why Sage is not prepared for `Category` to take the role of general mathematical categories. Also, should the reference manual be updated with more accurate information?",
    "created_at": "2022-09-01T12:57:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672111",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:116'></a>
Replying to [tscrim](#comment%3A115):
> As Matthias points out in[comment:108](#comment%3A108), the implementation of `Category` in Sage is not designed to model a general mathematical category.


However, to be fair here, the Sage reference manual:

https://doc.sagemath.org/html/en/reference/categories/sage/categories/primer.html

explicitely state:

> The purpose of categories in Sage is to translate the mathematical concept of categories (category of groups, of vector spaces, …) into a concrete software [...]


and

> A category is a Python instance modelling a mathematical category.


Not that it necessarily change my opinion on this discussion, I would be curious in knowing why Sage is not prepared for `Category` to take the role of general mathematical categories. Also, should the reference manual be updated with more accurate information?



---

archive/issue_comments_672112.json:
```json
{
    "body": "<a id='comment:7'></a>\nBe careful about the difference between a general paradigm (lowercase \u201ccategories\u201d) and a specific implementation (the class `Category`). In this case, the framework is built around dealing with requisite properties and constructions, not about setting a class (in the mathematical sense of large categories) of objects and their morphisms explicitly, as well as more larger scale properties (e.g., the billion adjectives a category theorist knows such as triangulated). We can model a mathematical category using other implementations that are better equipped for their purpose (such as a diagrammatic category using the partition algebra).\n\nI should also point out that you have cherry-picked your first quote and left off the rest of it that provides some really important context that changes the intent within Sage. They are designed for reducing code duplication and to carry some generic mathematical information (such as what operations should be there with what axioms). Note also in your second quote, it is lower case and says these are examples, not that everything modeling a category needs to be a subclass of `Category`. These are somewhat subtle points though.",
    "created_at": "2022-09-01T13:11:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672112",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:7'></a>
Be careful about the difference between a general paradigm (lowercase “categories”) and a specific implementation (the class `Category`). In this case, the framework is built around dealing with requisite properties and constructions, not about setting a class (in the mathematical sense of large categories) of objects and their morphisms explicitly, as well as more larger scale properties (e.g., the billion adjectives a category theorist knows such as triangulated). We can model a mathematical category using other implementations that are better equipped for their purpose (such as a diagrammatic category using the partition algebra).

I should also point out that you have cherry-picked your first quote and left off the rest of it that provides some really important context that changes the intent within Sage. They are designed for reducing code duplication and to carry some generic mathematical information (such as what operations should be there with what axioms). Note also in your second quote, it is lower case and says these are examples, not that everything modeling a category needs to be a subclass of `Category`. These are somewhat subtle points though.



---

archive/issue_comments_672113.json:
```json
{
    "body": "<a id='comment:118'></a>\nReplying to [tscrim](#comment%3A117):\n\nOkay, I understand the nuance. As you said it is subtle, but it is still there. Thank you very much for the explanations!",
    "created_at": "2022-09-01T13:25:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672113",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:118'></a>
Replying to [tscrim](#comment%3A117):

Okay, I understand the nuance. As you said it is subtle, but it is still there. Thank you very much for the explanations!



---

archive/issue_comments_672114.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** Last 10 new commits:\n|                                                                                                                                           |                                                        |\n|-------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------|\n|[cfad960](https://github.com/sagemath/sagetrac-mirror/commit/cfad9600155f0c1ae0cc95c83cc86f9a3b464bed)|`Use Parent instead of CategoryObject in DrinfeldModule`|\n|[dbcbaf7](https://github.com/sagemath/sagetrac-mirror/commit/dbcbaf74fc617f8605466fce3223abccc8874053)|`Implement base_ring in DrinfeldModule`|\n|[771f406](https://github.com/sagemath/sagetrac-mirror/commit/771f406ec3e9d4fb0317da89af4b3b0abc2bf788)|`Use Category_over_base instead of CategoryWithParameters for DrinfeldModules`|\n|[674faeb](https://github.com/sagemath/sagetrac-mirror/commit/674faeb30a406932eb67c44a126b561a7cf03e3a)|`Make DrinfeldModuleMorphism inherit Morphism`|\n|[71a6b4a](https://github.com/sagemath/sagetrac-mirror/commit/71a6b4aec9c8e2cee386945b02439293097d93e6)|`Merge branch 'develop' into public/drinfeld_module`|\n|[d597953](https://github.com/sagemath/sagetrac-mirror/commit/d597953e9c51bd2474c263d7c0c49730511125f0)|`Remove methods ore_variable from Drinfeld module classes`|\n|[2ca2183](https://github.com/sagemath/sagetrac-mirror/commit/2ca21832b445169e246edce63498f01e53f76a42)|<code>Remove `class ElementMethods` from DrinfeldModules</code>|\n|[15efff9](https://github.com/sagemath/sagetrac-mirror/commit/15efff9de6413a48c7f8bf000466c341485fb4d2)|`(Fix) Add doc of morphism method in DrinfeldModule`|\n|[2e77452](https://github.com/sagemath/sagetrac-mirror/commit/2e7745256a9c152d975b77de812bb31efed9414d)|`Enhance base and base ring distinctions in doc`|\n|[4412ad1](https://github.com/sagemath/sagetrac-mirror/commit/4412ad191092e9d5bab82d1ad73a669dc83d6f96)|`Move 'category methods' from DrinfeldModule to DrinfeldModules`|",
    "created_at": "2022-09-09T10:58:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672114",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** Last 10 new commits:
|                                                                                                                                           |                                                        |
|-------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------|
|[cfad960](https://github.com/sagemath/sagetrac-mirror/commit/cfad9600155f0c1ae0cc95c83cc86f9a3b464bed)|`Use Parent instead of CategoryObject in DrinfeldModule`|
|[dbcbaf7](https://github.com/sagemath/sagetrac-mirror/commit/dbcbaf74fc617f8605466fce3223abccc8874053)|`Implement base_ring in DrinfeldModule`|
|[771f406](https://github.com/sagemath/sagetrac-mirror/commit/771f406ec3e9d4fb0317da89af4b3b0abc2bf788)|`Use Category_over_base instead of CategoryWithParameters for DrinfeldModules`|
|[674faeb](https://github.com/sagemath/sagetrac-mirror/commit/674faeb30a406932eb67c44a126b561a7cf03e3a)|`Make DrinfeldModuleMorphism inherit Morphism`|
|[71a6b4a](https://github.com/sagemath/sagetrac-mirror/commit/71a6b4aec9c8e2cee386945b02439293097d93e6)|`Merge branch 'develop' into public/drinfeld_module`|
|[d597953](https://github.com/sagemath/sagetrac-mirror/commit/d597953e9c51bd2474c263d7c0c49730511125f0)|`Remove methods ore_variable from Drinfeld module classes`|
|[2ca2183](https://github.com/sagemath/sagetrac-mirror/commit/2ca21832b445169e246edce63498f01e53f76a42)|<code>Remove `class ElementMethods` from DrinfeldModules</code>|
|[15efff9](https://github.com/sagemath/sagetrac-mirror/commit/15efff9de6413a48c7f8bf000466c341485fb4d2)|`(Fix) Add doc of morphism method in DrinfeldModule`|
|[2e77452](https://github.com/sagemath/sagetrac-mirror/commit/2e7745256a9c152d975b77de812bb31efed9414d)|`Enhance base and base ring distinctions in doc`|
|[4412ad1](https://github.com/sagemath/sagetrac-mirror/commit/4412ad191092e9d5bab82d1ad73a669dc83d6f96)|`Move 'category methods' from DrinfeldModule to DrinfeldModules`|



---

archive/issue_comments_672115.json:
```json
{
    "body": "**Changing commit** from \"[43c430f273a372e316a0061646f8bd4830837895](https://github.com/sagemath/sagetrac-mirror/commit/43c430f273a372e316a0061646f8bd4830837895)\" to \"[4412ad191092e9d5bab82d1ad73a669dc83d6f96](https://github.com/sagemath/sagetrac-mirror/commit/4412ad191092e9d5bab82d1ad73a669dc83d6f96)\".",
    "created_at": "2022-09-09T10:58:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672115",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[43c430f273a372e316a0061646f8bd4830837895](https://github.com/sagemath/sagetrac-mirror/commit/43c430f273a372e316a0061646f8bd4830837895)" to "[4412ad191092e9d5bab82d1ad73a669dc83d6f96](https://github.com/sagemath/sagetrac-mirror/commit/4412ad191092e9d5bab82d1ad73a669dc83d6f96)".



---

archive/issue_comments_672116.json:
```json
{
    "body": "<a id='comment:0'></a>\nSummary of the changes:\n- `DrinfeldModule` is a `Parent`.\n- `DrinfeldModules` is a `Category_over_base` (used to be `CategoryWithParameters`).\n- `DrinfeldModuleMorphism` now inherits `Morphism`, which is possible because `DrinfeldModule` is a `Parent`.\n- I removed the method `__call__` in `DrinfeldModules` to emphasize that this class should not be a `Parent`.\n- The base of the category is not a field `K` anymore, but rather the ring morphism `\\gamma: \\Fq[X] \\to K`. The former was misleading and ambiguous.\n- I removed the method `change_ring` in `DrinfeldModule`, as the new paradigm is to consider a base morphism and not a base ring.\n- Getters of `DrinfeldModule` that corresponded to getters of the category were moved to the `class ParentMethods` part of the category.\n- I removed some useless getters like `ore_variable`.\n\nDoc is updated and tests pass. I am happy with the code, it is ready for review.",
    "created_at": "2022-09-09T11:00:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672116",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:0'></a>
Summary of the changes:
- `DrinfeldModule` is a `Parent`.
- `DrinfeldModules` is a `Category_over_base` (used to be `CategoryWithParameters`).
- `DrinfeldModuleMorphism` now inherits `Morphism`, which is possible because `DrinfeldModule` is a `Parent`.
- I removed the method `__call__` in `DrinfeldModules` to emphasize that this class should not be a `Parent`.
- The base of the category is not a field `K` anymore, but rather the ring morphism `\gamma: \Fq[X] \to K`. The former was misleading and ambiguous.
- I removed the method `change_ring` in `DrinfeldModule`, as the new paradigm is to consider a base morphism and not a base ring.
- Getters of `DrinfeldModule` that corresponded to getters of the category were moved to the `class ParentMethods` part of the category.
- I removed some useless getters like `ore_variable`.

Doc is updated and tests pass. I am happy with the code, it is ready for review.



---

archive/issue_comments_672117.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,3 +1,7 @@\n+**EDIT (2022-09-09). *A lot has changed since this first comment; interface and implementation details are vastly different.***\n+\n+---\n+\n I would like to propose an implementation for *finite Drinfeld modules*. I\n opened this ticket to discuss this idea and have feedback on implementation\n directions, in order to comply with Sage's guidelines. Please feel free to express any doubt or criticism, or give ideas! I very much value the collaborative aspect of the [SageMath](SageMath) community.\n``````\n",
    "created_at": "2022-09-09T11:03:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672117",
    "user": "https://github.com/antoine-leudiere"
}
```


**Description changed:**
``````diff
--- 
+++ 
@@ -1,3 +1,7 @@
+**EDIT (2022-09-09). *A lot has changed since this first comment; interface and implementation details are vastly different.***
+
+---
+
 I would like to propose an implementation for *finite Drinfeld modules*. I
 opened this ticket to discuss this idea and have feedback on implementation
 directions, in order to comply with Sage's guidelines. Please feel free to express any doubt or criticism, or give ideas! I very much value the collaborative aspect of the [SageMath](SageMath) community.
``````




---

archive/issue_comments_672118.json:
```json
{
    "body": "**Changing status** from new to needs_review.",
    "created_at": "2022-09-09T11:03:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672118",
    "user": "https://github.com/antoine-leudiere"
}
```


**Changing status** from new to needs_review.



---

archive/issue_comments_672119.json:
```json
{
    "body": "<a id='comment:3'></a>\nI'm still reviewing the file `drinfeld_module.py`:\n\n* In the documentation of `DrinfeldModule`, you mention the terminology \"function ring\" before defining it:\n\n```\n    A *Drinfeld `\\Fq[X]`-module over the base `\\gamma`* is an\n    `\\Fq`-algebra morphism `\\phi: \\Fq[X] \\to K\\{\\tau\\}` such that:\n\n        1. The image of `\\phi` contains non-constant Ore polynomials.\n        2. For every element `a` in the function ring, the constant\n           coefficient `\\phi(a)` is `\\gamma(a)`.\n\n    For `a` in the function ring, `\\phi(a)` is denoted `\\phi_a`.\n\n    The Drinfeld module `\\phi` is uniquely determined by the image\n    `\\phi_X` of `X`, which is an input of the class.\n\n    We say that `\\Fq[X]` is the *function ring of `\\phi`*; *K\\{\\tau\\}*\n    is the *Ore polynomial ring of `\\phi`*.\n```\n\n* Suggestion + typo, lines 205 - 206:\n\n```diff\n+     The Drinfeld modules `\\phi` and `\\rho` have different base. That of\n+    `\\phi` is surjective while that of `\\rho` is not::\n-     Drinfeld modules `\\phi` and `\\rho` have different based. That of\n-    `\\phi` is surjective while that of `\\rho` is note::\n```\n* Typo, line 430 of `drinfeld_module.py`:\n\n```diff\n    .. NOTE::\n\n+        In this implementation, `L` is `K`.\n-        In this implementation, `L` is `L`.\n```\n* On[comment:88](#comment%3A88), I mentionned that I don't think that this `if` statement (lines 520 - 522) is necessary:\n\n```python\n        # Check gen as Ore polynomial\n        if ore_polring is not None and \\\n                ore_polring != category.ore_polring():\n            raise ValueError(f'generator must lie in {category.ore_polring()}')\n```\n    You still haven't addressed that, even though you made the change proposed by Travis in[comment:90](#comment%3A90). After testing  bit your code, I wasn't able to recreate the `ValueError` you raise. However, if this `if` statement is really necessary, you should make a doctest in order to test it. Also, looking at your code, I hardly see why the test `ore_polring != category.ore_polring()` could be true as `category` is constructed using `ore_polring`.\n\n* Small latex suggestion, line 712:\n\n```diff\n+    Return the `n`-th coefficient of the generator.\n-    Return the n-th coefficient of the generator.\n```\n\n* Whenever you have a private class attribute with an associated method, instead of calling the method, you can directly access the attribute:\n\n    Line 1053\n\n```diff\n+        return self._gen.degree()\n-        return self.gen().degree()\n```\n\n* Suggestion: a lot of your examples and tests are made using Drinfeld modules over a `Fq[X]`-field of finite characteristic. I think, for better coverage, it would be good to add some examples of Drinfeld modules over `Fq[X]`-fields of generic characteristic. In my opinion, this would better emphasize the fact that your implementation does not only work for finite Drinfeld modules.",
    "created_at": "2022-09-09T15:15:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672119",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:3'></a>
I'm still reviewing the file `drinfeld_module.py`:

* In the documentation of `DrinfeldModule`, you mention the terminology "function ring" before defining it:

```
    A *Drinfeld `\Fq[X]`-module over the base `\gamma`* is an
    `\Fq`-algebra morphism `\phi: \Fq[X] \to K\{\tau\}` such that:

        1. The image of `\phi` contains non-constant Ore polynomials.
        2. For every element `a` in the function ring, the constant
           coefficient `\phi(a)` is `\gamma(a)`.

    For `a` in the function ring, `\phi(a)` is denoted `\phi_a`.

    The Drinfeld module `\phi` is uniquely determined by the image
    `\phi_X` of `X`, which is an input of the class.

    We say that `\Fq[X]` is the *function ring of `\phi`*; *K\{\tau\}*
    is the *Ore polynomial ring of `\phi`*.
```

* Suggestion + typo, lines 205 - 206:

```diff
+     The Drinfeld modules `\phi` and `\rho` have different base. That of
+    `\phi` is surjective while that of `\rho` is not::
-     Drinfeld modules `\phi` and `\rho` have different based. That of
-    `\phi` is surjective while that of `\rho` is note::
```
* Typo, line 430 of `drinfeld_module.py`:

```diff
    .. NOTE::

+        In this implementation, `L` is `K`.
-        In this implementation, `L` is `L`.
```
* On[comment:88](#comment%3A88), I mentionned that I don't think that this `if` statement (lines 520 - 522) is necessary:

```python
        # Check gen as Ore polynomial
        if ore_polring is not None and \
                ore_polring != category.ore_polring():
            raise ValueError(f'generator must lie in {category.ore_polring()}')
```
    You still haven't addressed that, even though you made the change proposed by Travis in[comment:90](#comment%3A90). After testing  bit your code, I wasn't able to recreate the `ValueError` you raise. However, if this `if` statement is really necessary, you should make a doctest in order to test it. Also, looking at your code, I hardly see why the test `ore_polring != category.ore_polring()` could be true as `category` is constructed using `ore_polring`.

* Small latex suggestion, line 712:

```diff
+    Return the `n`-th coefficient of the generator.
-    Return the n-th coefficient of the generator.
```

* Whenever you have a private class attribute with an associated method, instead of calling the method, you can directly access the attribute:

    Line 1053

```diff
+        return self._gen.degree()
-        return self.gen().degree()
```

* Suggestion: a lot of your examples and tests are made using Drinfeld modules over a `Fq[X]`-field of finite characteristic. I think, for better coverage, it would be good to add some examples of Drinfeld modules over `Fq[X]`-fields of generic characteristic. In my opinion, this would better emphasize the fact that your implementation does not only work for finite Drinfeld modules.



---

archive/issue_comments_672120.json:
```json
{
    "body": "<a id='comment:4'></a>\nAll you\u2019ve done is put lipstick on a pig with your changes, and like that mental image suggests, things are worse and scarier than before without make any fundamental changes:\n\n- You have a `Parent` without an `Element` and the category is still acting like a parent.\n- A morphism is not a ring. So the category is the wrong base class.\n- `DrinfeldModules` should have a way to build its elements through `DrinfeldModules(foo)`.\n- You are significantly abusing the input of the morphism parent with it not being a homset (both mathematically (as I understand it) and practically).\n\nWhat I think would be the way forward:\n\n- `DrinfeldModules` should be a `Parent` (possibly of a `Homset`).\n- `DrinfeldModule` should be a subclass of `Element` (possibly of a `RingHomomorphism`).\n- There is a new category of `DrinfeldModulesCategory` that is returned by the `category()`.\n- You want a new parent that is a subclass of `Homset` for the Drinfeld module morphisms.\n\nEven if you are insistent on using `CategoryObject`, you have a number of issues to fix to get the hog ready for sale at the market.\n\n(PS - I am not meaning to use swine as a negative, it just fit the idiom. They are delicious, an important commodity, and can be quite cute.)",
    "created_at": "2022-09-10T01:06:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672120",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:4'></a>
All you’ve done is put lipstick on a pig with your changes, and like that mental image suggests, things are worse and scarier than before without make any fundamental changes:

- You have a `Parent` without an `Element` and the category is still acting like a parent.
- A morphism is not a ring. So the category is the wrong base class.
- `DrinfeldModules` should have a way to build its elements through `DrinfeldModules(foo)`.
- You are significantly abusing the input of the morphism parent with it not being a homset (both mathematically (as I understand it) and practically).

What I think would be the way forward:

- `DrinfeldModules` should be a `Parent` (possibly of a `Homset`).
- `DrinfeldModule` should be a subclass of `Element` (possibly of a `RingHomomorphism`).
- There is a new category of `DrinfeldModulesCategory` that is returned by the `category()`.
- You want a new parent that is a subclass of `Homset` for the Drinfeld module morphisms.

Even if you are insistent on using `CategoryObject`, you have a number of issues to fix to get the hog ready for sale at the market.

(PS - I am not meaning to use swine as a negative, it just fit the idiom. They are delicious, an important commodity, and can be quite cute.)



---

archive/issue_comments_672121.json:
```json
{
    "body": "<a id='comment:5'></a>\nStrong **+1** to everything Travis said. \n\nOur mathematician minds likes to think that a parent is the same as an object in a category (me included, especially with Drinfeld modules), however, the Python programming reality is that one should use the framework which is best suited for the situation. The `Parent/Element` framework should always come as pair: a **parent** which contains **elements**. Therefore, if you only implement a parent without any elements, you are using the wrong framework.\n\nOn an unrelated note, I'm pretty sure this deleted line is not intentional:\n\n```diff\ndiff --git a/src/sage/rings/function_field/all.py b/src/sage/rings/function_field/all.py\nindex b6bba33..6904f3e 100644\n--- a/src/sage/rings/function_field/all.py\n+++ b/src/sage/rings/function_field/all.py\n@@ -1 +1 @@\n-from .constructor import FunctionField\n+from .drinfeld_modules.all import *\n```\n\nThis removes the class `FunctionField` from the global namespace and it is probably why there are so many failed [doctests](https://github.com/sagemath/sagetrac-mirror/runs/8268621152?check_suite_focus=true).",
    "created_at": "2022-09-10T03:04:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672121",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:5'></a>
Strong **+1** to everything Travis said. 

Our mathematician minds likes to think that a parent is the same as an object in a category (me included, especially with Drinfeld modules), however, the Python programming reality is that one should use the framework which is best suited for the situation. The `Parent/Element` framework should always come as pair: a **parent** which contains **elements**. Therefore, if you only implement a parent without any elements, you are using the wrong framework.

On an unrelated note, I'm pretty sure this deleted line is not intentional:

```diff
diff --git a/src/sage/rings/function_field/all.py b/src/sage/rings/function_field/all.py
index b6bba33..6904f3e 100644
--- a/src/sage/rings/function_field/all.py
+++ b/src/sage/rings/function_field/all.py
@@ -1 +1 @@
-from .constructor import FunctionField
+from .drinfeld_modules.all import *
```

This removes the class `FunctionField` from the global namespace and it is probably why there are so many failed [doctests](https://github.com/sagemath/sagetrac-mirror/runs/8268621152?check_suite_focus=true).



---

archive/issue_comments_672122.json:
```json
{
    "body": "<a id='comment:126'></a>\nReplying to [Travis Scrimshaw](#comment%3A124):\n> What I think would be the way forward:\n> - `DrinfeldModules` should be a `Parent` (possibly of a `Homset`).\n> - `DrinfeldModule` should be a subclass of `Element` (possibly of a `RingHomomorphism`).\n> - There is a new category of `DrinfeldModulesCategory` that is returned by the `category()`.\n> - You want a new parent that is a subclass of `Homset` for the Drinfeld module morphisms.\n\n\nI agree that, if we move to the `Parent`/`Element` paradigm, we should define a parent (the set of Drinfeld modules) having elements (the Drinfeld modules).\n\nHowever, what is the category (and I strongly believe that there should be a category because we want to handle morphisms)? Of course, it has to be the category of Drinfeld modules. But it is redundant with the parent (btw, should the constructor of the category just take the parent as input?). Besides, regarding notations, all the categories in `sage.categories` are called `Foobars` and never `FoobarsCategory`.\n\nTo be honest, I'm a bit embarassed with this because it will certainly cause confusion. Probably not so much, actually, because the user will basically never see the parent, nor the category. However, the sword of Damocles is here.\n\nIn a previous comment, I remember that David suggested to include the rank of the Drinfeld module in the parent. I'm not in favor of this because if we insist on viewing Drinfeld modules as morphisms `phi : Fq[X] -> L{tau}`, I can't see why it could be relevant to have different parents according to the degree of `phi(X)`. (We don't have specific parents for Ore polynomials of given degrees.)",
    "created_at": "2022-09-10T07:30:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672122",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:126'></a>
Replying to [Travis Scrimshaw](#comment%3A124):
> What I think would be the way forward:
> - `DrinfeldModules` should be a `Parent` (possibly of a `Homset`).
> - `DrinfeldModule` should be a subclass of `Element` (possibly of a `RingHomomorphism`).
> - There is a new category of `DrinfeldModulesCategory` that is returned by the `category()`.
> - You want a new parent that is a subclass of `Homset` for the Drinfeld module morphisms.


I agree that, if we move to the `Parent`/`Element` paradigm, we should define a parent (the set of Drinfeld modules) having elements (the Drinfeld modules).

However, what is the category (and I strongly believe that there should be a category because we want to handle morphisms)? Of course, it has to be the category of Drinfeld modules. But it is redundant with the parent (btw, should the constructor of the category just take the parent as input?). Besides, regarding notations, all the categories in `sage.categories` are called `Foobars` and never `FoobarsCategory`.

To be honest, I'm a bit embarassed with this because it will certainly cause confusion. Probably not so much, actually, because the user will basically never see the parent, nor the category. However, the sword of Damocles is here.

In a previous comment, I remember that David suggested to include the rank of the Drinfeld module in the parent. I'm not in favor of this because if we insist on viewing Drinfeld modules as morphisms `phi : Fq[X] -> L{tau}`, I can't see why it could be relevant to have different parents according to the degree of `phi(X)`. (We don't have specific parents for Ore polynomials of given degrees.)



---

archive/issue_comments_672123.json:
```json
{
    "body": "<a id='comment:127'></a>\nReplying to [Xavier Caruso](#comment%3A126):\n> Replying to [Travis Scrimshaw](#comment%3A124):\n> > What I think would be the way forward:\n> > - `DrinfeldModules` should be a `Parent` (possibly of a `Homset`).\n> > - `DrinfeldModule` should be a subclass of `Element` (possibly of a `RingHomomorphism`).\n> > - There is a new category of `DrinfeldModulesCategory` that is returned by the `category()`.\n> > - You want a new parent that is a subclass of `Homset` for the Drinfeld module morphisms.\n \n> \n> I agree that, if we move to the `Parent`/`Element` paradigm, we should define a parent (the set of Drinfeld modules) having elements (the Drinfeld modules).\n> \n> However, what is the category (and I strongly believe that there should be a category because we want to handle morphisms)? Of course, it has to be the category of Drinfeld modules. But it is redundant with the parent (btw, should the constructor of the category just take the parent as input?).\n\n\nI can make a category out of any set (Sage even lets me do this and even create morphisms between them too!). Moreover, you do not have to implement anything here (most likely): There is a default class for categories of elements. You're wanting to break a lot of established coding paradigms in Sage for the mathematical purity of one particular viewpoint.\n\n> Besides, regarding notations, all the categories in `sage.categories` are called `Foobars` and never `FoobarsCategory`.\n\n\nI should have made it clear this was a placeholder name and may not have to be implemented so that there wouldn't be confusion. I was running out the door as I was finishing my post. Sorry about that.\n\n> To be honest, I'm a bit embarassed with this because it will certainly cause confusion. Probably not so much, actually, because the user will basically never see the parent, nor the category. However, the sword of Damocles is here.\n\n\nWe have this actually all over Sage and it has never caused confusion. Many objects carry multiple ways of looking at them, and those sometimes carry different implementations. An example would be matrices/linear maps. To bring in another weapon, I think you're tiling at windmills here.\n\nEDIT - Another example is the category of bases of an algebra, e.g., symmetric functions. In contrast to the case here, (IMO) most people actually just think of this as a set and don't think of the equality of elements as being morphisms, but they are because we have a distinguished basis (this would be like a change of basepoint for homotopoy groups). Furthermore, those parents actually have elements as well.",
    "created_at": "2022-09-10T08:16:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672123",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:127'></a>
Replying to [Xavier Caruso](#comment%3A126):
> Replying to [Travis Scrimshaw](#comment%3A124):
> > What I think would be the way forward:
> > - `DrinfeldModules` should be a `Parent` (possibly of a `Homset`).
> > - `DrinfeldModule` should be a subclass of `Element` (possibly of a `RingHomomorphism`).
> > - There is a new category of `DrinfeldModulesCategory` that is returned by the `category()`.
> > - You want a new parent that is a subclass of `Homset` for the Drinfeld module morphisms.
 
> 
> I agree that, if we move to the `Parent`/`Element` paradigm, we should define a parent (the set of Drinfeld modules) having elements (the Drinfeld modules).
> 
> However, what is the category (and I strongly believe that there should be a category because we want to handle morphisms)? Of course, it has to be the category of Drinfeld modules. But it is redundant with the parent (btw, should the constructor of the category just take the parent as input?).


I can make a category out of any set (Sage even lets me do this and even create morphisms between them too!). Moreover, you do not have to implement anything here (most likely): There is a default class for categories of elements. You're wanting to break a lot of established coding paradigms in Sage for the mathematical purity of one particular viewpoint.

> Besides, regarding notations, all the categories in `sage.categories` are called `Foobars` and never `FoobarsCategory`.


I should have made it clear this was a placeholder name and may not have to be implemented so that there wouldn't be confusion. I was running out the door as I was finishing my post. Sorry about that.

> To be honest, I'm a bit embarassed with this because it will certainly cause confusion. Probably not so much, actually, because the user will basically never see the parent, nor the category. However, the sword of Damocles is here.


We have this actually all over Sage and it has never caused confusion. Many objects carry multiple ways of looking at them, and those sometimes carry different implementations. An example would be matrices/linear maps. To bring in another weapon, I think you're tiling at windmills here.

EDIT - Another example is the category of bases of an algebra, e.g., symmetric functions. In contrast to the case here, (IMO) most people actually just think of this as a set and don't think of the equality of elements as being morphisms, but they are because we have a distinguished basis (this would be like a change of basepoint for homotopoy groups). Furthermore, those parents actually have elements as well.



---

archive/issue_comments_672124.json:
```json
{
    "body": "<a id='comment:128'></a>\nReplying to [Travis Scrimshaw](#comment%3A127):\n> I can make a category out of any set (Sage even lets me do this and even create morphisms between them too!). Moreover, you do not have to implement anything here (most likely): There is a default class for categories of elements.\n\n\nAh okay.",
    "created_at": "2022-09-10T09:58:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672124",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:128'></a>
Replying to [Travis Scrimshaw](#comment%3A127):
> I can make a category out of any set (Sage even lets me do this and even create morphisms between them too!). Moreover, you do not have to implement anything here (most likely): There is a default class for categories of elements.


Ah okay.



---

archive/issue_comments_672125.json:
```json
{
    "body": "<a id='comment:129'></a>\nReplying to [Xavier Caruso](#comment%3A126):\n> In a previous comment, I remember that David suggested to include the rank of the Drinfeld module in the parent. I'm not in favor of this because if we insist on viewing Drinfeld modules as morphisms `phi : Fq[X] -> L{tau}`, I can't see why it could be relevant to have different parents according to the degree of `phi(X)`. (We don't have specific parents for Ore polynomials of given degrees.)\n\n\nFrom the literature, people usually consider the category of Drinfeld modules of fixed rank with morphism being the isogenies (isogenous Drinfeld modules must have the same rank). This is the reason why I mentioned this, and, honestly, I don't have a very strong opinion about this, except that it would be closer to the maths. Thus, I don't think it would be much of a problem to consider the parent of all Drinfeld modules of arbitrary ranks and I would be in favor of using any approach which is better from a programming viewpoint. I'm guessing here that if we don't include the rank in the parent, there would probably be less unecessary creation of different parents (with only the ranks varying).",
    "created_at": "2022-09-10T14:09:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672125",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:129'></a>
Replying to [Xavier Caruso](#comment%3A126):
> In a previous comment, I remember that David suggested to include the rank of the Drinfeld module in the parent. I'm not in favor of this because if we insist on viewing Drinfeld modules as morphisms `phi : Fq[X] -> L{tau}`, I can't see why it could be relevant to have different parents according to the degree of `phi(X)`. (We don't have specific parents for Ore polynomials of given degrees.)


From the literature, people usually consider the category of Drinfeld modules of fixed rank with morphism being the isogenies (isogenous Drinfeld modules must have the same rank). This is the reason why I mentioned this, and, honestly, I don't have a very strong opinion about this, except that it would be closer to the maths. Thus, I don't think it would be much of a problem to consider the parent of all Drinfeld modules of arbitrary ranks and I would be in favor of using any approach which is better from a programming viewpoint. I'm guessing here that if we don't include the rank in the parent, there would probably be less unecessary creation of different parents (with only the ranks varying).



---

archive/issue_comments_672126.json:
```json
{
    "body": "<a id='comment:0'></a>\nI'm trying to re-implement this ticket along the lines proposed by Travis.\n\nAnd I realized that the fact that a Drinfeld module is not a parent causes a lot of headache when we are coming to morphisms between Drinfeld modules; indeed, this roughly prevents from inheriting from `Morphism` becomes this class implicity assumes everywhere that the domain and the codomain are parents (typically, the cython attributes `_domain` and `_codomain` are declared to be parents).\n\nThe right solution would probably be to have a general class for morphisms in a category (whose elements are not parents and which cannot be necessarily callable). However, it does not exist (correct me if I'm wrong) and it's not the purpose of this ticket to implement it (and btw, I don't really have the courage to do it now).\n\nIn order to go ahead, I see two options:\n- either we stay with the current implement and let Drinfeld modules be parents,\n- or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).\n\nWhat's your opinion? (Or do you see another solution?)",
    "created_at": "2022-09-13T16:18:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672126",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:0'></a>
I'm trying to re-implement this ticket along the lines proposed by Travis.

And I realized that the fact that a Drinfeld module is not a parent causes a lot of headache when we are coming to morphisms between Drinfeld modules; indeed, this roughly prevents from inheriting from `Morphism` becomes this class implicity assumes everywhere that the domain and the codomain are parents (typically, the cython attributes `_domain` and `_codomain` are declared to be parents).

The right solution would probably be to have a general class for morphisms in a category (whose elements are not parents and which cannot be necessarily callable). However, it does not exist (correct me if I'm wrong) and it's not the purpose of this ticket to implement it (and btw, I don't really have the courage to do it now).

In order to go ahead, I see two options:
- either we stay with the current implement and let Drinfeld modules be parents,
- or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).

What's your opinion? (Or do you see another solution?)



---

archive/issue_comments_672127.json:
```json
{
    "body": "<a id='comment:131'></a>\nReplying to [Travis Scrimshaw](#comment%3A124):\n> All you\u2019ve done is put lipstick on a pig with your changes, and like that\n> mental image suggests, things are worse and scarier than before without make\n> any fundamental changes: \n\n\nNo, you are wrong, all Antoine has done is not just \"put lipstick on a pig\".\n\n> What I think would be the way forward:\n\n>\n>   - `DrinfeldModules` should be a Parent (possibly of a Homset).\n>   - `DrinfeldModule` should be a subclass of Element (possibly of a `RingHomomorphism`).\n>   - There is a new category of `DrinfeldModulesCategory` that is returned by the category().\n>   - You want a new parent that is a subclass of Homset for the Drinfeld module morphisms. \n\n\nI disagree with Travis' suggestions. The main reason is that I believe\nthat a class implementing Drinfeld modules should not be a subclass of a class\nimplementing ring morphisms, because this fails to capture correctly the notion\nof morphisms of Drinfeld modules.\n\nTo be a bit clearer, let's look at a similar situation for elliptic curves.\nElliptic curves are most often constructed from a bivariate polynomial\n`y<sup>2-x</sup>3-a*x-b` and this is how they are often stored and manipulated. However,\nit would be misleading to say that an elliptic curve *is* a bivariate\npolynomial. More precisely, an elliptic curve should not be seen as an element\nof the ring of bivariate polynomials; it is just a way to construct and to\nmanipulate it. This is why it is often said that an elliptic curve *is defined\nby* such a polynomial, but not that it *is* such a polynomial.\n\nThe reason for this is that polynomials fail to capture correctly the notion of\nmorphisms of elliptic curves. And this is why implementing elliptic curves as a\nsubclass of a class implementing bivariate polynomials would be very confusing.\n\nThe situation is similar for Drinfeld modules. In maths, it is said that a\nDrinfeld module *is* a ring morphism, but I believe that it would be less\nconfusing to say that it *is defined by* a ring morphism, as in the case of\nelliptic curves.\n\nThis is not only an abstract issue.  If Drinfeld modules are represented via a\nsubclass of ring morphisms as Travis suggests, then a user who would like to\naccess morphisms of Drinfeld modules via Hom(phi, psi) (where phi, psi are\nDrinfeld modules) would get an erroneous result, and this seems problematic to\nme.\nWe should consider that these ring morphisms are just a way to represent\nobjects in the category of Drinfeld modules, but they are not enough to\nrepresent the morphisms of Drinfeld modules.\n\nI believe that this problem does not arise with Antoine's current code.\nThis is why I prefer the structure of Antoine's current code to Travis'\nsuggestions.\n\nAlso, I should say that I agree with Xavier's remarks and concerns, and I do\nnot believe that he is \"tiling at windmills\" (and no need to bring in \"another\nweapon\", nor any other pejorative/agressive metaphor; please let this public\nspace remain a non-hostile environment; please check https://github.com/sagemath/sage/blob/develop/CODE_OF_CONDUCT.md).\n\nConcerning the question of the Parent vs Element framework, I believe that the\nimplementation of elliptic curves is very nice and they are parents without\nelements. This is consistent with the fact they are objects in a non-concrete\ncategory (objects have no underlying set). I don't see why using a similar\nframework for Drinfeld modules would pose any problem. \n\nTravis, could you please elaborate on the reason why you think that using a\nstructure similar to that of the implementation of elliptic curves would be bad?\n\nIn summary, I believe that Antoine's code is in good shape, and that following\nTravis' suggestions would introduce problems related to the fact that\ninheriting from ring morphisms would not capture well the category of Drinfeld\nmodules (and in particular their morphisms, which are very important for\npractitioners), and which would lead to erroneous and confusing behaviours (for instance `Hom(phi,psi)`, or `phi.category()` would be wrong).",
    "created_at": "2022-09-13T17:04:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672127",
    "user": "https://github.com/spaenlehauer"
}
```


<a id='comment:131'></a>
Replying to [Travis Scrimshaw](#comment%3A124):
> All you’ve done is put lipstick on a pig with your changes, and like that
> mental image suggests, things are worse and scarier than before without make
> any fundamental changes: 


No, you are wrong, all Antoine has done is not just "put lipstick on a pig".

> What I think would be the way forward:

>
>   - `DrinfeldModules` should be a Parent (possibly of a Homset).
>   - `DrinfeldModule` should be a subclass of Element (possibly of a `RingHomomorphism`).
>   - There is a new category of `DrinfeldModulesCategory` that is returned by the category().
>   - You want a new parent that is a subclass of Homset for the Drinfeld module morphisms. 


I disagree with Travis' suggestions. The main reason is that I believe
that a class implementing Drinfeld modules should not be a subclass of a class
implementing ring morphisms, because this fails to capture correctly the notion
of morphisms of Drinfeld modules.

To be a bit clearer, let's look at a similar situation for elliptic curves.
Elliptic curves are most often constructed from a bivariate polynomial
`y<sup>2-x</sup>3-a*x-b` and this is how they are often stored and manipulated. However,
it would be misleading to say that an elliptic curve *is* a bivariate
polynomial. More precisely, an elliptic curve should not be seen as an element
of the ring of bivariate polynomials; it is just a way to construct and to
manipulate it. This is why it is often said that an elliptic curve *is defined
by* such a polynomial, but not that it *is* such a polynomial.

The reason for this is that polynomials fail to capture correctly the notion of
morphisms of elliptic curves. And this is why implementing elliptic curves as a
subclass of a class implementing bivariate polynomials would be very confusing.

The situation is similar for Drinfeld modules. In maths, it is said that a
Drinfeld module *is* a ring morphism, but I believe that it would be less
confusing to say that it *is defined by* a ring morphism, as in the case of
elliptic curves.

This is not only an abstract issue.  If Drinfeld modules are represented via a
subclass of ring morphisms as Travis suggests, then a user who would like to
access morphisms of Drinfeld modules via Hom(phi, psi) (where phi, psi are
Drinfeld modules) would get an erroneous result, and this seems problematic to
me.
We should consider that these ring morphisms are just a way to represent
objects in the category of Drinfeld modules, but they are not enough to
represent the morphisms of Drinfeld modules.

I believe that this problem does not arise with Antoine's current code.
This is why I prefer the structure of Antoine's current code to Travis'
suggestions.

Also, I should say that I agree with Xavier's remarks and concerns, and I do
not believe that he is "tiling at windmills" (and no need to bring in "another
weapon", nor any other pejorative/agressive metaphor; please let this public
space remain a non-hostile environment; please check https://github.com/sagemath/sage/blob/develop/CODE_OF_CONDUCT.md).

Concerning the question of the Parent vs Element framework, I believe that the
implementation of elliptic curves is very nice and they are parents without
elements. This is consistent with the fact they are objects in a non-concrete
category (objects have no underlying set). I don't see why using a similar
framework for Drinfeld modules would pose any problem. 

Travis, could you please elaborate on the reason why you think that using a
structure similar to that of the implementation of elliptic curves would be bad?

In summary, I believe that Antoine's code is in good shape, and that following
Travis' suggestions would introduce problems related to the fact that
inheriting from ring morphisms would not capture well the category of Drinfeld
modules (and in particular their morphisms, which are very important for
practitioners), and which would lead to erroneous and confusing behaviours (for instance `Hom(phi,psi)`, or `phi.category()` would be wrong).



---

archive/issue_comments_672128.json:
```json
{
    "body": "<a id='comment:132'></a>\nReplying to [Xavier Caruso](#comment%3A130):\n> I'm trying to re-implement this ticket along the lines proposed by Travis.\n> \n> And I realized that the fact that a Drinfeld module is not a parent causes a lot of headache when we are coming to morphisms between Drinfeld modules; indeed, this roughly prevents from inheriting from `Morphism` becomes this class implicity assumes everywhere that the domain and the codomain are parents (typically, the cython attributes `_domain` and `_codomain` are declared to be parents).\n> \n> The right solution would probably be to have a general class for morphisms in a category (whose elements are not parents and which cannot be necessarily callable). However, it does not exist (correct me if I'm wrong) and it's not the purpose of this ticket to implement it (and btw, I don't really have the courage to do it now).\n> \n> In order to go ahead, I see two options:\n> - either we stay with the current implement and let Drinfeld modules be parents,\n> - or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).\n> \n> What's your opinion? (Or do you see another solution?)\n\n\nMany thanks Xavier for trying to implement Travis' suggestions. As I mention above, I agree with you that his suggestions create problems with morphisms. My opinion is that Antoine's current code is fine and that we can stay with it.",
    "created_at": "2022-09-13T17:08:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672128",
    "user": "https://github.com/spaenlehauer"
}
```


<a id='comment:132'></a>
Replying to [Xavier Caruso](#comment%3A130):
> I'm trying to re-implement this ticket along the lines proposed by Travis.
> 
> And I realized that the fact that a Drinfeld module is not a parent causes a lot of headache when we are coming to morphisms between Drinfeld modules; indeed, this roughly prevents from inheriting from `Morphism` becomes this class implicity assumes everywhere that the domain and the codomain are parents (typically, the cython attributes `_domain` and `_codomain` are declared to be parents).
> 
> The right solution would probably be to have a general class for morphisms in a category (whose elements are not parents and which cannot be necessarily callable). However, it does not exist (correct me if I'm wrong) and it's not the purpose of this ticket to implement it (and btw, I don't really have the courage to do it now).
> 
> In order to go ahead, I see two options:
> - either we stay with the current implement and let Drinfeld modules be parents,
> - or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).
> 
> What's your opinion? (Or do you see another solution?)


Many thanks Xavier for trying to implement Travis' suggestions. As I mention above, I agree with you that his suggestions create problems with morphisms. My opinion is that Antoine's current code is fine and that we can stay with it.



---

archive/issue_comments_672129.json:
```json
{
    "body": "<a id='comment:3'></a>\nReplying to[comment:131](#comment%3A131)\n> Concerning the question of the Parent vs Element framework, I believe that the implementation of elliptic curves is very nice and they are parents without elements. This is consistent with the fact they are objects in a non-concrete category (objects have no underlying set). I don't see why using a similar framework for Drinfeld modules would pose any problem.\n\n\nAccording to the Sage reference manual:\n\n> Parents are the Sage/mathematical analogues of container objects in computer science.\n\n\nAs you know, a big difference between Drinfeld modules and elliptic curves is that the latter has points. For example, in Sage we can do\n\n```\nsage: E = EllipticCurve([0,0,1,-1,0])\nsage: E.an_element()\n(0 : -1 : 1)\nsage: E.point_set()\nAbelian group of points on Elliptic Curve defined by y^2 + y = x^3 - x over Rational Field\n```\n\nHence, even though elliptic curves does not have a dedicated elements class, they still do want to act like a \"container objects\". In the case of Drinfeld modules, there is no analogues to this, because they don't have points. It's not even a variety, it just \"acts\" like one by its properties. However, I do have a suggestion:\n\n* `DrinfeldModule` inherits from parent\n* New Category `DrinfeldModules`\n* New element class `DrinfeldModuleActionElement` (or any other name) being the set of all `\\phi(a) = \\phi_a` for `a \\in A = Fq[T]`\n\nOne could create a Drinfeld module `\\phi` in the same way that Antoine nicely implemented. Then, calling the element constructor method `\\phi(a)` for any element `a \\in Fq[T]` would return a \"Drinfeld module action element\" represented by the Ore polynomial `\\phi_a(\\tau)` where `\\tau` is the `q`-frobenius. We would therefore have something like:\n\n```\nsage: A = GF(5)['T'], K.<T> = Frac(A)\nsage: phi = DrinfeldModule(A, [T, K.one()])\nsage: phi\nDrinfeld module defined by T |--> t + T over [...]\nsage: s = phi(T^2); s\nt^2 + (T^5 + T)*t + T^2\nsage: s.parent()\nDrinfeld module defined by T |--> t + T over [...]\n```\n\nThis is one way that I would see to \"artificially\" consider an element class for a Drinfeld module, however one downside that I see from my proposition is that we would not directly manipulate Ore polynomials when we manipulate \"Drinfeld module action element\", hence the need to reimplement some Ore polynomial-specific methods. However, I know that if I was a user and I wanted to do computations in a CAS with Drinfeld modules, then I would probably want to manipulates objects like `\\phi_a(\\tau)` and recover the mathematical information they give. Therefore, I think that the implemention definitely should focus on this aspect.\n\n---\n\nReplying to[comment:130](#comment%3A130):\n>In order to go ahead, I see two options:\n>\n>* either we stay with the current implement and let Drinfeld modules be parents,\n>* or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).\n\n\nIn the case of option 2 do you think it would be a lot work to reimplement the methods related to composition?",
    "created_at": "2022-09-13T18:47:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672129",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:3'></a>
Replying to[comment:131](#comment%3A131)
> Concerning the question of the Parent vs Element framework, I believe that the implementation of elliptic curves is very nice and they are parents without elements. This is consistent with the fact they are objects in a non-concrete category (objects have no underlying set). I don't see why using a similar framework for Drinfeld modules would pose any problem.


According to the Sage reference manual:

> Parents are the Sage/mathematical analogues of container objects in computer science.


As you know, a big difference between Drinfeld modules and elliptic curves is that the latter has points. For example, in Sage we can do

```
sage: E = EllipticCurve([0,0,1,-1,0])
sage: E.an_element()
(0 : -1 : 1)
sage: E.point_set()
Abelian group of points on Elliptic Curve defined by y^2 + y = x^3 - x over Rational Field
```

Hence, even though elliptic curves does not have a dedicated elements class, they still do want to act like a "container objects". In the case of Drinfeld modules, there is no analogues to this, because they don't have points. It's not even a variety, it just "acts" like one by its properties. However, I do have a suggestion:

* `DrinfeldModule` inherits from parent
* New Category `DrinfeldModules`
* New element class `DrinfeldModuleActionElement` (or any other name) being the set of all `\phi(a) = \phi_a` for `a \in A = Fq[T]`

One could create a Drinfeld module `\phi` in the same way that Antoine nicely implemented. Then, calling the element constructor method `\phi(a)` for any element `a \in Fq[T]` would return a "Drinfeld module action element" represented by the Ore polynomial `\phi_a(\tau)` where `\tau` is the `q`-frobenius. We would therefore have something like:

```
sage: A = GF(5)['T'], K.<T> = Frac(A)
sage: phi = DrinfeldModule(A, [T, K.one()])
sage: phi
Drinfeld module defined by T |--> t + T over [...]
sage: s = phi(T^2); s
t^2 + (T^5 + T)*t + T^2
sage: s.parent()
Drinfeld module defined by T |--> t + T over [...]
```

This is one way that I would see to "artificially" consider an element class for a Drinfeld module, however one downside that I see from my proposition is that we would not directly manipulate Ore polynomials when we manipulate "Drinfeld module action element", hence the need to reimplement some Ore polynomial-specific methods. However, I know that if I was a user and I wanted to do computations in a CAS with Drinfeld modules, then I would probably want to manipulates objects like `\phi_a(\tau)` and recover the mathematical information they give. Therefore, I think that the implemention definitely should focus on this aspect.

---

Replying to[comment:130](#comment%3A130):
>In order to go ahead, I see two options:
>
>* either we stay with the current implement and let Drinfeld modules be parents,
>* or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).


In the case of option 2 do you think it would be a lot work to reimplement the methods related to composition?



---

archive/issue_comments_672130.json:
```json
{
    "body": "<a id='comment:134'></a>\nReplying to [David Ayotte](#comment%3A133):\n> As you know, a big difference between Drinfeld modules and elliptic curves is that the latter has points.\n\n\nI actually don't think that it's a problem to have a parent without elements.\n\nBut, if you do think that it's indeed a problem, my opinion is that using the class `CategoryObject` is (theoretically) a right way to solve this. Okay, maybe, this class was not designed for this use case at first, and it has lost all meaning in the current version of sage... but then, why not revive it today?\nI think that Drinfeld modules (and maybe elliptic curves) are the perfect situation in which it can make a lot of sense.\n\n> However, I do have a suggestion:\n> \n> * `DrinfeldModule` inherits from parent\n> * New Category `DrinfeldModules`\n> * New element class `DrinfeldModuleActionElement` (or any other name) being the set of all `\\phi(a) = \\phi_a` for `a \\in A = Fq[T]`\n\n\nI'm not sure to understand the benefit of this.\n\n*If we really want to have elements* (but I insist that I think that it is not needed), I would define an element of a Drinfeld module `phi` as an element of the algebraic closure of `K` (or maybe, more generally, any element lying in a `K`-algebra), this set being equipped with the action of `Fq[X]` given by `phi`.\n\n> >In order to go ahead, I see two options:\n> >\n> >* either we stay with the current implement and let Drinfeld modules be parents,\n> >* or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).\n\n> \n> In the case of option 2 do you think it would be a lot work to reimplement the methods related to composition?\n\n\nHonestly, I don't know; my feeling is that it will basically consist in rewriting the code in `sage.categories.morphism`, but not assuming that `domain` and `codomain` are parents, though some simplifications should be possible if you restrict ourselves to Drinfeld modules.",
    "created_at": "2022-09-13T19:19:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672130",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:134'></a>
Replying to [David Ayotte](#comment%3A133):
> As you know, a big difference between Drinfeld modules and elliptic curves is that the latter has points.


I actually don't think that it's a problem to have a parent without elements.

But, if you do think that it's indeed a problem, my opinion is that using the class `CategoryObject` is (theoretically) a right way to solve this. Okay, maybe, this class was not designed for this use case at first, and it has lost all meaning in the current version of sage... but then, why not revive it today?
I think that Drinfeld modules (and maybe elliptic curves) are the perfect situation in which it can make a lot of sense.

> However, I do have a suggestion:
> 
> * `DrinfeldModule` inherits from parent
> * New Category `DrinfeldModules`
> * New element class `DrinfeldModuleActionElement` (or any other name) being the set of all `\phi(a) = \phi_a` for `a \in A = Fq[T]`


I'm not sure to understand the benefit of this.

*If we really want to have elements* (but I insist that I think that it is not needed), I would define an element of a Drinfeld module `phi` as an element of the algebraic closure of `K` (or maybe, more generally, any element lying in a `K`-algebra), this set being equipped with the action of `Fq[X]` given by `phi`.

> >In order to go ahead, I see two options:
> >
> >* either we stay with the current implement and let Drinfeld modules be parents,
> >* or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).

> 
> In the case of option 2 do you think it would be a lot work to reimplement the methods related to composition?


Honestly, I don't know; my feeling is that it will basically consist in rewriting the code in `sage.categories.morphism`, but not assuming that `domain` and `codomain` are parents, though some simplifications should be possible if you restrict ourselves to Drinfeld modules.



---

archive/issue_comments_672131.json:
```json
{
    "body": "<a id='comment:135'></a>\nReplying to [Xavier Caruso](#comment%3A134):\n> > However, I do have a suggestion:\n> > \n> > * `DrinfeldModule` inherits from parent\n> > * New Category `DrinfeldModules`\n> > * New element class `DrinfeldModuleActionElement` (or any other name) being the set of all `\\phi(a) = \\phi_a` for `a \\in A = Fq[T]`\n \n> \n> I'm not sure to understand the benefit of this.\n> \n> *If we really want to have elements* (but I insist that I think that it is not needed), I would define an element of a Drinfeld module `phi` as an element of the algebraic closure of `K` (or maybe, more generally, any element lying in a `K`-algebra), this set being equipped with the action of `Fq[X]` given by `phi`.\n\n\n(*If we really want to have elements*) I also thought about your definition of an \"element\". As much as it could makes sense mathematically, I don't think that, as a user, I would want to directly manipulate elements of K with an induced action of `Fq[T]`. I would be more interested in the information given by the Ore polynomial `\\phi_a`. There are indeed interesting objects that we can compute using the `\\phi_a` (for example: computing logarithms and exponential associated to `\\phi`). My suggestion was a quick naive attempt to make a potential element class more \"centered around\" these specific Ore polynomials that the user would probably want to manipulate (I hope I'm clear). But again, this is if we absolutely want to have an element class, otherwise we can scrap this idea!\n\nBefore my main concerns were more centered about future of the code, but now I am more centered around the user and I don't think that wether `DrinfeldModule` is a parent or not would change anything for the user. According to your implementation (thank you for that!), there definitely seems to be some technical benefit in keeping the current implementation (thank you Antoine for all your work!).",
    "created_at": "2022-09-13T20:08:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672131",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:135'></a>
Replying to [Xavier Caruso](#comment%3A134):
> > However, I do have a suggestion:
> > 
> > * `DrinfeldModule` inherits from parent
> > * New Category `DrinfeldModules`
> > * New element class `DrinfeldModuleActionElement` (or any other name) being the set of all `\phi(a) = \phi_a` for `a \in A = Fq[T]`
 
> 
> I'm not sure to understand the benefit of this.
> 
> *If we really want to have elements* (but I insist that I think that it is not needed), I would define an element of a Drinfeld module `phi` as an element of the algebraic closure of `K` (or maybe, more generally, any element lying in a `K`-algebra), this set being equipped with the action of `Fq[X]` given by `phi`.


(*If we really want to have elements*) I also thought about your definition of an "element". As much as it could makes sense mathematically, I don't think that, as a user, I would want to directly manipulate elements of K with an induced action of `Fq[T]`. I would be more interested in the information given by the Ore polynomial `\phi_a`. There are indeed interesting objects that we can compute using the `\phi_a` (for example: computing logarithms and exponential associated to `\phi`). My suggestion was a quick naive attempt to make a potential element class more "centered around" these specific Ore polynomials that the user would probably want to manipulate (I hope I'm clear). But again, this is if we absolutely want to have an element class, otherwise we can scrap this idea!

Before my main concerns were more centered about future of the code, but now I am more centered around the user and I don't think that wether `DrinfeldModule` is a parent or not would change anything for the user. According to your implementation (thank you for that!), there definitely seems to be some technical benefit in keeping the current implementation (thank you Antoine for all your work!).



---

archive/issue_comments_672132.json:
```json
{
    "body": "<a id='comment:136'></a>\nReplying to [Xavier Caruso](#comment%3A130):\n> I'm trying to re-implement this ticket along the lines proposed by Travis.\n> \n> And I realized that the fact that a Drinfeld module is not a parent causes a lot of headache when we are coming to morphisms between Drinfeld modules; indeed, this roughly prevents from inheriting from `Morphism` becomes this class implicity assumes everywhere that the domain and the codomain are parents (typically, the cython attributes `_domain` and `_codomain` are declared to be parents).\n\n\nThis remains a problem even if you revert back to `CategoryObject`. I am very strongly opposed to having a `Parent` that does not have elements as the code, mathematical model, and documentation explicitly are based upon this.\n\n> The right solution would probably be to have a general class for morphisms in a category (whose elements are not parents and which cannot be necessarily callable). However, it does not exist (correct me if I'm wrong) and it's not the purpose of this ticket to implement it (and btw, I don't really have the courage to do it now).\n\n\nNo, it doesn't exist. There are some technical challenges and larger organizational things to be done to get this to work. It should be possible with actually somewhat minimal changes, but it will require some thought on the design (and likely some political discussions).\n\n> In order to go ahead, I see two options:\n> - either we stay with the current implement and let Drinfeld modules be parents,\n> - or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).\n> \n> What's your opinion? (Or do you see another solution?)\n\n\nUnfortunately, I think you are stuck with the second option. This is basically what `Functor` does.",
    "created_at": "2022-09-14T00:27:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672132",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:136'></a>
Replying to [Xavier Caruso](#comment%3A130):
> I'm trying to re-implement this ticket along the lines proposed by Travis.
> 
> And I realized that the fact that a Drinfeld module is not a parent causes a lot of headache when we are coming to morphisms between Drinfeld modules; indeed, this roughly prevents from inheriting from `Morphism` becomes this class implicity assumes everywhere that the domain and the codomain are parents (typically, the cython attributes `_domain` and `_codomain` are declared to be parents).


This remains a problem even if you revert back to `CategoryObject`. I am very strongly opposed to having a `Parent` that does not have elements as the code, mathematical model, and documentation explicitly are based upon this.

> The right solution would probably be to have a general class for morphisms in a category (whose elements are not parents and which cannot be necessarily callable). However, it does not exist (correct me if I'm wrong) and it's not the purpose of this ticket to implement it (and btw, I don't really have the courage to do it now).


No, it doesn't exist. There are some technical challenges and larger organizational things to be done to get this to work. It should be possible with actually somewhat minimal changes, but it will require some thought on the design (and likely some political discussions).

> In order to go ahead, I see two options:
> - either we stay with the current implement and let Drinfeld modules be parents,
> - or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).
> 
> What's your opinion? (Or do you see another solution?)


Unfortunately, I think you are stuck with the second option. This is basically what `Functor` does.



---

archive/issue_comments_672133.json:
```json
{
    "body": "<a id='comment:7'></a>\nActually, let me explain a bit of my idea to get `Map` to work more generally:\n\n- We strip many of the set/`Parent`-like operations from `CategoryObject` (perhaps as a new intermediate class) and make `Element` a subclass of `CategoryObject`.\n- We downgrade `Parent _codomain` to `CategoryObject _codomain`.\n\nNote that it makes sense to have `Element` as `CategoryObject` since they have a category. It also makes a distinction between more general `SageObject`s and things in a category. This would fit better with the mathematics. Finally, there is no major refactoring that would need to be done.",
    "created_at": "2022-09-14T00:32:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672133",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:7'></a>
Actually, let me explain a bit of my idea to get `Map` to work more generally:

- We strip many of the set/`Parent`-like operations from `CategoryObject` (perhaps as a new intermediate class) and make `Element` a subclass of `CategoryObject`.
- We downgrade `Parent _codomain` to `CategoryObject _codomain`.

Note that it makes sense to have `Element` as `CategoryObject` since they have a category. It also makes a distinction between more general `SageObject`s and things in a category. This would fit better with the mathematics. Finally, there is no major refactoring that would need to be done.



---

archive/issue_comments_672134.json:
```json
{
    "body": "<a id='comment:138'></a>\nReplying to [gh-spaenlehauer](#comment%3A131):\n> Replying to [Travis Scrimshaw](#comment%3A124):\n> > All you\u2019ve done is put lipstick on a pig with your changes, and like that\n> > mental image suggests, things are worse and scarier than before without make\n> > any fundamental changes: \n\n> \n> No, you are wrong, all Antoine has done is not just \"put lipstick on a pig\".\n\n\nYou should actually provide evidence instead of just simply stating it. I mentioned a number of reasons why it is basically the same implementation.\n\n> > What I think would be the way forward:\n\n> >\n> >   - `DrinfeldModules` should be a Parent (possibly of a Homset).\n> >   - `DrinfeldModule` should be a subclass of Element (possibly of a `RingHomomorphism`).\n> >   - There is a new category of `DrinfeldModulesCategory` that is returned by the category().\n> >   - You want a new parent that is a subclass of Homset for the Drinfeld module morphisms. \n \n> \n> I disagree with Travis' suggestions. The main reason is that I believe\n> that a class implementing Drinfeld modules should not be a subclass of a class\n> implementing ring morphisms, because this fails to capture correctly the notion\n> of morphisms of Drinfeld modules.\n\n\nThis is exactly what subclasses are for: To extend functionality that does not exist at a more general level.\n\n> To be a bit clearer, let's look at a similar situation for elliptic curves.\n> Elliptic curves are most often constructed from a bivariate polynomial\n> `y<sup>2-x</sup>3-a*x-b` and this is how they are often stored and manipulated. However,\n> it would be misleading to say that an elliptic curve *is* a bivariate\n> polynomial. More precisely, an elliptic curve should not be seen as an element\n> of the ring of bivariate polynomials; it is just a way to construct and to\n> manipulate it. This is why it is often said that an elliptic curve *is defined\n> by* such a polynomial, but not that it *is* such a polynomial.\n\n>\n> The reason for this is that polynomials fail to capture correctly the notion of\n> morphisms of elliptic curves. And this is why implementing elliptic curves as a\n> subclass of a class implementing bivariate polynomials would be very confusing.\n\n\nIndeed, because an elliptic curve is the zero set of the polynomial as I understand it (from a quick look at the Wikipedia page). So this is a non-sequitur.\n\n> The situation is similar for Drinfeld modules. In maths, it is said that a\n> Drinfeld module *is* a ring morphism, but I believe that it would be less\n> confusing to say that it *is defined by* a ring morphism, as in the case of\n> elliptic curves.\n\n\nIs your point that the mathematics is wrong? The definition as given says it is a certain subset of ring morphisms defined by a particular property.\n\n> This is not only an abstract issue.  If Drinfeld modules are represented via a\n> subclass of ring morphisms as Travis suggests, then a user who would like to\n> access morphisms of Drinfeld modules via Hom(phi, psi) (where phi, psi are\n> Drinfeld modules) would get an erroneous result, and this seems problematic to\n> me.\n\n\nThis makes no sense to me. You still have a set of morphisms between the objects, which is the `Parent` for any such morphism. You should not get anything different, that would be a bug due to the implementer of the specific behavior. What would be wrong with the returned homset? To get non-generic behavior, you need to implement something.\n\n> We should consider that these ring morphisms are just a way to represent\n> objects in the category of Drinfeld modules, but they are not enough to\n> represent the morphisms of Drinfeld modules.\n\n\nI see this argument akin to saying we shouldn't implement an algebra as a subclass of a module implementation (see all the subclasses of `CombinatorialFreeModule`). Furthermore, the morphisms are a completely separate implementation.\n\n> I believe that this problem does not arise with Antoine's current code.\n> This is why I prefer the structure of Antoine's current code to Travis'\n> suggestions.\n\n\nYou haven't said anything specific or exact to justify your claims. You have used vague words such as \"enough\" without saying what it means to have it represent something. Can you be more precise here with what you want?\n\n> Also, I should say that I agree with Xavier's remarks and concerns, and I do\n> not believe that he is \"tiling at windmills\" (and no need to bring in \"another\n> weapon\", nor any other pejorative/agressive metaphor; please let this public\n> space remain a non-hostile environment; please check https://github.com/sagemath/sage/blob/develop/CODE_OF_CONDUCT.md).\n\n\nFirst, if you want to claim such violations, please attempt to do so evenly and fairly. Second, you should understand the idiom of \"tilting at windmills\" (sorry for the typo in my post) means going after something that is not an actual problem. There is no violation by pointing out that I think the issue raise there is not a problem.\n\n> Concerning the question of the Parent vs Element framework, I believe that the\n> implementation of elliptic curves is very nice and they are parents without\n> elements. This is consistent with the fact they are objects in a non-concrete\n> category (objects have no underlying set). I don't see why using a similar\n> framework for Drinfeld modules would pose any problem. \n> \n> Travis, could you please elaborate on the reason why you think that using a\n> structure similar to that of the implementation of elliptic curves would be bad?\n\n\nIn addition to the mathematical differences I pointed to above, you need to let the code speak to you. In particular, the implementation details will give you a good guide. If you implement all of the methods and behaviors of class `Foo`, you should almost always inherit from class `Foo` or have a common ABC. As I have said repeatedly, everything that is in the category is doing what a `Parent` does and not a `Category`, everything in the `DrinfeldModule` is doing what an `Element` does, not a `CategoryObject`.\n\nFrom what Xavier did, it seems we have hit a limitation/assumption in the implementation of `Map`.\n\n> In summary, I believe that Antoine's code is in good shape, and that following\n> Travis' suggestions would introduce problems related to the fact that\n> inheriting from ring morphisms would not capture well the category of Drinfeld\n> modules (and in particular their morphisms, which are very important for\n> practitioners),\n\n\n> and which would lead to erroneous and confusing behaviours (for instance `Hom(phi,psi)`, or `phi.category()` would be wrong).\n\n\nThis is claim is demonstratively false. You get a homset and you get a category of all Drinfeld modules with certain parameters (albeit stored indirectly in the parent class, which is more of the object you want to use anyways).\n\n```\nsage: x = 2\nsage: y = 3\nsage: H = Hom(x, y)\nsage: H\nSet of Morphisms from 2 to 3 in Category of elements of Integer Ring\nsage: x.category()\nCategory of elements of Integer Ring\n```",
    "created_at": "2022-09-14T02:32:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672134",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:138'></a>
Replying to [gh-spaenlehauer](#comment%3A131):
> Replying to [Travis Scrimshaw](#comment%3A124):
> > All you’ve done is put lipstick on a pig with your changes, and like that
> > mental image suggests, things are worse and scarier than before without make
> > any fundamental changes: 

> 
> No, you are wrong, all Antoine has done is not just "put lipstick on a pig".


You should actually provide evidence instead of just simply stating it. I mentioned a number of reasons why it is basically the same implementation.

> > What I think would be the way forward:

> >
> >   - `DrinfeldModules` should be a Parent (possibly of a Homset).
> >   - `DrinfeldModule` should be a subclass of Element (possibly of a `RingHomomorphism`).
> >   - There is a new category of `DrinfeldModulesCategory` that is returned by the category().
> >   - You want a new parent that is a subclass of Homset for the Drinfeld module morphisms. 
 
> 
> I disagree with Travis' suggestions. The main reason is that I believe
> that a class implementing Drinfeld modules should not be a subclass of a class
> implementing ring morphisms, because this fails to capture correctly the notion
> of morphisms of Drinfeld modules.


This is exactly what subclasses are for: To extend functionality that does not exist at a more general level.

> To be a bit clearer, let's look at a similar situation for elliptic curves.
> Elliptic curves are most often constructed from a bivariate polynomial
> `y<sup>2-x</sup>3-a*x-b` and this is how they are often stored and manipulated. However,
> it would be misleading to say that an elliptic curve *is* a bivariate
> polynomial. More precisely, an elliptic curve should not be seen as an element
> of the ring of bivariate polynomials; it is just a way to construct and to
> manipulate it. This is why it is often said that an elliptic curve *is defined
> by* such a polynomial, but not that it *is* such a polynomial.

>
> The reason for this is that polynomials fail to capture correctly the notion of
> morphisms of elliptic curves. And this is why implementing elliptic curves as a
> subclass of a class implementing bivariate polynomials would be very confusing.


Indeed, because an elliptic curve is the zero set of the polynomial as I understand it (from a quick look at the Wikipedia page). So this is a non-sequitur.

> The situation is similar for Drinfeld modules. In maths, it is said that a
> Drinfeld module *is* a ring morphism, but I believe that it would be less
> confusing to say that it *is defined by* a ring morphism, as in the case of
> elliptic curves.


Is your point that the mathematics is wrong? The definition as given says it is a certain subset of ring morphisms defined by a particular property.

> This is not only an abstract issue.  If Drinfeld modules are represented via a
> subclass of ring morphisms as Travis suggests, then a user who would like to
> access morphisms of Drinfeld modules via Hom(phi, psi) (where phi, psi are
> Drinfeld modules) would get an erroneous result, and this seems problematic to
> me.


This makes no sense to me. You still have a set of morphisms between the objects, which is the `Parent` for any such morphism. You should not get anything different, that would be a bug due to the implementer of the specific behavior. What would be wrong with the returned homset? To get non-generic behavior, you need to implement something.

> We should consider that these ring morphisms are just a way to represent
> objects in the category of Drinfeld modules, but they are not enough to
> represent the morphisms of Drinfeld modules.


I see this argument akin to saying we shouldn't implement an algebra as a subclass of a module implementation (see all the subclasses of `CombinatorialFreeModule`). Furthermore, the morphisms are a completely separate implementation.

> I believe that this problem does not arise with Antoine's current code.
> This is why I prefer the structure of Antoine's current code to Travis'
> suggestions.


You haven't said anything specific or exact to justify your claims. You have used vague words such as "enough" without saying what it means to have it represent something. Can you be more precise here with what you want?

> Also, I should say that I agree with Xavier's remarks and concerns, and I do
> not believe that he is "tiling at windmills" (and no need to bring in "another
> weapon", nor any other pejorative/agressive metaphor; please let this public
> space remain a non-hostile environment; please check https://github.com/sagemath/sage/blob/develop/CODE_OF_CONDUCT.md).


First, if you want to claim such violations, please attempt to do so evenly and fairly. Second, you should understand the idiom of "tilting at windmills" (sorry for the typo in my post) means going after something that is not an actual problem. There is no violation by pointing out that I think the issue raise there is not a problem.

> Concerning the question of the Parent vs Element framework, I believe that the
> implementation of elliptic curves is very nice and they are parents without
> elements. This is consistent with the fact they are objects in a non-concrete
> category (objects have no underlying set). I don't see why using a similar
> framework for Drinfeld modules would pose any problem. 
> 
> Travis, could you please elaborate on the reason why you think that using a
> structure similar to that of the implementation of elliptic curves would be bad?


In addition to the mathematical differences I pointed to above, you need to let the code speak to you. In particular, the implementation details will give you a good guide. If you implement all of the methods and behaviors of class `Foo`, you should almost always inherit from class `Foo` or have a common ABC. As I have said repeatedly, everything that is in the category is doing what a `Parent` does and not a `Category`, everything in the `DrinfeldModule` is doing what an `Element` does, not a `CategoryObject`.

From what Xavier did, it seems we have hit a limitation/assumption in the implementation of `Map`.

> In summary, I believe that Antoine's code is in good shape, and that following
> Travis' suggestions would introduce problems related to the fact that
> inheriting from ring morphisms would not capture well the category of Drinfeld
> modules (and in particular their morphisms, which are very important for
> practitioners),


> and which would lead to erroneous and confusing behaviours (for instance `Hom(phi,psi)`, or `phi.category()` would be wrong).


This is claim is demonstratively false. You get a homset and you get a category of all Drinfeld modules with certain parameters (albeit stored indirectly in the parent class, which is more of the object you want to use anyways).

```
sage: x = 2
sage: y = 3
sage: H = Hom(x, y)
sage: H
Set of Morphisms from 2 to 3 in Category of elements of Integer Ring
sage: x.category()
Category of elements of Integer Ring
```



---

archive/issue_comments_672135.json:
```json
{
    "body": "<a id='comment:139'></a>\n(Combined answer.)\n\nReplying to [Travis Scrimshaw](#comment%3A136):\n> This remains a problem even if you revert back to `CategoryObject`.\n\n\nThat's correct.\n\nBut since I definitely think that it is a better solution, I feel more motivation to make it work :-). However, as we both said, this needs more discussion as it touches at the core of Sage.\n\nThat's why my proposal for now would be to stay with `Parent` (i.e. to allow parents without elements) and to remember that we have the plan to move to `CategoryObject` in the future.\n\nI actually do not see the problem with having temporarily one parent without elements, i.e. for which `_element_constructor_` raises an error. Would this break something? (I think it wouldn't because we already have one such parent, namely `EllipticCurve`.)\n\nReplying to [Travis Scrimshaw](#comment%3A137):\n> Actually, let me explain a bit of my idea to get `Map` to work more generally:\n> \n> - We strip many of the set/`Parent`-like operations from `CategoryObject` (perhaps as a new intermediate class) and make `Element` a subclass of `CategoryObject`.\n> - We downgrade `Parent _codomain` to `CategoryObject _codomain`.\n> \n> Note that it makes sense to have `Element` as `CategoryObject` since they have a category. It also makes a distinction between more general `SageObject`s and things in a category. This would fit better with the mathematics. Finally, there is no major refactoring that would need to be done.\n\n\nI basically agree with this, except that I do not believe that `Element` should derive from `CategoryObject`. Okay, maybe, at some point, it can be convenient to form the category of elements of some parent (btw, is this construction currently used somewhere in sage?) but I definitely think that we do not have to encourage this behaviour.\n\nReplying to [Travis Scrimshaw](#comment%3A138):\n> Indeed, because an elliptic curve is the zero set of the polynomial as I understand it (from a quick look at the Wikipedia page). So this is a non-sequitur.\n\n\nNo, that's not correct! This works maybe over an algebraically closed field (of characteristic zero?) but this does not work in full generality. In full generality, it is better to say that the elliptic curve is just the datum of the (Weierstrass) equation defining it (or, equivalenty, the ideal generated by this equation, or the quotient ring by this ideal, or the scheme associated to this ring...). In any case, it is not clear what is an element of an elliptic curve.",
    "created_at": "2022-09-14T04:43:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672135",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:139'></a>
(Combined answer.)

Replying to [Travis Scrimshaw](#comment%3A136):
> This remains a problem even if you revert back to `CategoryObject`.


That's correct.

But since I definitely think that it is a better solution, I feel more motivation to make it work :-). However, as we both said, this needs more discussion as it touches at the core of Sage.

That's why my proposal for now would be to stay with `Parent` (i.e. to allow parents without elements) and to remember that we have the plan to move to `CategoryObject` in the future.

I actually do not see the problem with having temporarily one parent without elements, i.e. for which `_element_constructor_` raises an error. Would this break something? (I think it wouldn't because we already have one such parent, namely `EllipticCurve`.)

Replying to [Travis Scrimshaw](#comment%3A137):
> Actually, let me explain a bit of my idea to get `Map` to work more generally:
> 
> - We strip many of the set/`Parent`-like operations from `CategoryObject` (perhaps as a new intermediate class) and make `Element` a subclass of `CategoryObject`.
> - We downgrade `Parent _codomain` to `CategoryObject _codomain`.
> 
> Note that it makes sense to have `Element` as `CategoryObject` since they have a category. It also makes a distinction between more general `SageObject`s and things in a category. This would fit better with the mathematics. Finally, there is no major refactoring that would need to be done.


I basically agree with this, except that I do not believe that `Element` should derive from `CategoryObject`. Okay, maybe, at some point, it can be convenient to form the category of elements of some parent (btw, is this construction currently used somewhere in sage?) but I definitely think that we do not have to encourage this behaviour.

Replying to [Travis Scrimshaw](#comment%3A138):
> Indeed, because an elliptic curve is the zero set of the polynomial as I understand it (from a quick look at the Wikipedia page). So this is a non-sequitur.


No, that's not correct! This works maybe over an algebraically closed field (of characteristic zero?) but this does not work in full generality. In full generality, it is better to say that the elliptic curve is just the datum of the (Weierstrass) equation defining it (or, equivalenty, the ideal generated by this equation, or the quotient ring by this ideal, or the scheme associated to this ring...). In any case, it is not clear what is an element of an elliptic curve.



---

archive/issue_comments_672136.json:
```json
{
    "body": "<a id='comment:140'></a>\nReplying to [Xavier Caruso](#comment%3A139):\n> I actually do not see the problem with having temporarily one parent without element, i.e. for which `_element_constructor_` raises an error. Would this break something?\n\n\nI think this is perfectly fine. \n\nAnother example of parents that don't have (proper) elements are facade parents.\nYou can still have meaningful morphisms between parents that don't have elements.\nIn fact, in #34461 I introduce such \"pointless\" morphisms.",
    "created_at": "2022-09-14T05:40:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672136",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:140'></a>
Replying to [Xavier Caruso](#comment%3A139):
> I actually do not see the problem with having temporarily one parent without element, i.e. for which `_element_constructor_` raises an error. Would this break something?


I think this is perfectly fine. 

Another example of parents that don't have (proper) elements are facade parents.
You can still have meaningful morphisms between parents that don't have elements.
In fact, in #34461 I introduce such "pointless" morphisms.



---

archive/issue_comments_672137.json:
```json
{
    "body": "<a id='comment:141'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A140):\n> Replying to [Xavier Caruso](#comment%3A139):\n> > I actually do not see the problem with having temporarily one parent without element, i.e. for which `_element_constructor_` raises an error. Would this break something?\n\n> \n> I think this is perfectly fine. \n> \n> Another example of parents that don't have (proper) elements are facade parents.\n> You can still have meaningful morphisms between parents that don't have elements.\n> In fact, in #34461 I introduce such \"pointless\" morphisms.\n\n\nThey do not have proper elements, but they still are modeling a set with elements with the corresponding properties such as containment and an `_element_constructor_`. So this is not an example.",
    "created_at": "2022-09-14T05:50:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672137",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:141'></a>
Replying to [Matthias Köppe](#comment%3A140):
> Replying to [Xavier Caruso](#comment%3A139):
> > I actually do not see the problem with having temporarily one parent without element, i.e. for which `_element_constructor_` raises an error. Would this break something?

> 
> I think this is perfectly fine. 
> 
> Another example of parents that don't have (proper) elements are facade parents.
> You can still have meaningful morphisms between parents that don't have elements.
> In fact, in #34461 I introduce such "pointless" morphisms.


They do not have proper elements, but they still are modeling a set with elements with the corresponding properties such as containment and an `_element_constructor_`. So this is not an example.



---

archive/issue_comments_672138.json:
```json
{
    "body": "<a id='comment:2'></a>\nI think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. \nWhether something is \"empty as a set\" or \"in principle doesn't have elements\" is probably a distinction that is not important enough to model in our code.",
    "created_at": "2022-09-14T06:08:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672138",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:2'></a>
I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. 
Whether something is "empty as a set" or "in principle doesn't have elements" is probably a distinction that is not important enough to model in our code.



---

archive/issue_comments_672139.json:
```json
{
    "body": "<a id='comment:143'></a>\nReplying to [Xavier Caruso](#comment%3A139):\n> (Combined answer.)\n> \n> Replying to [Travis Scrimshaw](#comment%3A136):\n> > This remains a problem even if you revert back to `CategoryObject`.\n\n> \n> That's correct.\n> \n> But since I definitely think that it is a better solution, I feel more motivation in make it work :-). However, as we both said, this needs more discussion as it touches at the core of Sage.\n> \n> That's why my proposal for now would be to stay with `Parent` (i.e. to allow parents without elements) and to remember that we have the plan to move to `CategoryObject` in the future.\n\n\nI think this would be taking on a large amount of technical debt and would set some bad precedents. I can settle for `CategoryObject`, as much as I strongly disagree with using `Category` instead of `Parent`, as a compromise, but not with using `Parent`.\n\nThe good news is that because you don't have any algebraic operations, you don't have to implement all of the morphism stuff based around coercion. You will probably want to do custom compositions anyways, right? (Currently, composing two of them will not have an `ore_polynomial` method I believe.) Plus things like injective and surjective no longer make sense, correct? This is probably better for the API, and I don't think there are too many things that will need to be duplicated.\n\n> I actually do not see the problem with having temporarily one parent without elementd, i.e. for which `_element_constructor_` raises an error. Would this break something? (I think it wouldn't because we already have one such parent, namely `EllipticCurve`.)\n\n\nYour proposal is quite different than what `EllipticCurve` does:\n\n```\nsage: E = EllipticCurve([0,0,1,-1,0])\nsage: E.gens()\n[(0 : -1 : 1)]\nsage: E.an_element()\n(0 : -1 : 1)\n```\nAlthough I don't know anything about the Mordell-Weil group, but it not registered as an element in `E`. `E` also implements a `__contains__` method.\n\nMy understanding is that the `EllipticCurve` setup is fairly old code to Sage, predating categories, coercion, etc. that have been around for a long time. So that gives it less weight as a precedent, and I doubt anyone has a desire to spend lots of time rewriting it as it currently works.\n\nLet me restate again that a `Parent` is suppose to model a set of elements. Breaking the fundamental model of a class is an evil practice. Thus, I think it is not behavior to be encouraged.\n\n> Replying to [Travis Scrimshaw](#comment%3A137):\n> > Actually, let me explain a bit of my idea to get `Map` to work more generally:\n> > \n> > - We strip many of the set/`Parent`-like operations from `CategoryObject` (perhaps as a new intermediate class) and make `Element` a subclass of `CategoryObject`.\n> > - We downgrade `Parent _codomain` to `CategoryObject _codomain`.\n> > \n> > Note that it makes sense to have `Element` as `CategoryObject` since they have a category. It also makes a distinction between more general `SageObject`s and things in a category. This would fit better with the mathematics. Finally, there is no major refactoring that would need to be done.\n\n> \n> I basically agree with this, except that I do not believe that `Element` should derive from `CategoryObject`. Okay, maybe, at some point, it can be convenient to form the category of elements of some parents (btw, is this construction currently used somewhere in sage?) but I definitely think that we do not have to encourage this behaviour.\n\n\nWhy? It is an object in a category. The category of elements is essentially just a different implementation of the set to make it fit with some of the other infrastructure within Sage.\n\nIn fact, the behavior that you want in this ticket is basically already there within Sage too. There is just a technical limitation due to an assumption that all things that want morphisms are subclasses of `Parent` (well, just their codomain I think).\n\n> Replying to [Travis Scrimshaw](#comment%3A138):\n> > Indeed, because an elliptic curve is the zero set of the polynomial as I understand it (from a quick look at the Wikipedia page). So this is a non-sequitur.\n\n> \n> No, that's not correct! This works maybe over an algebraically closed field (of characteristic zero?) but this does not work in full generality. In full generality, it is better to say that the elliptic curve is just the datum of the (Weierstrass) equation defining it (or, equivalenty, the ideal generated by this equation, or the quotient ring by this ideal, or the scheme associated to this ring...). In any case, it is not clear what is an element of an elliptic curve.\n\n\nAh, yea, what I said is too simplistic of a perspective. However, it is still not the polynomial but a related object.",
    "created_at": "2022-09-14T06:26:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672139",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:143'></a>
Replying to [Xavier Caruso](#comment%3A139):
> (Combined answer.)
> 
> Replying to [Travis Scrimshaw](#comment%3A136):
> > This remains a problem even if you revert back to `CategoryObject`.

> 
> That's correct.
> 
> But since I definitely think that it is a better solution, I feel more motivation in make it work :-). However, as we both said, this needs more discussion as it touches at the core of Sage.
> 
> That's why my proposal for now would be to stay with `Parent` (i.e. to allow parents without elements) and to remember that we have the plan to move to `CategoryObject` in the future.


I think this would be taking on a large amount of technical debt and would set some bad precedents. I can settle for `CategoryObject`, as much as I strongly disagree with using `Category` instead of `Parent`, as a compromise, but not with using `Parent`.

The good news is that because you don't have any algebraic operations, you don't have to implement all of the morphism stuff based around coercion. You will probably want to do custom compositions anyways, right? (Currently, composing two of them will not have an `ore_polynomial` method I believe.) Plus things like injective and surjective no longer make sense, correct? This is probably better for the API, and I don't think there are too many things that will need to be duplicated.

> I actually do not see the problem with having temporarily one parent without elementd, i.e. for which `_element_constructor_` raises an error. Would this break something? (I think it wouldn't because we already have one such parent, namely `EllipticCurve`.)


Your proposal is quite different than what `EllipticCurve` does:

```
sage: E = EllipticCurve([0,0,1,-1,0])
sage: E.gens()
[(0 : -1 : 1)]
sage: E.an_element()
(0 : -1 : 1)
```
Although I don't know anything about the Mordell-Weil group, but it not registered as an element in `E`. `E` also implements a `__contains__` method.

My understanding is that the `EllipticCurve` setup is fairly old code to Sage, predating categories, coercion, etc. that have been around for a long time. So that gives it less weight as a precedent, and I doubt anyone has a desire to spend lots of time rewriting it as it currently works.

Let me restate again that a `Parent` is suppose to model a set of elements. Breaking the fundamental model of a class is an evil practice. Thus, I think it is not behavior to be encouraged.

> Replying to [Travis Scrimshaw](#comment%3A137):
> > Actually, let me explain a bit of my idea to get `Map` to work more generally:
> > 
> > - We strip many of the set/`Parent`-like operations from `CategoryObject` (perhaps as a new intermediate class) and make `Element` a subclass of `CategoryObject`.
> > - We downgrade `Parent _codomain` to `CategoryObject _codomain`.
> > 
> > Note that it makes sense to have `Element` as `CategoryObject` since they have a category. It also makes a distinction between more general `SageObject`s and things in a category. This would fit better with the mathematics. Finally, there is no major refactoring that would need to be done.

> 
> I basically agree with this, except that I do not believe that `Element` should derive from `CategoryObject`. Okay, maybe, at some point, it can be convenient to form the category of elements of some parents (btw, is this construction currently used somewhere in sage?) but I definitely think that we do not have to encourage this behaviour.


Why? It is an object in a category. The category of elements is essentially just a different implementation of the set to make it fit with some of the other infrastructure within Sage.

In fact, the behavior that you want in this ticket is basically already there within Sage too. There is just a technical limitation due to an assumption that all things that want morphisms are subclasses of `Parent` (well, just their codomain I think).

> Replying to [Travis Scrimshaw](#comment%3A138):
> > Indeed, because an elliptic curve is the zero set of the polynomial as I understand it (from a quick look at the Wikipedia page). So this is a non-sequitur.

> 
> No, that's not correct! This works maybe over an algebraically closed field (of characteristic zero?) but this does not work in full generality. In full generality, it is better to say that the elliptic curve is just the datum of the (Weierstrass) equation defining it (or, equivalenty, the ideal generated by this equation, or the quotient ring by this ideal, or the scheme associated to this ring...). In any case, it is not clear what is an element of an elliptic curve.


Ah, yea, what I said is too simplistic of a perspective. However, it is still not the polynomial but a related object.



---

archive/issue_comments_672140.json:
```json
{
    "body": "<a id='comment:144'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A142):\n> I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. \n> Whether something is \"empty as a set\" or \"in principle doesn't have elements\" is probably a distinction that is not important enough to model in our code.\n\n\nOne can, but it is far less than ideal. A `NotImplementedError` (possibly a `AttributeError` if called directly) sends a very different signal than an `EmptySetError` or a `ValueError`. Its message also contains relevant information to the user too. I would be hunting for a bug if I got:\n\n```\nsage: class Foo(Parent):\n....:     pass\n....:     \nsage: F = Foo()\nsage: F(2)\n---------------------------------------------------------------------------\nNotImplementedError                       Traceback (most recent call last)\nInput In [7], in <cell line: 1>()\n----> 1 F(Integer(2))\n\nFile ~/sage-build/src/sage/structure/parent.pyx:878, in sage.structure.parent.Parent.__call__()\n    876 \"\"\"\n    877 if self._element_constructor is None:\n--> 878     raise NotImplementedError(f\"cannot construct elements of {self}\")\n    879 cdef Py_ssize_t i\n    880 cdef R = parent(x)\n\nNotImplementedError: cannot construct elements of <__main__.Foo object at 0x7fbdbd537a60>\n```",
    "created_at": "2022-09-14T06:30:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672140",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:144'></a>
Replying to [Matthias Köppe](#comment%3A142):
> I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. 
> Whether something is "empty as a set" or "in principle doesn't have elements" is probably a distinction that is not important enough to model in our code.


One can, but it is far less than ideal. A `NotImplementedError` (possibly a `AttributeError` if called directly) sends a very different signal than an `EmptySetError` or a `ValueError`. Its message also contains relevant information to the user too. I would be hunting for a bug if I got:

```
sage: class Foo(Parent):
....:     pass
....:     
sage: F = Foo()
sage: F(2)
---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
Input In [7], in <cell line: 1>()
----> 1 F(Integer(2))

File ~/sage-build/src/sage/structure/parent.pyx:878, in sage.structure.parent.Parent.__call__()
    876 """
    877 if self._element_constructor is None:
--> 878     raise NotImplementedError(f"cannot construct elements of {self}")
    879 cdef Py_ssize_t i
    880 cdef R = parent(x)

NotImplementedError: cannot construct elements of <__main__.Foo object at 0x7fbdbd537a60>
```



---

archive/issue_comments_672141.json:
```json
{
    "body": "<a id='comment:5'></a>\nI am not versed in scheme theory. Are there many different empty-as-set schemes?",
    "created_at": "2022-09-14T06:31:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672141",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:5'></a>
I am not versed in scheme theory. Are there many different empty-as-set schemes?



---

archive/issue_comments_672142.json:
```json
{
    "body": "<a id='comment:146'></a>\nReplying to [Travis Scrimshaw](#comment%3A144):\n> Replying to [Matthias K\u00f6ppe](#comment%3A142):\n> > I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. \n> > Whether something is \"empty as a set\" or \"in principle doesn't have elements\" is probably a distinction that is not important enough to model in our code.\n\n> \n> One can, but it is far less than ideal. \n\n\nI disagree. \n\nIn my opinion, the best way to think about what a `Parent` is, is something that makes sense as domain and codomain of morphisms. \n\nAll of that \"is like a container\" and \"models a set\" are just didactical simplifications that don't capture the full story.\n\nConsider two implementation classes that implement `Scheme`s - one whose instances are schemes that always have points (elements), one that never has points (elements). \nYou don't want to say that one of them should be a `Parent`, the other one shouldn't be a `Parent`.",
    "created_at": "2022-09-14T06:40:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672142",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:146'></a>
Replying to [Travis Scrimshaw](#comment%3A144):
> Replying to [Matthias Köppe](#comment%3A142):
> > I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. 
> > Whether something is "empty as a set" or "in principle doesn't have elements" is probably a distinction that is not important enough to model in our code.

> 
> One can, but it is far less than ideal. 


I disagree. 

In my opinion, the best way to think about what a `Parent` is, is something that makes sense as domain and codomain of morphisms. 

All of that "is like a container" and "models a set" are just didactical simplifications that don't capture the full story.

Consider two implementation classes that implement `Scheme`s - one whose instances are schemes that always have points (elements), one that never has points (elements). 
You don't want to say that one of them should be a `Parent`, the other one shouldn't be a `Parent`.



---

archive/issue_comments_672143.json:
```json
{
    "body": "<a id='comment:147'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A146):\n> Replying to [Travis Scrimshaw](#comment%3A144):\n> > Replying to [Matthias K\u00f6ppe](#comment%3A142):\n> > > I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. \n> > > Whether something is \"empty as a set\" or \"in principle doesn't have elements\" is probably a distinction that is not important enough to model in our code.\n\n> > \n> > One can, but it is far less than ideal. \n\n> \n> I disagree. \n> \n> In my opinion, the best way to think about what a `Parent` is, is something that makes sense as domain and codomain of morphisms. \n\n\nI think this is what `CategoryObject` should become. There are some vestiges of this, but it isn't supported (yet).\n\n> All of that \"is like a container\" and \"models a set\" are just didactical simplifications that don't capture the full story.\n\n\nTrue, but by being a subclass, the implementation is agreeing to follow the requirements given by the base (`Parent` `:p`) class.\n\n> Consider two implementation classes that implement `Scheme`s - one whose instances are schemes that always have points (elements), one that never has points (elements). \n> You don't want to say that one of them should be a `Parent`, the other one shouldn't be a `Parent`.\n\n\nThey should both be `Parent`s. One of which is just an empty set (plus some additional structure).",
    "created_at": "2022-09-14T06:48:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672143",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:147'></a>
Replying to [Matthias Köppe](#comment%3A146):
> Replying to [Travis Scrimshaw](#comment%3A144):
> > Replying to [Matthias Köppe](#comment%3A142):
> > > I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. 
> > > Whether something is "empty as a set" or "in principle doesn't have elements" is probably a distinction that is not important enough to model in our code.

> > 
> > One can, but it is far less than ideal. 

> 
> I disagree. 
> 
> In my opinion, the best way to think about what a `Parent` is, is something that makes sense as domain and codomain of morphisms. 


I think this is what `CategoryObject` should become. There are some vestiges of this, but it isn't supported (yet).

> All of that "is like a container" and "models a set" are just didactical simplifications that don't capture the full story.


True, but by being a subclass, the implementation is agreeing to follow the requirements given by the base (`Parent` `:p`) class.

> Consider two implementation classes that implement `Scheme`s - one whose instances are schemes that always have points (elements), one that never has points (elements). 
> You don't want to say that one of them should be a `Parent`, the other one shouldn't be a `Parent`.


They should both be `Parent`s. One of which is just an empty set (plus some additional structure).



---

archive/issue_comments_672144.json:
```json
{
    "body": "<a id='comment:148'></a>\nReplying to [Travis Scrimshaw](#comment%3A147):\n> Replying to [Matthias K\u00f6ppe](#comment%3A146):\n> > I disagree. \n> > \n> > In my opinion, the best way to think about what a `Parent` is, is something that makes sense as domain and codomain of morphisms. \n\n> \n> I think this is what `CategoryObject` should become. There are some vestiges of this, but it isn't supported (yet).\n\n\nNo, I disagree with retrofitting such an interpretation to `CategoryObject`. I've explained my view in[comment:108](#comment%3A108). `CategoryObject` is a technical implementation class. It does not have the mathematical meaning that you are trying to give it.\n\n> > All of that \"is like a container\" and \"models a set\" are just didactical simplifications that don't capture the full story.\n\n> \n> True, but by being a subclass, the implementation is agreeing to follow the requirements given by the base (`Parent` `:p`) class.\n\n\nNo, it's not established at all that `Parent` defines `__contains__` to mean the set-theoretic \"element-of\" relation. That's only true for a `Parent` in the category of `Sets`.",
    "created_at": "2022-09-14T06:56:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672144",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:148'></a>
Replying to [Travis Scrimshaw](#comment%3A147):
> Replying to [Matthias Köppe](#comment%3A146):
> > I disagree. 
> > 
> > In my opinion, the best way to think about what a `Parent` is, is something that makes sense as domain and codomain of morphisms. 

> 
> I think this is what `CategoryObject` should become. There are some vestiges of this, but it isn't supported (yet).


No, I disagree with retrofitting such an interpretation to `CategoryObject`. I've explained my view in[comment:108](#comment%3A108). `CategoryObject` is a technical implementation class. It does not have the mathematical meaning that you are trying to give it.

> > All of that "is like a container" and "models a set" are just didactical simplifications that don't capture the full story.

> 
> True, but by being a subclass, the implementation is agreeing to follow the requirements given by the base (`Parent` `:p`) class.


No, it's not established at all that `Parent` defines `__contains__` to mean the set-theoretic "element-of" relation. That's only true for a `Parent` in the category of `Sets`.



---

archive/issue_comments_672145.json:
```json
{
    "body": "<a id='comment:149'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A148):\n> Replying to [Travis Scrimshaw](#comment%3A147):\n> > I think this is what `CategoryObject` should become. There are some vestiges of this, but it isn't supported (yet).\n\n> \n> No, I disagree with retrofitting such an interpretation to `CategoryObject`. I've explained my view in[comment:108](#comment%3A108). `CategoryObject` is a technical implementation class. It does not have the mathematical meaning that you are trying to give it.\n\n\nCurrently, it does not. I am also not suggesting we make `Element` a subclass of `CategoryObject` as-in; some refactoring is required. However, its documentation states\n\n```\nBase class for objects of a category\n```\nand elements belong to a category.\n\nI think this would be the least invasive change needed for this ticket that is not being contrary to our current documentation and implementions.\n\n> > > All of that \"is like a container\" and \"models a set\" are just didactical simplifications that don't capture the full story.\n\n> > \n> > True, but by being a subclass, the implementation is agreeing to follow the requirements given by the base (`Parent` `:p`) class.\n\n> \n> No, it's not established at all that `Parent` defines `__contains__` to mean the set-theoretic \"element-of\" relation. That's only true for a `Parent` in the category of `Sets`.\n\n\nIt sounds like you are proposing to ignore what is in its documentation and the structure of its implementation (and how it is (near?) universally used within Sage). Is that correct?\n\nEdit - Changed my last question as it was not meant to sound sarcastic.",
    "created_at": "2022-09-14T07:07:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672145",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:149'></a>
Replying to [Matthias Köppe](#comment%3A148):
> Replying to [Travis Scrimshaw](#comment%3A147):
> > I think this is what `CategoryObject` should become. There are some vestiges of this, but it isn't supported (yet).

> 
> No, I disagree with retrofitting such an interpretation to `CategoryObject`. I've explained my view in[comment:108](#comment%3A108). `CategoryObject` is a technical implementation class. It does not have the mathematical meaning that you are trying to give it.


Currently, it does not. I am also not suggesting we make `Element` a subclass of `CategoryObject` as-in; some refactoring is required. However, its documentation states

```
Base class for objects of a category
```
and elements belong to a category.

I think this would be the least invasive change needed for this ticket that is not being contrary to our current documentation and implementions.

> > > All of that "is like a container" and "models a set" are just didactical simplifications that don't capture the full story.

> > 
> > True, but by being a subclass, the implementation is agreeing to follow the requirements given by the base (`Parent` `:p`) class.

> 
> No, it's not established at all that `Parent` defines `__contains__` to mean the set-theoretic "element-of" relation. That's only true for a `Parent` in the category of `Sets`.


It sounds like you are proposing to ignore what is in its documentation and the structure of its implementation (and how it is (near?) universally used within Sage). Is that correct?

Edit - Changed my last question as it was not meant to sound sarcastic.



---

archive/issue_comments_672146.json:
```json
{
    "body": "<a id='comment:150'></a>\nReplying to [Travis Scrimshaw](#comment%3A149):\n> Replying to [Matthias K\u00f6ppe](#comment%3A148):\n> > `CategoryObject` is a technical implementation class. It does not have the mathematical meaning that you are trying to give it.\n\n> \n> Currently, it does not.\n\n\nYes, and my point is, don't try to change it on the basis of a narrow theory about what a `Parent` is.",
    "created_at": "2022-09-14T07:14:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672146",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:150'></a>
Replying to [Travis Scrimshaw](#comment%3A149):
> Replying to [Matthias Köppe](#comment%3A148):
> > `CategoryObject` is a technical implementation class. It does not have the mathematical meaning that you are trying to give it.

> 
> Currently, it does not.


Yes, and my point is, don't try to change it on the basis of a narrow theory about what a `Parent` is.



---

archive/issue_comments_672147.json:
```json
{
    "body": "<a id='comment:151'></a>\nReplying to [Travis Scrimshaw](#comment%3A149):\n> It sounds like you are proposing to ignore what is in its documentation and the structure of its implementation (and how it is (near?) universally used within Sage).\n\n\n`Parent` probably contains a lot of legacy code that predates the category framework. I'd urge not to put too much weight on such implementation details.",
    "created_at": "2022-09-14T07:18:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672147",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:151'></a>
Replying to [Travis Scrimshaw](#comment%3A149):
> It sounds like you are proposing to ignore what is in its documentation and the structure of its implementation (and how it is (near?) universally used within Sage).


`Parent` probably contains a lot of legacy code that predates the category framework. I'd urge not to put too much weight on such implementation details.



---

archive/issue_comments_672148.json:
```json
{
    "body": "<a id='comment:152'></a>\nReplying to [Travis Scrimshaw](#comment%3A144):\n> Replying to [Matthias K\u00f6ppe](#comment%3A142):\n> > I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. \n> > Whether something is \"empty as a set\" or \"in principle doesn't have elements\" is probably a distinction that is not important enough to model in our code.\n\n> \n> [...] A `NotImplementedError` (possibly a `AttributeError` if called directly) sends a very different signal than an `EmptySetError` or a `ValueError`. \n\n\nYou are right; instead of \"leaving it unimplemented\", I should have said \"always raising a `ValueError`\".",
    "created_at": "2022-09-14T07:28:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672148",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:152'></a>
Replying to [Travis Scrimshaw](#comment%3A144):
> Replying to [Matthias Köppe](#comment%3A142):
> > I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. 
> > Whether something is "empty as a set" or "in principle doesn't have elements" is probably a distinction that is not important enough to model in our code.

> 
> [...] A `NotImplementedError` (possibly a `AttributeError` if called directly) sends a very different signal than an `EmptySetError` or a `ValueError`. 


You are right; instead of "leaving it unimplemented", I should have said "always raising a `ValueError`".



---

archive/issue_comments_672149.json:
```json
{
    "body": "<a id='comment:153'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A151):\n> Replying to [Travis Scrimshaw](#comment%3A149):\n> > It sounds like you are proposing to ignore what is in its documentation and the structure of its implementation (and how it is (near?) universally used within Sage).\n\n> \n> `Parent` probably contains a lot of legacy code that predates the category framework. I'd urge not to put too much weight on such implementation details.\n\n\nThe current design of `Parent` is primarily based around the coercion system. In particular, it is designed to be a set with elements, which is also reflected in its documentation. The legacy parts of it are methods like `base_ring()` that are there in general but need to be fast (and possibly time-consuming to refactor out).\n\nWhat we are seeing is the need for a different class hierarchy that supports elements actually being objects in a category.\n\nRight now, we have:\n\n```\nSageObject  (a generic object in Sage)\n+ CategoryObject  (a technical class)\n| + Parent  (a container class for elements)\n+ Element  (an element of a Parent)\n```\nI don't actually see the point of having `CategoryObject` being a technical class. It has only one \"real\" subclass: `Parent` (comment:113). (Note that `SageObject` has other subclasses not listed.)\n\nWhat I am proposing is something like the following:\n\n```\nSageObject (generic object in Sage)\n+ CategoryObject (an generic object in a generic category)\n  + Element (an element of a parent)\n  + Parent (an object in a concrete category)\n```\nSo we would the old `CategoryObject` would merge the elements that treat it like a set with `Parent` (e.g., `gens()`, `base_ring()`). For legacy reasons, we can a class in between `CategoryObject` and `Parent`.\n\nAdvantages:\n\n- We have a clear mathematical meaning matching their name and their doc.\n- Elements can now easily have morphisms between them (changing the type of `Map._codomain`) without major refactoring.\n- Potentially less pollution of the tab-completion name space with unimplemented/unrelated methods.\n- It requires very little coding.\n- We might even be able to have the result of `Element.category()` return the parent.\n\nDisadvantages:\n\n- Elements might have to have a category initialized when created. Although if the parent becomes the category, then this is moot.\n- There are more base classes for `Element`, and it might become a heavier class (I don't think it will though).",
    "created_at": "2022-09-14T07:45:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672149",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:153'></a>
Replying to [Matthias Köppe](#comment%3A151):
> Replying to [Travis Scrimshaw](#comment%3A149):
> > It sounds like you are proposing to ignore what is in its documentation and the structure of its implementation (and how it is (near?) universally used within Sage).

> 
> `Parent` probably contains a lot of legacy code that predates the category framework. I'd urge not to put too much weight on such implementation details.


The current design of `Parent` is primarily based around the coercion system. In particular, it is designed to be a set with elements, which is also reflected in its documentation. The legacy parts of it are methods like `base_ring()` that are there in general but need to be fast (and possibly time-consuming to refactor out).

What we are seeing is the need for a different class hierarchy that supports elements actually being objects in a category.

Right now, we have:

```
SageObject  (a generic object in Sage)
+ CategoryObject  (a technical class)
| + Parent  (a container class for elements)
+ Element  (an element of a Parent)
```
I don't actually see the point of having `CategoryObject` being a technical class. It has only one "real" subclass: `Parent` (comment:113). (Note that `SageObject` has other subclasses not listed.)

What I am proposing is something like the following:

```
SageObject (generic object in Sage)
+ CategoryObject (an generic object in a generic category)
  + Element (an element of a parent)
  + Parent (an object in a concrete category)
```
So we would the old `CategoryObject` would merge the elements that treat it like a set with `Parent` (e.g., `gens()`, `base_ring()`). For legacy reasons, we can a class in between `CategoryObject` and `Parent`.

Advantages:

- We have a clear mathematical meaning matching their name and their doc.
- Elements can now easily have morphisms between them (changing the type of `Map._codomain`) without major refactoring.
- Potentially less pollution of the tab-completion name space with unimplemented/unrelated methods.
- It requires very little coding.
- We might even be able to have the result of `Element.category()` return the parent.

Disadvantages:

- Elements might have to have a category initialized when created. Although if the parent becomes the category, then this is moot.
- There are more base classes for `Element`, and it might become a heavier class (I don't think it will though).



---

archive/issue_comments_672150.json:
```json
{
    "body": "<a id='comment:154'></a>\nReplying to [Travis Scrimshaw](#comment%3A153):\n> The current design of `Parent` is primarily based around the coercion system.\n> In particular, it is designed to be a set with elements, which is also reflected in its documentation. The legacy parts of it are methods like `base_ring()` that are there in general but need to be fast (and possibly time-consuming to refactor out).\n\n\nI think actually that it would make sense to set up the coercion system at a higher level (if we decide to have one).\nOf course, coercion is important for dealing with elements but it is also meaningful for parents themselves, e.g. for dealing with morphisms. For instance if `f : A -> B` and `g : C -> D` are morphisms (in some category) and `B` coerces to `C`, the composite `g*f` could make sense. \n\n> What we are seeing is the need for a different class hierarchy that supports elements actually being objects in a category.\n\n\nI don't see this.\nFor me, Drinfeld modules really live at the level of parents, even though they are modeled by morphisms: a Drinfeld module is defined by a ring homomorphism but it is a different object (e.g. we do not want to apply the same operations on them) and making the confusion may be dangerous.\n\n> Right now, we have:\n> \n> ```\n> SageObject  (a generic object in Sage)\n> + CategoryObject  (a technical class)\n> | + Parent  (a container class for elements)\n> + Element  (an element of a Parent)\n> ```\n> I don't actually see the point of having `CategoryObject` being a technical class. It has only one \"real\" subclass: `Parent` (comment:113). (Note that `SageObject` has other subclasses not listed.)\n\n\nI'm happy with this organization and doesn't want to change it. In particular, I don't want to make `Element` a subclass of `CategoryObject` as you proposed.\n\nIn my understanding, `CategoryObject` could be a class for parents without elements (I understand that it is not the case currently, I mean that ideally it could be). But if you say that it's already okay to have parents without elements, I just propose to get rid of this class `CategoryObject` (which is apparently almost not used).",
    "created_at": "2022-09-14T08:12:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672150",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:154'></a>
Replying to [Travis Scrimshaw](#comment%3A153):
> The current design of `Parent` is primarily based around the coercion system.
> In particular, it is designed to be a set with elements, which is also reflected in its documentation. The legacy parts of it are methods like `base_ring()` that are there in general but need to be fast (and possibly time-consuming to refactor out).


I think actually that it would make sense to set up the coercion system at a higher level (if we decide to have one).
Of course, coercion is important for dealing with elements but it is also meaningful for parents themselves, e.g. for dealing with morphisms. For instance if `f : A -> B` and `g : C -> D` are morphisms (in some category) and `B` coerces to `C`, the composite `g*f` could make sense. 

> What we are seeing is the need for a different class hierarchy that supports elements actually being objects in a category.


I don't see this.
For me, Drinfeld modules really live at the level of parents, even though they are modeled by morphisms: a Drinfeld module is defined by a ring homomorphism but it is a different object (e.g. we do not want to apply the same operations on them) and making the confusion may be dangerous.

> Right now, we have:
> 
> ```
> SageObject  (a generic object in Sage)
> + CategoryObject  (a technical class)
> | + Parent  (a container class for elements)
> + Element  (an element of a Parent)
> ```
> I don't actually see the point of having `CategoryObject` being a technical class. It has only one "real" subclass: `Parent` (comment:113). (Note that `SageObject` has other subclasses not listed.)


I'm happy with this organization and doesn't want to change it. In particular, I don't want to make `Element` a subclass of `CategoryObject` as you proposed.

In my understanding, `CategoryObject` could be a class for parents without elements (I understand that it is not the case currently, I mean that ideally it could be). But if you say that it's already okay to have parents without elements, I just propose to get rid of this class `CategoryObject` (which is apparently almost not used).



---

archive/issue_comments_672151.json:
```json
{
    "body": "<a id='comment:5'></a>\nIt is very clearly documented that a parent has elements:\n\n> Parents are the Sage/mathematical analogues of container objects in computer science.\n\n\nThe class is designed for objects that have elements, and the entire implementation supports that. A Drinfeld module is definitely not a `Parent`. You need a new class for something that has morphisms but not elements. The set of such objects is a set (a small category) and the `Category` class is not designed to be used to model such things, but `Parent` is with objects being `Element`.",
    "created_at": "2022-09-14T08:21:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672151",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:5'></a>
It is very clearly documented that a parent has elements:

> Parents are the Sage/mathematical analogues of container objects in computer science.


The class is designed for objects that have elements, and the entire implementation supports that. A Drinfeld module is definitely not a `Parent`. You need a new class for something that has morphisms but not elements. The set of such objects is a set (a small category) and the `Category` class is not designed to be used to model such things, but `Parent` is with objects being `Element`.



---

archive/issue_comments_672152.json:
```json
{
    "body": "<a id='comment:156'></a>\nReplying to [Travis Scrimshaw](#comment%3A155):\n> It is very clearly documented that a parent has elements:\n> \n> > Parents are the Sage/mathematical analogues of container objects in computer science.\n\n\nThat's true but we can always update the documentation :-).\n\n> The class is designed for objects that have elements, and the entire implementation supports that. A Drinfeld module is definitely not a `Parent`. You need a new class for something that has morphisms but not elements. The set of such objects is a set (a small category) and the `Category` class is not designed to be used to model such things, but `Parent` is with objects being `Element`.\n\n\nI'm certainly fine with using a new class for this; it could be `CategoryObject` but it could also be something else, I don't really care (though I think that the name `CategoryObject` is very well suited). But if it's not needed, I prefer not reorganizing the complete Sage's classes hierarchy and I still don't understand why simply using `Parent` is not good. Okay, there is no element and it is written in the documentation that `Parent`s have `Element`s but, apart from this, would this be the source of concrete issues?",
    "created_at": "2022-09-14T08:29:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672152",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:156'></a>
Replying to [Travis Scrimshaw](#comment%3A155):
> It is very clearly documented that a parent has elements:
> 
> > Parents are the Sage/mathematical analogues of container objects in computer science.


That's true but we can always update the documentation :-).

> The class is designed for objects that have elements, and the entire implementation supports that. A Drinfeld module is definitely not a `Parent`. You need a new class for something that has morphisms but not elements. The set of such objects is a set (a small category) and the `Category` class is not designed to be used to model such things, but `Parent` is with objects being `Element`.


I'm certainly fine with using a new class for this; it could be `CategoryObject` but it could also be something else, I don't really care (though I think that the name `CategoryObject` is very well suited). But if it's not needed, I prefer not reorganizing the complete Sage's classes hierarchy and I still don't understand why simply using `Parent` is not good. Okay, there is no element and it is written in the documentation that `Parent`s have `Element`s but, apart from this, would this be the source of concrete issues?



---

archive/issue_comments_672153.json:
```json
{
    "body": "<a id='comment:157'></a>\nReplying to [Xavier Caruso](#comment%3A156):\n> Replying to [Travis Scrimshaw](#comment%3A155):\n> > It is very clearly documented that a parent has elements:\n> > \n> > > Parents are the Sage/mathematical analogues of container objects in computer science.\n\n> \n> That's true but we can always update the documentation :-).\n\n\nAnd you can always update the code too. However, the implementation and uses also speaks volumes. `;)`\n\n> > The class is designed for objects that have elements, and the entire implementation supports that. A Drinfeld module is definitely not a `Parent`. You need a new class for something that has morphisms but not elements. The set of such objects is a set (a small category) and the `Category` class is not designed to be used to model such things, but `Parent` is with objects being `Element`.\n\n> \n> I'm certainly fine with using a new class for this; it could be `CategoryObject` but it could also be something else, I don't really care (though I think that the name `CategoryObject` is very well suited). But if it's not needed, I prefer not reorganizing the complete Sage's classes hierarchy and I still don't understand why simply using `Parent` is not good. Okay, there is no element and it is written in the documentation that `Parent`s have `Element`s but, apart from this, would this be the source of concrete issues?\n\n\nSo you don't find any of these to be reasons why it is not good:\n\n- is used contrary to the documentation (and essentially all other uses within Sage),\n- many of the methods will not work, including with errors that are saying things should be implemented (see `NotImplementedError` from the element constructor),\n- at any given time, `Parent` would be well within its rights to enforce the set-like behavior and break your code,\n- it leads to an abuse of the `Category` implementation (the two biggest to me are: there is a distinguished implementation for its objects; it duplicates a lot of what `Parent` does) ,\n- it sets a bad precedent that roughly say \"because there is one feature we really want, we can use a class however we want\".\n\nLet me be clear, I don't see any way I will budge from my position here. I am trying my hardest to give you solutions that are acceptable to me with minimal effort (and I am willing to implement, which I don't think I made clear). If you want to take this to sage-devel for a discussion/vote because you think we will remain at an impasse, we can.",
    "created_at": "2022-09-14T10:07:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672153",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:157'></a>
Replying to [Xavier Caruso](#comment%3A156):
> Replying to [Travis Scrimshaw](#comment%3A155):
> > It is very clearly documented that a parent has elements:
> > 
> > > Parents are the Sage/mathematical analogues of container objects in computer science.

> 
> That's true but we can always update the documentation :-).


And you can always update the code too. However, the implementation and uses also speaks volumes. `;)`

> > The class is designed for objects that have elements, and the entire implementation supports that. A Drinfeld module is definitely not a `Parent`. You need a new class for something that has morphisms but not elements. The set of such objects is a set (a small category) and the `Category` class is not designed to be used to model such things, but `Parent` is with objects being `Element`.

> 
> I'm certainly fine with using a new class for this; it could be `CategoryObject` but it could also be something else, I don't really care (though I think that the name `CategoryObject` is very well suited). But if it's not needed, I prefer not reorganizing the complete Sage's classes hierarchy and I still don't understand why simply using `Parent` is not good. Okay, there is no element and it is written in the documentation that `Parent`s have `Element`s but, apart from this, would this be the source of concrete issues?


So you don't find any of these to be reasons why it is not good:

- is used contrary to the documentation (and essentially all other uses within Sage),
- many of the methods will not work, including with errors that are saying things should be implemented (see `NotImplementedError` from the element constructor),
- at any given time, `Parent` would be well within its rights to enforce the set-like behavior and break your code,
- it leads to an abuse of the `Category` implementation (the two biggest to me are: there is a distinguished implementation for its objects; it duplicates a lot of what `Parent` does) ,
- it sets a bad precedent that roughly say "because there is one feature we really want, we can use a class however we want".

Let me be clear, I don't see any way I will budge from my position here. I am trying my hardest to give you solutions that are acceptable to me with minimal effort (and I am willing to implement, which I don't think I made clear). If you want to take this to sage-devel for a discussion/vote because you think we will remain at an impasse, we can.



---

archive/issue_comments_672154.json:
```json
{
    "body": "<a id='comment:158'></a>\nReplying to [Travis Scrimshaw](#comment%3A155):\n> It is very clearly documented that a parent has elements:\n> \n> > Parents are the Sage/mathematical analogues of container objects in computer science.\n\n\nI have already explained in[comment:146](#comment%3A146) that this is a didactical simplification.",
    "created_at": "2022-09-14T14:25:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672154",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:158'></a>
Replying to [Travis Scrimshaw](#comment%3A155):
> It is very clearly documented that a parent has elements:
> 
> > Parents are the Sage/mathematical analogues of container objects in computer science.


I have already explained in[comment:146](#comment%3A146) that this is a didactical simplification.



---

archive/issue_comments_672155.json:
```json
{
    "body": "<a id='comment:159'></a>\nReplying to [Travis Scrimshaw](#comment%3A153):\n> The current design of `Parent` is primarily based around the coercion system. \n\n\nYes, and the mechanism for discovering coercion morphisms between parents and the way that parents participate in the pushout construction are very important even if the morphisms are never called on an element.\n\nSee again #34461.\n\n> In particular, it is designed to be a set with elements, which is also reflected in its documentation. \n\n\nDidactical simplification.",
    "created_at": "2022-09-14T14:36:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672155",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:159'></a>
Replying to [Travis Scrimshaw](#comment%3A153):
> The current design of `Parent` is primarily based around the coercion system. 


Yes, and the mechanism for discovering coercion morphisms between parents and the way that parents participate in the pushout construction are very important even if the morphisms are never called on an element.

See again #34461.

> In particular, it is designed to be a set with elements, which is also reflected in its documentation. 


Didactical simplification.



---

archive/issue_comments_672156.json:
```json
{
    "body": "<a id='comment:160'></a>\nReplying to [Travis Scrimshaw](#comment%3A153):\n> What I am proposing is something like the following:\n> \n> ```\n> SageObject (generic object in Sage)\n> + CategoryObject (an generic object in a generic category)\n>   + Element (an element of a parent)\n>   + Parent (an object in a concrete category)\n> ```\n> So we would the old `CategoryObject` would merge the elements that treat it like a set with `Parent` (e.g., `gens()`, `base_ring()`). For legacy reasons, we can a class in between `CategoryObject` and `Parent`.\n> \n> Advantages:\n> [...]\n> - Elements can now easily have morphisms between them (changing the type of `Map._codomain`) without major refactoring.\n\n\nThere would indeed be a value in allowing an Element to be the domain or codomain of morphisms.\n\nI actually have a strong use case for this: a `Polyhedron` mathematically clearly is a set, but it is implemented as an `Element`, which is in part motivated by an algebra structure on families of polyhedra.\nBut we would also like to be able to set up a morphism (say, in the category of topological spaces) from a polyhedron to another polyhedron. This is not possible currently.\n\nBut it feels that this is a separate issue. So I think we should have a new ticket where we discuss a design that supports such use cases.",
    "created_at": "2022-09-14T14:48:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672156",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:160'></a>
Replying to [Travis Scrimshaw](#comment%3A153):
> What I am proposing is something like the following:
> 
> ```
> SageObject (generic object in Sage)
> + CategoryObject (an generic object in a generic category)
>   + Element (an element of a parent)
>   + Parent (an object in a concrete category)
> ```
> So we would the old `CategoryObject` would merge the elements that treat it like a set with `Parent` (e.g., `gens()`, `base_ring()`). For legacy reasons, we can a class in between `CategoryObject` and `Parent`.
> 
> Advantages:
> [...]
> - Elements can now easily have morphisms between them (changing the type of `Map._codomain`) without major refactoring.


There would indeed be a value in allowing an Element to be the domain or codomain of morphisms.

I actually have a strong use case for this: a `Polyhedron` mathematically clearly is a set, but it is implemented as an `Element`, which is in part motivated by an algebra structure on families of polyhedra.
But we would also like to be able to set up a morphism (say, in the category of topological spaces) from a polyhedron to another polyhedron. This is not possible currently.

But it feels that this is a separate issue. So I think we should have a new ticket where we discuss a design that supports such use cases.



---

archive/issue_comments_672157.json:
```json
{
    "body": "<a id='comment:161'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A159):\n> Replying to [Travis Scrimshaw](#comment%3A153):\n> > The current design of `Parent` is primarily based around the coercion system. \n\n> \n> Yes, and the mechanism for discovering coercion morphisms between parents and the way that parents participate in the pushout construction are very important even if the morphisms are never called on an element.\n\n\nThe pushout constructions are a separate thing as it is built from manipulating functors. It is used by the coercion system to construct a `Parent` `N` that contains two elements in different `Parent`s `X` and `Y`. But it is only evoked when there is no coercion, nor does it create one between the parents `X` and `Y`. All we would really need is the `construction()` method for this to be extended to any object.\n\n> > In particular, it is designed to be a set with elements, which is also reflected in its documentation. \n\n> \n> Didactical simplification.\n\n\nReplying to [Matthias K\u00f6ppe](#comment%3A158):\n> Replying to [Travis Scrimshaw](#comment%3A155):\n> > It is very clearly documented that a parent has elements:\n> > \n> > > Parents are the Sage/mathematical analogues of container objects in computer science.\n\n> \n> I have already explained in[comment:146](#comment%3A146) that this is a didactical simplification.\n\n\nYou are not disputing it is correct. By allowing something that is clearly not meant to be a container object would be ignoring this completely (and again, the implementation details of the class). Anytime I hear someone say, \"parts of this class can be used in broader generality,\" this means you should be refactoring things out, not \"let's use this class anyways as-is, even if this is a [spacebar](https://xkcd.com/1172/).\" (It isn't that extreme here, but that is the underlying logic of the argument.)",
    "created_at": "2022-09-15T00:02:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672157",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:161'></a>
Replying to [Matthias Köppe](#comment%3A159):
> Replying to [Travis Scrimshaw](#comment%3A153):
> > The current design of `Parent` is primarily based around the coercion system. 

> 
> Yes, and the mechanism for discovering coercion morphisms between parents and the way that parents participate in the pushout construction are very important even if the morphisms are never called on an element.


The pushout constructions are a separate thing as it is built from manipulating functors. It is used by the coercion system to construct a `Parent` `N` that contains two elements in different `Parent`s `X` and `Y`. But it is only evoked when there is no coercion, nor does it create one between the parents `X` and `Y`. All we would really need is the `construction()` method for this to be extended to any object.

> > In particular, it is designed to be a set with elements, which is also reflected in its documentation. 

> 
> Didactical simplification.


Replying to [Matthias Köppe](#comment%3A158):
> Replying to [Travis Scrimshaw](#comment%3A155):
> > It is very clearly documented that a parent has elements:
> > 
> > > Parents are the Sage/mathematical analogues of container objects in computer science.

> 
> I have already explained in[comment:146](#comment%3A146) that this is a didactical simplification.


You are not disputing it is correct. By allowing something that is clearly not meant to be a container object would be ignoring this completely (and again, the implementation details of the class). Anytime I hear someone say, "parts of this class can be used in broader generality," this means you should be refactoring things out, not "let's use this class anyways as-is, even if this is a [spacebar](https://xkcd.com/1172/)." (It isn't that extreme here, but that is the underlying logic of the argument.)



---

archive/issue_comments_672158.json:
```json
{
    "body": "<a id='comment:2'></a>\nNo, Travis, what's not correct is trying to use this didactical explanation as a definition, and pretending that it canonically extends to what your interpretation is.",
    "created_at": "2022-09-15T00:26:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672158",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:2'></a>
No, Travis, what's not correct is trying to use this didactical explanation as a definition, and pretending that it canonically extends to what your interpretation is.



---

archive/issue_comments_672159.json:
```json
{
    "body": "<a id='comment:163'></a>\nReplying to [Travis Scrimshaw](#comment%3A147):\n> > Consider two implementation classes that implement `Scheme`s - one whose instances are schemes that always have points (elements), one that never has points (elements). \n> > You don't want to say that one of them should be a `Parent`, the other one shouldn't be a `Parent`.\n\n> \n> They should both be `Parent`s. One of which is just an empty set (plus some additional structure).\n\n\nGood that we agree on this; my point is that the empty one does not need an element class, and its element constructor can always raise an error.",
    "created_at": "2022-09-15T00:36:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672159",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:163'></a>
Replying to [Travis Scrimshaw](#comment%3A147):
> > Consider two implementation classes that implement `Scheme`s - one whose instances are schemes that always have points (elements), one that never has points (elements). 
> > You don't want to say that one of them should be a `Parent`, the other one shouldn't be a `Parent`.

> 
> They should both be `Parent`s. One of which is just an empty set (plus some additional structure).


Good that we agree on this; my point is that the empty one does not need an element class, and its element constructor can always raise an error.



---

archive/issue_comments_672160.json:
```json
{
    "body": "<a id='comment:4'></a>\nNo, Matthias, you can't just ignore documentation (and the implementation) when it doesn't suit you. All documentation  is didactic; it is teaching you what the class is designed for and to be treated as. I can make an argument for anything to be \"a simplification of something more general.\" Using beyond the documentation is bad practice; this is what subclasses are for.",
    "created_at": "2022-09-15T00:43:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672160",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:4'></a>
No, Matthias, you can't just ignore documentation (and the implementation) when it doesn't suit you. All documentation  is didactic; it is teaching you what the class is designed for and to be treated as. I can make an argument for anything to be "a simplification of something more general." Using beyond the documentation is bad practice; this is what subclasses are for.



---

archive/issue_comments_672161.json:
```json
{
    "body": "<a id='comment:165'></a>\nReplying to [Travis Scrimshaw](#comment%3A164):\n> No, Matthias, you can't just ignore documentation (and the implementation) when it doesn't suit you.\n\n\nIt's poorly written, which leads you to your mistaken interpretation.",
    "created_at": "2022-09-15T00:48:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672161",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:165'></a>
Replying to [Travis Scrimshaw](#comment%3A164):
> No, Matthias, you can't just ignore documentation (and the implementation) when it doesn't suit you.


It's poorly written, which leads you to your mistaken interpretation.



---

archive/issue_comments_672162.json:
```json
{
    "body": "<a id='comment:6'></a>\nReplying to [Travis Scrimshaw](#comment%3A153):\n> What I am proposing is something like the following:\n> \n> ```\n> SageObject (generic object in Sage)\n> + CategoryObject (an generic object in a generic category)\n>   + Element (an element of a parent)\n>   + Parent (an object in a concrete category)\n> ```\n\n\nStrong -1 on that. An object that is an `Element` must continue to refer to its parent to get the category if it refers to its role as an element of that parent.\n\nYour proposed change of the design would rule out the possibility that an `Element` can also have the role of a `Parent`. (This is currently not possible, I think, but only because of an implementation restriction due to Cython extension classes.)",
    "created_at": "2022-09-15T00:51:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672162",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:6'></a>
Replying to [Travis Scrimshaw](#comment%3A153):
> What I am proposing is something like the following:
> 
> ```
> SageObject (generic object in Sage)
> + CategoryObject (an generic object in a generic category)
>   + Element (an element of a parent)
>   + Parent (an object in a concrete category)
> ```


Strong -1 on that. An object that is an `Element` must continue to refer to its parent to get the category if it refers to its role as an element of that parent.

Your proposed change of the design would rule out the possibility that an `Element` can also have the role of a `Parent`. (This is currently not possible, I think, but only because of an implementation restriction due to Cython extension classes.)



---

archive/issue_comments_672163.json:
```json
{
    "body": "<a id='comment:7'></a>\nIn my example with polyhedra, I would like to have for example\na semigroup (parent) of polyhedra (element), but each polyhedron is also a parent whose element class is a point.\nThere are 3 separate categories involved: \n- Semigroups\n- Join of Topological Spaces, Elements of semigroups \n- Elements of Topological Spaces",
    "created_at": "2022-09-15T00:57:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672163",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:7'></a>
In my example with polyhedra, I would like to have for example
a semigroup (parent) of polyhedra (element), but each polyhedron is also a parent whose element class is a point.
There are 3 separate categories involved: 
- Semigroups
- Join of Topological Spaces, Elements of semigroups 
- Elements of Topological Spaces



---

archive/issue_comments_672164.json:
```json
{
    "body": "<a id='comment:8'></a>\nBy the way, I haven't recently looked at the branch here on the ticket. In particular, in particular I haven't looked at what it does with `Category`. But I \n- object to your use of these overreaching claims on the illegitimacy of `Parent`s without `Element`s as an argument; and \n- I would urge not to demand that work here can only be done after a refactoring that retrofits `CategoryObject` with a mathematical meaning is done.",
    "created_at": "2022-09-15T01:08:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672164",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:8'></a>
By the way, I haven't recently looked at the branch here on the ticket. In particular, in particular I haven't looked at what it does with `Category`. But I 
- object to your use of these overreaching claims on the illegitimacy of `Parent`s without `Element`s as an argument; and 
- I would urge not to demand that work here can only be done after a refactoring that retrofits `CategoryObject` with a mathematical meaning is done.



---

archive/issue_comments_672165.json:
```json
{
    "body": "<a id='comment:9'></a>\nI've opened #34534 for a discussion focused on what a `Parent` is and what refactoring may be necessary to cover use cases that I explain in[comment:166](#comment%3A166),[comment:167](#comment%3A167).",
    "created_at": "2022-09-15T01:20:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672165",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:9'></a>
I've opened #34534 for a discussion focused on what a `Parent` is and what refactoring may be necessary to cover use cases that I explain in[comment:166](#comment%3A166),[comment:167](#comment%3A167).



---

archive/issue_comments_672166.json:
```json
{
    "body": "<a id='comment:170'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A166):\n> Replying to [Travis Scrimshaw](#comment%3A153):\n> > What I am proposing is something like the following:\n> > \n> > ```\n> > SageObject (generic object in Sage)\n> > + CategoryObject (an generic object in a generic category)\n> >   + Element (an element of a parent)\n> >   + Parent (an object in a concrete category)\n> > ```\n\n> \n> Strong -1 on that. An object that is an `Element` must continue to refer to its parent to get the category if it refers to its role as an element of that parent.\n\n\nI don't see what is changing other than potentially `Element.category()` returning the parent instead of the `Elements` category (which I am not 100% sold on doing). The category of the parent and the structure is embedded as part of its MRO through dynamic classes. This part doesn't change.\n\n> Your proposed change of the design would rule out the possibility that an `Element` can also have the role of a `Parent`. (This is currently not possible, I think, but only because of an implementation restriction due to Cython extension classes.) \n\n\nPerhaps this would be impossible if the category of the element is a `Parent`. This is something that would need to be played around with. I don't see how changing the ABC hierarchy prohibits this.",
    "created_at": "2022-09-15T02:03:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672166",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:170'></a>
Replying to [Matthias Köppe](#comment%3A166):
> Replying to [Travis Scrimshaw](#comment%3A153):
> > What I am proposing is something like the following:
> > 
> > ```
> > SageObject (generic object in Sage)
> > + CategoryObject (an generic object in a generic category)
> >   + Element (an element of a parent)
> >   + Parent (an object in a concrete category)
> > ```

> 
> Strong -1 on that. An object that is an `Element` must continue to refer to its parent to get the category if it refers to its role as an element of that parent.


I don't see what is changing other than potentially `Element.category()` returning the parent instead of the `Elements` category (which I am not 100% sold on doing). The category of the parent and the structure is embedded as part of its MRO through dynamic classes. This part doesn't change.

> Your proposed change of the design would rule out the possibility that an `Element` can also have the role of a `Parent`. (This is currently not possible, I think, but only because of an implementation restriction due to Cython extension classes.) 


Perhaps this would be impossible if the category of the element is a `Parent`. This is something that would need to be played around with. I don't see how changing the ABC hierarchy prohibits this.



---

archive/issue_comments_672167.json:
```json
{
    "body": "<a id='comment:171'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A168):\n> By the way, I haven't recently looked at the branch here on the ticket. In particular, in particular I haven't looked at what it does with `Category`. But I \n> - object to your use of these overreaching claims on the illegitimacy of `Parent`s without `Element`s as an argument; and \n\n\nYou can disagree with the legitimacy of it, but it is far from overreaching. It would be a fundamental change and sets a bad precedent.\n\n> - I would urge not to demand that work here can only be done after a refactoring that retrofits `CategoryObject` with a mathematical meaning is done.\n\n\nWhile perfect can be the enemy of the good, allowing bad practices is not something that should be taken lightly.\n\nAn alternative approach would be to just reimplement the parts of `Map`/`Morphism` for the Drinfeld module morphisms. (I am giving a concession of allowing the use `CategoryObject` too.)",
    "created_at": "2022-09-15T02:16:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672167",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:171'></a>
Replying to [Matthias Köppe](#comment%3A168):
> By the way, I haven't recently looked at the branch here on the ticket. In particular, in particular I haven't looked at what it does with `Category`. But I 
> - object to your use of these overreaching claims on the illegitimacy of `Parent`s without `Element`s as an argument; and 


You can disagree with the legitimacy of it, but it is far from overreaching. It would be a fundamental change and sets a bad precedent.

> - I would urge not to demand that work here can only be done after a refactoring that retrofits `CategoryObject` with a mathematical meaning is done.


While perfect can be the enemy of the good, allowing bad practices is not something that should be taken lightly.

An alternative approach would be to just reimplement the parts of `Map`/`Morphism` for the Drinfeld module morphisms. (I am giving a concession of allowing the use `CategoryObject` too.)



---

archive/issue_comments_672168.json:
```json
{
    "body": "<a id='comment:172'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A169):\n> I've opened #34534 for a discussion focused on what a `Parent` is and what refactoring may be necessary to cover use cases that I explain in[comment:166](#comment%3A166),[comment:167](#comment%3A167).\n\n\nWe can move the discussion there, but until that is resolved (or a sage-devel vote is done), this ticket cannot be positively reviewed while using `Parent`.",
    "created_at": "2022-09-15T02:19:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672168",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:172'></a>
Replying to [Matthias Köppe](#comment%3A169):
> I've opened #34534 for a discussion focused on what a `Parent` is and what refactoring may be necessary to cover use cases that I explain in[comment:166](#comment%3A166),[comment:167](#comment%3A167).


We can move the discussion there, but until that is resolved (or a sage-devel vote is done), this ticket cannot be positively reviewed while using `Parent`.



---

archive/issue_comments_672169.json:
```json
{
    "body": "<a id='comment:173'></a>\nReplying to [Travis Scrimshaw](#comment%3A172):\n> Replying to [Matthias K\u00f6ppe](#comment%3A169):\n> > I've opened #34534 for a discussion focused on what a `Parent` is and what refactoring may be necessary to cover use cases that I explain in[comment:166](#comment%3A166),[comment:167](#comment%3A167).\n\n> \n> We can move the discussion there, but until that is resolved (or a sage-devel vote is done), this ticket cannot be positively reviewed while using `Parent`.\n\n\nWell, this is exactly what I have criticized as improper in[comment:168](#comment%3A168).",
    "created_at": "2022-09-15T02:42:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672169",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:173'></a>
Replying to [Travis Scrimshaw](#comment%3A172):
> Replying to [Matthias Köppe](#comment%3A169):
> > I've opened #34534 for a discussion focused on what a `Parent` is and what refactoring may be necessary to cover use cases that I explain in[comment:166](#comment%3A166),[comment:167](#comment%3A167).

> 
> We can move the discussion there, but until that is resolved (or a sage-devel vote is done), this ticket cannot be positively reviewed while using `Parent`.


Well, this is exactly what I have criticized as improper in[comment:168](#comment%3A168).



---

archive/issue_comments_672170.json:
```json
{
    "body": "<a id='comment:174'></a>\nReplying to [Travis Scrimshaw](#comment%3A171):\n> It would be a fundamental change and sets a bad precedent.\n\n\nI shall presume that this has never been pointed to you: This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that \"Parent with no Element\" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.",
    "created_at": "2022-09-15T02:45:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672170",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:174'></a>
Replying to [Travis Scrimshaw](#comment%3A171):
> It would be a fundamental change and sets a bad precedent.


I shall presume that this has never been pointed to you: This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that "Parent with no Element" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.



---

archive/issue_comments_672171.json:
```json
{
    "body": "<a id='comment:175'></a>\nReplying to [Travis Scrimshaw](#comment%3A161):\n>  Anytime I hear someone say, \"parts of this class can be used in broader generality,\" this means you should be refactoring things out, not \"let's use this class anyways as-is, even if this is [BAD].\n\n\nThat's too generic an argument. Yes, refactoring is good when it is done correctly.\nBut your analysis is too quick and does not lead to the correct result.\nIn #31247#comment:21, you tried to sell me on the foundational importance of `Parent`s that admit multiple `Element` classes. Well, and I say that in my thickest fake American accent, **I'm buying**. When we implement a `Parent` so that it can admit 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK.",
    "created_at": "2022-09-15T02:58:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672171",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:175'></a>
Replying to [Travis Scrimshaw](#comment%3A161):
>  Anytime I hear someone say, "parts of this class can be used in broader generality," this means you should be refactoring things out, not "let's use this class anyways as-is, even if this is [BAD].


That's too generic an argument. Yes, refactoring is good when it is done correctly.
But your analysis is too quick and does not lead to the correct result.
In #31247#comment:21, you tried to sell me on the foundational importance of `Parent`s that admit multiple `Element` classes. Well, and I say that in my thickest fake American accent, **I'm buying**. When we implement a `Parent` so that it can admit 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK.



---

archive/issue_comments_672172.json:
```json
{
    "body": "<a id='comment:176'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A174):\n> Replying to [Travis Scrimshaw](#comment%3A171):\n> > It would be a fundamental change and sets a bad precedent.\n\n> \n> I shall presume that this has never been pointed to you:\n\n\nYou would be wrong, and I also make arguments for why it might be an exceptional circumstance (and do cost/benefit analysis).\n\n> This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that \"Parent with no Element\" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.\n\n\nThis isn't a slippery slope, which says \"if we allow A, then this will lead to B, which will lead to D, which is BAD\". By allowing this, it says \"we can break rule A, so everyone can break rule A\", and there would be no point in having the rule (here, it is following the current documentation and implementation details). If you want to allow the violation, give justification about what makes this case special.",
    "created_at": "2022-09-15T02:58:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672172",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:176'></a>
Replying to [Matthias Köppe](#comment%3A174):
> Replying to [Travis Scrimshaw](#comment%3A171):
> > It would be a fundamental change and sets a bad precedent.

> 
> I shall presume that this has never been pointed to you:


You would be wrong, and I also make arguments for why it might be an exceptional circumstance (and do cost/benefit analysis).

> This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that "Parent with no Element" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.


This isn't a slippery slope, which says "if we allow A, then this will lead to B, which will lead to D, which is BAD". By allowing this, it says "we can break rule A, so everyone can break rule A", and there would be no point in having the rule (here, it is following the current documentation and implementation details). If you want to allow the violation, give justification about what makes this case special.



---

archive/issue_comments_672173.json:
```json
{
    "body": "<a id='comment:177'></a>\nReplying to [Travis Scrimshaw](#comment%3A176):\n> Replying to [Matthias K\u00f6ppe](#comment%3A174):\n> > Replying to [Travis Scrimshaw](#comment%3A171):\n> > > It would be a fundamental change and sets a bad precedent.\n\n> > \n> > I shall presume that this has never been pointed to you:\n\n> \n> You would be wrong, and I also make arguments for why it might be an exceptional circumstance (and do cost/benefit analysis).\n> \n> > This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that \"Parent with no Element\" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.\n\n> \n> This isn't a slippery slope\n\n\nI said \"akin\".",
    "created_at": "2022-09-15T03:02:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672173",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:177'></a>
Replying to [Travis Scrimshaw](#comment%3A176):
> Replying to [Matthias Köppe](#comment%3A174):
> > Replying to [Travis Scrimshaw](#comment%3A171):
> > > It would be a fundamental change and sets a bad precedent.

> > 
> > I shall presume that this has never been pointed to you:

> 
> You would be wrong, and I also make arguments for why it might be an exceptional circumstance (and do cost/benefit analysis).
> 
> > This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that "Parent with no Element" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.

> 
> This isn't a slippery slope


I said "akin".



---

archive/issue_comments_672174.json:
```json
{
    "body": "<a id='comment:178'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A175):\n> Replying to [Travis Scrimshaw](#comment%3A161):\n> >  Anytime I hear someone say, \"parts of this class can be used in broader generality,\" this means you should be refactoring things out, not \"let's use this class anyways as-is, even if this is [BAD].\n\n> \n> That's too generic an argument. Yes, refactoring is good when it is done correctly.\n> But your analysis is too quick and does not lead to the correct result.\n> In #31247#comment:21, you tried to sell me on the foundational importance of `Parent`s that admit multiple `Element` classes. Well, and I say that in my thickest fake American accent, **I'm buying**. When we implement a `Parent` so that it can admits 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. \n\n\nAnd I still believe having multiple `Element` classes for a particular parent is a good thing that we want. However, the positive integers are not nonnegative integers and induction doesn't allow you to go backwards from the base case. If you want to apply a theorem that starts with \"assume there exists X\", you cannot expect it to hold true when X does not exist.",
    "created_at": "2022-09-15T03:04:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672174",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:178'></a>
Replying to [Matthias Köppe](#comment%3A175):
> Replying to [Travis Scrimshaw](#comment%3A161):
> >  Anytime I hear someone say, "parts of this class can be used in broader generality," this means you should be refactoring things out, not "let's use this class anyways as-is, even if this is [BAD].

> 
> That's too generic an argument. Yes, refactoring is good when it is done correctly.
> But your analysis is too quick and does not lead to the correct result.
> In #31247#comment:21, you tried to sell me on the foundational importance of `Parent`s that admit multiple `Element` classes. Well, and I say that in my thickest fake American accent, **I'm buying**. When we implement a `Parent` so that it can admits 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. 


And I still believe having multiple `Element` classes for a particular parent is a good thing that we want. However, the positive integers are not nonnegative integers and induction doesn't allow you to go backwards from the base case. If you want to apply a theorem that starts with "assume there exists X", you cannot expect it to hold true when X does not exist.



---

archive/issue_comments_672175.json:
```json
{
    "body": "<a id='comment:179'></a>\nReplying to [Travis Scrimshaw](#comment%3A176):\n> there would be no point in having the rule (here, it is following the current documentation and implementation details)\n\n\nNo, Travis, you just did it again. You are trying to prove that it's violating a rule (BAD), so it will lead to more BAD things. But what you are presuming is exactly what I dispute. I have clearly said so in[comment:165](#comment%3A165).",
    "created_at": "2022-09-15T03:05:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672175",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:179'></a>
Replying to [Travis Scrimshaw](#comment%3A176):
> there would be no point in having the rule (here, it is following the current documentation and implementation details)


No, Travis, you just did it again. You are trying to prove that it's violating a rule (BAD), so it will lead to more BAD things. But what you are presuming is exactly what I dispute. I have clearly said so in[comment:165](#comment%3A165).



---

archive/issue_comments_672176.json:
```json
{
    "body": "<a id='comment:180'></a>\nReplying to [Travis Scrimshaw](#comment%3A178):\n> > In #31247#comment:21, you tried to sell me on the foundational importance of `Parent`s that admit multiple `Element` classes. Well, and I say that in my thickest fake American accent, **I'm buying**. When we implement a `Parent` so that it can admits 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. \n\n> \n> And I still believe having multiple `Element` classes for a particular parent is a good thing that we want.\n\n\nYes, so do I, that's why I'm buying it!",
    "created_at": "2022-09-15T03:06:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672176",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:180'></a>
Replying to [Travis Scrimshaw](#comment%3A178):
> > In #31247#comment:21, you tried to sell me on the foundational importance of `Parent`s that admit multiple `Element` classes. Well, and I say that in my thickest fake American accent, **I'm buying**. When we implement a `Parent` so that it can admits 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. 

> 
> And I still believe having multiple `Element` classes for a particular parent is a good thing that we want.


Yes, so do I, that's why I'm buying it!



---

archive/issue_comments_672177.json:
```json
{
    "body": "<a id='comment:181'></a>\nReplying to [Travis Scrimshaw](#comment%3A178):\n> However, the positive integers are not nonnegative integers and induction doesn't allow you to go backwards from the base case.\n\n\nPlease, Travis.",
    "created_at": "2022-09-15T03:07:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672177",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:181'></a>
Replying to [Travis Scrimshaw](#comment%3A178):
> However, the positive integers are not nonnegative integers and induction doesn't allow you to go backwards from the base case.


Please, Travis.



---

archive/issue_comments_672178.json:
```json
{
    "body": "<a id='comment:182'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A177):\n> Replying to [Travis Scrimshaw](#comment%3A176):\n> > Replying to [Matthias K\u00f6ppe](#comment%3A174):\n> > > This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that \"Parent with no Element\" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.\n\n> > \n> > This isn't a slippery slope\n\n> \n> I said \"akin\".\n\n\nThen I amend my respond to say \"This isn't akin to a slippery slope\". Although how strongly do you want to make the association?\n\nImagine I took a dollar from your wallet (without asking). This is bad (like all stealing), but you say it is okay because I used it to buy a sip of water (I was dying of thirst in the heat and inflation is so bad, that's all I could afford `:P`). Now someone else sees this and steals a dollar from your wallet and says they bought a sip of water. Is that okay?",
    "created_at": "2022-09-15T03:11:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672178",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:182'></a>
Replying to [Matthias Köppe](#comment%3A177):
> Replying to [Travis Scrimshaw](#comment%3A176):
> > Replying to [Matthias Köppe](#comment%3A174):
> > > This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that "Parent with no Element" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.

> > 
> > This isn't a slippery slope

> 
> I said "akin".


Then I amend my respond to say "This isn't akin to a slippery slope". Although how strongly do you want to make the association?

Imagine I took a dollar from your wallet (without asking). This is bad (like all stealing), but you say it is okay because I used it to buy a sip of water (I was dying of thirst in the heat and inflation is so bad, that's all I could afford `:P`). Now someone else sees this and steals a dollar from your wallet and says they bought a sip of water. Is that okay?



---

archive/issue_comments_672179.json:
```json
{
    "body": "<a id='comment:183'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A181):\n> Replying to [Travis Scrimshaw](#comment%3A178):\n> > However, the positive integers are not nonnegative integers and induction doesn't allow you to go backwards from the base case.\n\n> \n> Please, Travis.\n\n\nNo, really Matthias. That is what your argument is based on: If something is true for `1, 2, 3, ...` it should be true for `0`. If you have another separate argument, please explain.",
    "created_at": "2022-09-15T03:13:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672179",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:183'></a>
Replying to [Matthias Köppe](#comment%3A181):
> Replying to [Travis Scrimshaw](#comment%3A178):
> > However, the positive integers are not nonnegative integers and induction doesn't allow you to go backwards from the base case.

> 
> Please, Travis.


No, really Matthias. That is what your argument is based on: If something is true for `1, 2, 3, ...` it should be true for `0`. If you have another separate argument, please explain.



---

archive/issue_comments_672180.json:
```json
{
    "body": "<a id='comment:4'></a>\nYou know that I know that you know that I know that induction does not work this way. So I don't buy it that you believe you caught me in a fallacious application of mathematical induction.",
    "created_at": "2022-09-15T03:15:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672180",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:4'></a>
You know that I know that you know that I know that induction does not work this way. So I don't buy it that you believe you caught me in a fallacious application of mathematical induction.



---

archive/issue_comments_672181.json:
```json
{
    "body": "<a id='comment:5'></a>\nLook Travis, chatting with you is fun, but you are overdoing your argumentative tactics that it's not so amusing any more in the end. For example[comment:182](#comment%3A182) - obviously the discussion of what \"akin\" means is irrelevant for anything here - and you are using it as a distraction.",
    "created_at": "2022-09-15T03:17:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672181",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:5'></a>
Look Travis, chatting with you is fun, but you are overdoing your argumentative tactics that it's not so amusing any more in the end. For example[comment:182](#comment%3A182) - obviously the discussion of what "akin" means is irrelevant for anything here - and you are using it as a distraction.



---

archive/issue_comments_672182.json:
```json
{
    "body": "<a id='comment:186'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A184):\n> You know that I know that you know that I know that induction does not work this way. So I don't buy it that you believe you caught me in a fallacious application of mathematical induction.\n\n\nYes, I know you know how induction works. However, I am not able to understand how my argument applies to `0` because my argument is based on the existence of at least one distinguished `Element` and induction (there is nothing special about that one particular `Element` class, so we can add one more). I am pointing out that my argument breaks down and needs to be replaced by another one if you want `0` included.",
    "created_at": "2022-09-15T03:44:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672182",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:186'></a>
Replying to [Matthias Köppe](#comment%3A184):
> You know that I know that you know that I know that induction does not work this way. So I don't buy it that you believe you caught me in a fallacious application of mathematical induction.


Yes, I know you know how induction works. However, I am not able to understand how my argument applies to `0` because my argument is based on the existence of at least one distinguished `Element` and induction (there is nothing special about that one particular `Element` class, so we can add one more). I am pointing out that my argument breaks down and needs to be replaced by another one if you want `0` included.



---

archive/issue_comments_672183.json:
```json
{
    "body": "<a id='comment:187'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A185):\n> Look Travis, chatting with you is fun, but you are overdoing your argumentative tactics that it's not so amusing any more in the end. For example[comment:182](#comment%3A182) - obviously the discussion of what \"akin\" means is irrelevant for anything here - and you are using it as a distraction.\n\n\nI am not meaning to; I did not know you meant because I was writing my reply before[comment:179](#comment%3A179) and didn't understand what point you were trying to make.\n\nI would then respond by saying all of the tickets you want to enforce strict compliance with the Python `abc.collections` should be allowed too as they are (at best) weaker breaking of abstract behaviors (I still contend those are fundamentally different because of the weakness of the `isinstance` test).",
    "created_at": "2022-09-15T03:50:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672183",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:187'></a>
Replying to [Matthias Köppe](#comment%3A185):
> Look Travis, chatting with you is fun, but you are overdoing your argumentative tactics that it's not so amusing any more in the end. For example[comment:182](#comment%3A182) - obviously the discussion of what "akin" means is irrelevant for anything here - and you are using it as a distraction.


I am not meaning to; I did not know you meant because I was writing my reply before[comment:179](#comment%3A179) and didn't understand what point you were trying to make.

I would then respond by saying all of the tickets you want to enforce strict compliance with the Python `abc.collections` should be allowed too as they are (at best) weaker breaking of abstract behaviors (I still contend those are fundamentally different because of the weakness of the `isinstance` test).



---

archive/issue_comments_672184.json:
```json
{
    "body": "<a id='comment:188'></a>\nThe solution to the riddle:\n\nReplying to [Matthias K\u00f6ppe](#comment%3A175):\n> When we implement a `Parent` so that it can admit 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. \n\n\nThe context of this was refactoring. Both you and I agree that there must be a class that support 0 `Element` classes (that's your retrofitted `CategoryObject`) and there must be a class that supports 1, 2, 3, ... `Element` classes. Now standard programming wisdoms lead to the conclusion that these \"two classes\" should actually be the same class, namely one that supports 0, 1, 2, 3, ... `Element` classes. Because \"a for loop can also handle 0 iterations\".",
    "created_at": "2022-09-15T04:23:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672184",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:188'></a>
The solution to the riddle:

Replying to [Matthias Köppe](#comment%3A175):
> When we implement a `Parent` so that it can admit 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. 


The context of this was refactoring. Both you and I agree that there must be a class that support 0 `Element` classes (that's your retrofitted `CategoryObject`) and there must be a class that supports 1, 2, 3, ... `Element` classes. Now standard programming wisdoms lead to the conclusion that these "two classes" should actually be the same class, namely one that supports 0, 1, 2, 3, ... `Element` classes. Because "a for loop can also handle 0 iterations".



---

archive/issue_comments_672185.json:
```json
{
    "body": "<a id='comment:189'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A188):\n> The solution to the riddle:\n> \n> Replying to [Matthias K\u00f6ppe](#comment%3A175):\n> > When we implement a `Parent` so that it can admit 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. \n\n> \n> The context of this was refactoring. Both you and I agree that there must be a class that support 0 `Element` classes (that's your retrofitted `CategoryObject`) and there must be a class that supports 1, 2, 3, ... `Element` classes. Now standard programming wisdoms lead to the conclusion that these \"two classes\" should actually be the same class, namely one that supports 0, 1, 2, 3, ... `Element` classes. Because \"a for loop can also handle 0 iterations\".\n\n\nI see what you are saying now. I agree with you here completely. Do you agree that the same wisdom says we should have\n\n```\n+ Foo -- handles 0, 1, 2, ... `Element` classes\n  + Bar -- has specialized code that assumes >= 1 `Element` classes\n```\nFurthermore, do you also agree that subclassing `Bar` when something does have 0 `Element` classes is bad?",
    "created_at": "2022-09-15T04:37:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672185",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:189'></a>
Replying to [Matthias Köppe](#comment%3A188):
> The solution to the riddle:
> 
> Replying to [Matthias Köppe](#comment%3A175):
> > When we implement a `Parent` so that it can admit 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. 

> 
> The context of this was refactoring. Both you and I agree that there must be a class that support 0 `Element` classes (that's your retrofitted `CategoryObject`) and there must be a class that supports 1, 2, 3, ... `Element` classes. Now standard programming wisdoms lead to the conclusion that these "two classes" should actually be the same class, namely one that supports 0, 1, 2, 3, ... `Element` classes. Because "a for loop can also handle 0 iterations".


I see what you are saying now. I agree with you here completely. Do you agree that the same wisdom says we should have

```
+ Foo -- handles 0, 1, 2, ... `Element` classes
  + Bar -- has specialized code that assumes >= 1 `Element` classes
```
Furthermore, do you also agree that subclassing `Bar` when something does have 0 `Element` classes is bad?



---

archive/issue_comments_672186.json:
```json
{
    "body": "<a id='comment:0'></a>\nNo, the same wisdoms would say that you would maybe have a specialized subclass for 0 (for optimization purposes), but not one for >= 1.",
    "created_at": "2022-09-15T04:45:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672186",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:0'></a>
No, the same wisdoms would say that you would maybe have a specialized subclass for 0 (for optimization purposes), but not one for >= 1.



---

archive/issue_comments_672187.json:
```json
{
    "body": "<a id='comment:1'></a>\nMy final remark before I go to bed: Note that the idea of a category that \"does not have an element class\" has no mathematical meaning because the category of elements of a category has a general functorial construction. So the whole thing is a distinction on the level of programming - so the programming wisdoms apply.",
    "created_at": "2022-09-15T04:56:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672187",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:1'></a>
My final remark before I go to bed: Note that the idea of a category that "does not have an element class" has no mathematical meaning because the category of elements of a category has a general functorial construction. So the whole thing is a distinction on the level of programming - so the programming wisdoms apply.



---

archive/issue_comments_672188.json:
```json
{
    "body": "<a id='comment:192'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A190):\n> No, the same wisdoms would say that you would maybe have a specialized subclass for 0 (for optimization purposes), but not one for >= 1.\n\n\nIt looks like there is a misunderstanding here.\n\nCertainly, the class `Foo` (or `Adult` say) should only be used to handle 0 `Element` classes but also certainly `Bar` (or `Parent`) has to inherit for `Foo`.\nIMO, the class `Adult` should implement the coercion mecanism whereas the methods `_element_constructor` and `__call__` should be reserved to `Parent`.",
    "created_at": "2022-09-15T05:49:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672188",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:192'></a>
Replying to [Matthias Köppe](#comment%3A190):
> No, the same wisdoms would say that you would maybe have a specialized subclass for 0 (for optimization purposes), but not one for >= 1.


It looks like there is a misunderstanding here.

Certainly, the class `Foo` (or `Adult` say) should only be used to handle 0 `Element` classes but also certainly `Bar` (or `Parent`) has to inherit for `Foo`.
IMO, the class `Adult` should implement the coercion mecanism whereas the methods `_element_constructor` and `__call__` should be reserved to `Parent`.



---

archive/issue_comments_672189.json:
```json
{
    "body": "<a id='comment:193'></a>\nReplying to [Xavier Caruso](#comment%3A192):\n> Replying to [Matthias K\u00f6ppe](#comment%3A190):\n> > No, the same wisdoms would say that you would maybe have a specialized subclass for 0 (for optimization purposes), but not one for >= 1.\n\n> \n> It looks like there is a misunderstanding here.\n> \n> Certainly, the class `Foo` (or `Adult` say) should only be used to handle 0 `Element` classes but also certainly `Bar` (or `Parent`) has to inherit for `Foo`.\n> IMO, the class `Adult` should implement the coercion mecanism whereas the methods `_element_constructor` and `__call__` should be reserved to `Parent`.\n\n\nI agree with Xavier here. Other examples: We could have `Polytope` (i.e., a bounded polyhedron) as a subclass of `Polyhedron` as it is a specialized version where we could optimize things and have additional special methods (such as the Ehrhart polynomial). Or like the `CommutativeRing` subclass of `Ring`. Subclasses are for things that have additional assumptions, even if they avoid a measure 0 subset.",
    "created_at": "2022-09-15T07:04:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672189",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:193'></a>
Replying to [Xavier Caruso](#comment%3A192):
> Replying to [Matthias Köppe](#comment%3A190):
> > No, the same wisdoms would say that you would maybe have a specialized subclass for 0 (for optimization purposes), but not one for >= 1.

> 
> It looks like there is a misunderstanding here.
> 
> Certainly, the class `Foo` (or `Adult` say) should only be used to handle 0 `Element` classes but also certainly `Bar` (or `Parent`) has to inherit for `Foo`.
> IMO, the class `Adult` should implement the coercion mecanism whereas the methods `_element_constructor` and `__call__` should be reserved to `Parent`.


I agree with Xavier here. Other examples: We could have `Polytope` (i.e., a bounded polyhedron) as a subclass of `Polyhedron` as it is a specialized version where we could optimize things and have additional special methods (such as the Ehrhart polynomial). Or like the `CommutativeRing` subclass of `Ring`. Subclasses are for things that have additional assumptions, even if they avoid a measure 0 subset.



---

archive/issue_comments_672190.json:
```json
{
    "body": "<a id='comment:194'></a>\nReplying to [Travis Scrimshaw](#comment%3A193):\n> Subclasses are for things that have additional assumptions\n\n\nExactly, but I have already explained that \"admitting >= 1 element class\" is not such a situation that warrants a subclass (in particular not one that would add methods).\n\n-[comment:140](#comment%3A140) - Facade parents don't have an element class, but they do have an `_element_constructor_`.\n\n-[comment:142](#comment%3A142) - Whether something is (a) \"empty as a set\" or (b) \"in principle doesn't have elements\" is a distinction that is not important enough to model in our code. (This distinction has no standing as a mathematical concept -[comment:191](#comment%3A191).) \n\n-[comment:146](#comment%3A146),[comment:147](#comment%3A147),[comment:152](#comment%3A152) - Likewise, the distinction between (a) a parent that does not have element class / constructor and (b) a parent that has them but the element constructor always raises a `ValueError`, is not important enough to expose to the outside.\n\n- To add to this, in many cases it is not statically known whether a parent needs an element class (or which element class it needs if it does); it may depend on the input data. We have many classes that make such a dynamic choice of element class. In the running example with (say, affine real) schemes, say you get as input `x^(2d) + 1` vs. `x^(2d) - 1`. For the first one because it is empty as a set, you don't need an element class. For the second one, you want to use a specialized element class for affine varieties over a real closed field.\n\nI'll be happy to expand on all of this if necessary.",
    "created_at": "2022-09-15T20:26:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672190",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:194'></a>
Replying to [Travis Scrimshaw](#comment%3A193):
> Subclasses are for things that have additional assumptions


Exactly, but I have already explained that "admitting >= 1 element class" is not such a situation that warrants a subclass (in particular not one that would add methods).

-[comment:140](#comment%3A140) - Facade parents don't have an element class, but they do have an `_element_constructor_`.

-[comment:142](#comment%3A142) - Whether something is (a) "empty as a set" or (b) "in principle doesn't have elements" is a distinction that is not important enough to model in our code. (This distinction has no standing as a mathematical concept -[comment:191](#comment%3A191).) 

-[comment:146](#comment%3A146),[comment:147](#comment%3A147),[comment:152](#comment%3A152) - Likewise, the distinction between (a) a parent that does not have element class / constructor and (b) a parent that has them but the element constructor always raises a `ValueError`, is not important enough to expose to the outside.

- To add to this, in many cases it is not statically known whether a parent needs an element class (or which element class it needs if it does); it may depend on the input data. We have many classes that make such a dynamic choice of element class. In the running example with (say, affine real) schemes, say you get as input `x^(2d) + 1` vs. `x^(2d) - 1`. For the first one because it is empty as a set, you don't need an element class. For the second one, you want to use a specialized element class for affine varieties over a real closed field.

I'll be happy to expand on all of this if necessary.



---

archive/issue_comments_672191.json:
```json
{
    "body": "<a id='comment:5'></a>\nI have opened #34548 for further discussion of `Parent`s with 0, 1, 2, ... element classes",
    "created_at": "2022-09-17T00:08:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672191",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:5'></a>
I have opened #34548 for further discussion of `Parent`s with 0, 1, 2, ... element classes



---

archive/issue_comments_672192.json:
```json
{
    "body": "<a id='comment:6'></a>\nAnd I have opened #34540 to improve documentation of `CategoryObject`.",
    "created_at": "2022-09-17T00:09:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672192",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:6'></a>
And I have opened #34540 to improve documentation of `CategoryObject`.



---

archive/issue_comments_672193.json:
```json
{
    "body": "<a id='comment:197'></a>\nReplying to [Xavier Caruso](#comment%3A154):\n> But if you say that it's already okay to have parents without elements, I just propose to get rid of this class `CategoryObject` (which is apparently almost not used).\n\n\nYes, I think this could make sense.",
    "created_at": "2022-09-17T00:15:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672193",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:197'></a>
Replying to [Xavier Caruso](#comment%3A154):
> But if you say that it's already okay to have parents without elements, I just propose to get rid of this class `CategoryObject` (which is apparently almost not used).


Yes, I think this could make sense.



---

archive/issue_comments_672194.json:
```json
{
    "body": "<a id='comment:198'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A113):\n> I've explained in[comment:108](#comment%3A108) - `CategoryObject` is just a low-level implementation class, and despite its mathematical-sounding name, it does not model the notion of an \"object in a category\".\n>  \n> If you look for its uses in the Sage library, you'll see that there are exactly 2 direct uses of it (`IntegrableRepresentation`, `TopologicalVectorBundle`)... and both are mistakes.\n\n\nFor fixing `IntegrableRepresentation`, see #21387.",
    "created_at": "2022-09-17T00:17:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672194",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:198'></a>
Replying to [Matthias Köppe](#comment%3A113):
> I've explained in[comment:108](#comment%3A108) - `CategoryObject` is just a low-level implementation class, and despite its mathematical-sounding name, it does not model the notion of an "object in a category".
>  
> If you look for its uses in the Sage library, you'll see that there are exactly 2 direct uses of it (`IntegrableRepresentation`, `TopologicalVectorBundle`)... and both are mistakes.


For fixing `IntegrableRepresentation`, see #21387.



---

archive/issue_comments_672195.json:
```json
{
    "body": "<a id='comment:9'></a>\nI'm afraid that the discussion on `Parent`/`CategoryObject`/whatever will be still quite long and, actually, I do not want to hold this ticket too much.\n\nApart from Travis (who is clearly opposed), it seems to me that the current solution (Drinfeld modules are parents without elements) fits with the other participants (Antoine, David, Pierre-Jean, Matthias and myself); correct me if I'm wrong. So, for now, I would propose to accept this and continue the review. We will come back to this later on (in another ticket) once there will be a clear consensus on the structural design choices.\n\nDo you agree?",
    "created_at": "2022-09-17T08:13:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672195",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:9'></a>
I'm afraid that the discussion on `Parent`/`CategoryObject`/whatever will be still quite long and, actually, I do not want to hold this ticket too much.

Apart from Travis (who is clearly opposed), it seems to me that the current solution (Drinfeld modules are parents without elements) fits with the other participants (Antoine, David, Pierre-Jean, Matthias and myself); correct me if I'm wrong. So, for now, I would propose to accept this and continue the review. We will come back to this later on (in another ticket) once there will be a clear consensus on the structural design choices.

Do you agree?



---

archive/issue_comments_672196.json:
```json
{
    "body": "<a id='comment:200'></a>\nReplying to [Xavier Caruso](#comment%3A199):\n> I'm afraid that the discussion on `Parent`/`CategoryObject`/whatever will be still quite long and, actually, I do not want to hold this ticket too much.\n> \n> Apart from Travis (who is clearly opposed), it seems to me that the current solution (Drinfeld modules are parents without elements) fits with the other participants (Antoine, David, Pierre-Jean, Matthias and myself); correct me if I'm wrong. So, for now, I would propose to accept this and continue the review. We will come back to this later on (in another ticket) once there will be a clear consensus on the structural design choices.\n> \n> Do you agree?\n\n\nNo, you don\u2019t just get to sideline me like that. That is not how we do things here. If there is an impasse, we go to a sage-devel vote. Because of your suggestion, I am very hesitant to offer a compromise that I think is way more than fair to you.\n\nI am willing to accept this as-is with the current code structure (there are still other issues I mentioned in[comment:124](#comment%3A124)) as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`, and `DrinfeldModules` is assuming that its objects are the specific `DrinfeldModule` implementation. You should mention specifically that this was done as a special exception so that morphisms could work between your objects. Furthermore, you will have to open tickets stating that these things will be changed (`DrinfeldModules` becomes a `Parent` with  once the infrastructure is in place, with links in your documentation to these tickets.\n\nNow again, another way out of this is we could also just simply inherit `DrinfeldModuleMorphism` from `Element` instead of `Morphism` (or `Map`) and duplicate the necessary structure. This is something I am more than willing to do myself.\n\nI think there are some other issues with the morphisms that could bite you because you are not implementing a custom composition (since you say that the morphisms are very important). You get a generic composition morphism, which won\u2019t carry the properties of a `DrinfeldModuleMorphism`. I don\u2019t quite see what properties of inheriting from `Map`/`Morphism` that you will use beyond just having some of the fundamental methods we could easily ducktype.",
    "created_at": "2022-09-17T09:43:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672196",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:200'></a>
Replying to [Xavier Caruso](#comment%3A199):
> I'm afraid that the discussion on `Parent`/`CategoryObject`/whatever will be still quite long and, actually, I do not want to hold this ticket too much.
> 
> Apart from Travis (who is clearly opposed), it seems to me that the current solution (Drinfeld modules are parents without elements) fits with the other participants (Antoine, David, Pierre-Jean, Matthias and myself); correct me if I'm wrong. So, for now, I would propose to accept this and continue the review. We will come back to this later on (in another ticket) once there will be a clear consensus on the structural design choices.
> 
> Do you agree?


No, you don’t just get to sideline me like that. That is not how we do things here. If there is an impasse, we go to a sage-devel vote. Because of your suggestion, I am very hesitant to offer a compromise that I think is way more than fair to you.

I am willing to accept this as-is with the current code structure (there are still other issues I mentioned in[comment:124](#comment%3A124)) as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`, and `DrinfeldModules` is assuming that its objects are the specific `DrinfeldModule` implementation. You should mention specifically that this was done as a special exception so that morphisms could work between your objects. Furthermore, you will have to open tickets stating that these things will be changed (`DrinfeldModules` becomes a `Parent` with  once the infrastructure is in place, with links in your documentation to these tickets.

Now again, another way out of this is we could also just simply inherit `DrinfeldModuleMorphism` from `Element` instead of `Morphism` (or `Map`) and duplicate the necessary structure. This is something I am more than willing to do myself.

I think there are some other issues with the morphisms that could bite you because you are not implementing a custom composition (since you say that the morphisms are very important). You get a generic composition morphism, which won’t carry the properties of a `DrinfeldModuleMorphism`. I don’t quite see what properties of inheriting from `Map`/`Morphism` that you will use beyond just having some of the fundamental methods we could easily ducktype.



---

archive/issue_comments_672197.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2022-09-17T09:43:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672197",
    "user": "https://github.com/tscrim"
}
```


**Changing status** from needs_review to needs_work.



---

archive/issue_comments_672198.json:
```json
{
    "body": "<a id='comment:1'></a>\nI can also do a draft proposal if you are open to the idea of having a parallel map class as a bridge until we get the larger change sorted out. In particular, you don't even have to agree to it before I am willing to put in the effort to write the code.",
    "created_at": "2022-09-17T09:57:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672198",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:1'></a>
I can also do a draft proposal if you are open to the idea of having a parallel map class as a bridge until we get the larger change sorted out. In particular, you don't even have to agree to it before I am willing to put in the effort to write the code.



---

archive/issue_comments_672199.json:
```json
{
    "body": "<a id='comment:202'></a>\nReplying to [Travis Scrimshaw](#comment%3A200):\n> Now again, another way out of this is we could also just simply inherit `DrinfeldModuleMorphism` from `Element` instead of `Morphism` (or `Map`) and duplicate the necessary structure.\n\n\nStrong -1 on introducing direct uses of `CategoryObject` and workarounds like  morphisms that do not derive from `Morphism`.",
    "created_at": "2022-09-17T11:52:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672199",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:202'></a>
Replying to [Travis Scrimshaw](#comment%3A200):
> Now again, another way out of this is we could also just simply inherit `DrinfeldModuleMorphism` from `Element` instead of `Morphism` (or `Map`) and duplicate the necessary structure.


Strong -1 on introducing direct uses of `CategoryObject` and workarounds like  morphisms that do not derive from `Morphism`.



---

archive/issue_comments_672200.json:
```json
{
    "body": "<a id='comment:203'></a>\nReplying to [Travis Scrimshaw](#comment%3A200):\n> as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`\n\n\nThe class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.",
    "created_at": "2022-09-17T12:07:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672200",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:203'></a>
Replying to [Travis Scrimshaw](#comment%3A200):
> as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`


The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.



---

archive/issue_comments_672201.json:
```json
{
    "body": "<a id='comment:4'></a>\nI'd like to thank you three for this extensive discussion which resulted in what I think is a solution for our problem. In particular, I learned that the  `Parent`/`Element` implementation is much more than the didactical description explained in the Sage's manuals. \n\nAs much that I'm **very** eager to see Drinfeld modules in Sage, I think it would be best to wait until the generalization of `Parent` is at least implemented and have it as a dependency for this ticket. I would be willing to help for this solution, however I'm afraid that I would not know what to do. Anyhow, If you have any task for me that could help speed up the process, don't hesitate! I will be following the discussion on the other tickets too.",
    "created_at": "2022-09-17T14:26:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672201",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:4'></a>
I'd like to thank you three for this extensive discussion which resulted in what I think is a solution for our problem. In particular, I learned that the  `Parent`/`Element` implementation is much more than the didactical description explained in the Sage's manuals. 

As much that I'm **very** eager to see Drinfeld modules in Sage, I think it would be best to wait until the generalization of `Parent` is at least implemented and have it as a dependency for this ticket. I would be willing to help for this solution, however I'm afraid that I would not know what to do. Anyhow, If you have any task for me that could help speed up the process, don't hesitate! I will be following the discussion on the other tickets too.



---

archive/issue_comments_672202.json:
```json
{
    "body": "<a id='comment:205'></a>\nReplying to [David Ayotte](#comment%3A204):\n> I think it would be best to wait until the generalization of `Parent` is at least implemented and have it as a dependency for this ticket. I would be willing to help for this solution, however I'm afraid that I would not know what to do.\n\n\nFor `DrinfeldModule` to be a `Parent` without an element class, no work is needed; it already works.\n\nFor `DrinfeldModules` to (instead of a `Category`) become a `Parent` whose element class is both an `Element` and a `Parent`, we would need #34534. That ticket could use exploratory programming to see what the precise technical obstacles are.",
    "created_at": "2022-09-17T15:50:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672202",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:205'></a>
Replying to [David Ayotte](#comment%3A204):
> I think it would be best to wait until the generalization of `Parent` is at least implemented and have it as a dependency for this ticket. I would be willing to help for this solution, however I'm afraid that I would not know what to do.


For `DrinfeldModule` to be a `Parent` without an element class, no work is needed; it already works.

For `DrinfeldModules` to (instead of a `Category`) become a `Parent` whose element class is both an `Element` and a `Parent`, we would need #34534. That ticket could use exploratory programming to see what the precise technical obstacles are.



---

archive/issue_comments_672203.json:
```json
{
    "body": "<a id='comment:206'></a>\nReplying to [Xavier Caruso](#comment%3A46):\n> In [SageMath](SageMath), elliptic curves are parents:\n> \n> ```\n> sage: E = EllipticCurve(u'389a')\n> sage: E\n> Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field\n> sage: isinstance(E, Parent)\n> True\n> ```\n> \n> However, `E` does not have elements:\n\n\nI've opened #34550 for this",
    "created_at": "2022-09-17T17:11:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672203",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:206'></a>
Replying to [Xavier Caruso](#comment%3A46):
> In [SageMath](SageMath), elliptic curves are parents:
> 
> ```
> sage: E = EllipticCurve(u'389a')
> sage: E
> Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
> sage: isinstance(E, Parent)
> True
> ```
> 
> However, `E` does not have elements:


I've opened #34550 for this



---

archive/issue_comments_672204.json:
```json
{
    "body": "<a id='comment:207'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A203):\n> Replying to [Travis Scrimshaw](#comment%3A200):\n> > as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`\n\n> \n> The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.\n\n\nSo are you saying \u201cjust ignore the methods in that class that we don\u2019t intend to use because they are broken?\u201d So can I use, say, `Polyhedron` to be a base class of `AlternatingSignMatrix` without implementing its `@abstract_method`s? (Actually, I would even have some mathematical justification for this because it is a single integral point in an even bigger polytope.)\n\nWhile it is not explicitly documented that `Element` is a required attribute on any subclass, it is quite implicit by the points I\u2019ve made on #34534.\n\nActually, does pickling work with your implementation? Does `TestSuite` pass? From looking closely at the `Parent` code, I expect this to run into problems.\n\nFurthermore, because Drinfeld modules are morphisms, there is further tension with the `Parent.__call__`, where they cannot behave like morphisms because that directly contradicts its documentation and implementation. (This is something we need to figure out with morphisms (which are an `Element` subclass) that are also a proper `Parent` with its own `Element` class.)\n\nSome additional technical review things: This does not have 100% coverage. This includes all (double) underscore methods.",
    "created_at": "2022-09-17T23:53:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672204",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:207'></a>
Replying to [Matthias Köppe](#comment%3A203):
> Replying to [Travis Scrimshaw](#comment%3A200):
> > as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`

> 
> The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.


So are you saying “just ignore the methods in that class that we don’t intend to use because they are broken?” So can I use, say, `Polyhedron` to be a base class of `AlternatingSignMatrix` without implementing its `@abstract_method`s? (Actually, I would even have some mathematical justification for this because it is a single integral point in an even bigger polytope.)

While it is not explicitly documented that `Element` is a required attribute on any subclass, it is quite implicit by the points I’ve made on #34534.

Actually, does pickling work with your implementation? Does `TestSuite` pass? From looking closely at the `Parent` code, I expect this to run into problems.

Furthermore, because Drinfeld modules are morphisms, there is further tension with the `Parent.__call__`, where they cannot behave like morphisms because that directly contradicts its documentation and implementation. (This is something we need to figure out with morphisms (which are an `Element` subclass) that are also a proper `Parent` with its own `Element` class.)

Some additional technical review things: This does not have 100% coverage. This includes all (double) underscore methods.



---

archive/issue_comments_672205.json:
```json
{
    "body": "<a id='comment:208'></a>\nReplying to [Travis Scrimshaw](#comment%3A207):\n> Replying to [Matthias K\u00f6ppe](#comment%3A203):\n> > Replying to [Travis Scrimshaw](#comment%3A200):\n> > > as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`\n\n> > \n> > The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.\n\n> \n> So are you saying \u201cjust ignore the methods in that class that we don\u2019t intend to use because they are broken?\u201d \n\n\nNo, I'm not saying that. Read it again. You claimed that `Element` and `_element_constructor_` are required. They are not, and I've explained it in detail.\n\n> So can I use, say, `Polyhedron` to be a base class of `AlternatingSignMatrix` without implementing its `@abstract_method`s?\n\n\nNo, Travis, I'm not saying that. Invalid argumentative tactics \"akin\" to those you used earlier. Please use more restraint.\n\n> While it is not explicitly documented that `Element` is a required attribute on any subclass, it is quite implicit by the points I\u2019ve made on #34534.\n\n\nI'm quite intrigued with the phrasing \"quite implicit\". But setting this aside: It's definitely not clear that `Element` is a required. And just in the message that you replied to I explained that `Parent` implements both codepaths. So no, it's just your personal interpretation, and you already know that I disagree.\n\n> Furthermore, because Drinfeld modules are morphisms, there is further tension with the `Parent.__call__`, where they cannot behave like morphisms because that directly contradicts its documentation and implementation. (This is something we need to figure out with morphisms (which are an `Element` subclass) that are also a proper `Parent` with its own `Element` class.)\n\n\nTo my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.\n\n> Some additional technical review things: This does not have 100% coverage. This includes all (double) underscore methods.\n\n\nYes, clearly a lot of documentation/tests are missing.",
    "created_at": "2022-09-18T00:46:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672205",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:208'></a>
Replying to [Travis Scrimshaw](#comment%3A207):
> Replying to [Matthias Köppe](#comment%3A203):
> > Replying to [Travis Scrimshaw](#comment%3A200):
> > > as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`

> > 
> > The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.

> 
> So are you saying “just ignore the methods in that class that we don’t intend to use because they are broken?” 


No, I'm not saying that. Read it again. You claimed that `Element` and `_element_constructor_` are required. They are not, and I've explained it in detail.

> So can I use, say, `Polyhedron` to be a base class of `AlternatingSignMatrix` without implementing its `@abstract_method`s?


No, Travis, I'm not saying that. Invalid argumentative tactics "akin" to those you used earlier. Please use more restraint.

> While it is not explicitly documented that `Element` is a required attribute on any subclass, it is quite implicit by the points I’ve made on #34534.


I'm quite intrigued with the phrasing "quite implicit". But setting this aside: It's definitely not clear that `Element` is a required. And just in the message that you replied to I explained that `Parent` implements both codepaths. So no, it's just your personal interpretation, and you already know that I disagree.

> Furthermore, because Drinfeld modules are morphisms, there is further tension with the `Parent.__call__`, where they cannot behave like morphisms because that directly contradicts its documentation and implementation. (This is something we need to figure out with morphisms (which are an `Element` subclass) that are also a proper `Parent` with its own `Element` class.)


To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.

> Some additional technical review things: This does not have 100% coverage. This includes all (double) underscore methods.


Yes, clearly a lot of documentation/tests are missing.



---

archive/issue_comments_672206.json:
```json
{
    "body": "<a id='comment:209'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A208):\n> Replying to [Travis Scrimshaw](#comment%3A207):\n> > Replying to [Matthias K\u00f6ppe](#comment%3A203):\n> > > Replying to [Travis Scrimshaw](#comment%3A200):\n> > > > as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`\n\n> > > \n> > > The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.\n\n> > \n> > So are you saying \u201cjust ignore the methods in that class that we don\u2019t intend to use because they are broken?\u201d \n\n> \n> No, I'm not saying that. Read it again. You claimed that `Element` and `_element_constructor_` are required. They are not, and I've explained it in detail.\n\n\nThen what makes them required? Does it need to fail upon instance creation? I do not see where you have made clear what makes something required. All I recall and can quickly see is that you have said in detail is what it should be used for (which I think we agree that we should refactor out parts dealing with `Element`). I am sorry if it has gotten lost in our discussion.\n\n> > So can I use, say, `Polyhedron` to be a base class of `AlternatingSignMatrix` without implementing its `@abstract_method`s?\n\n> \n> No, Travis, I'm not saying that. Invalid argumentative tactics \"akin\" to those you used earlier. Please use more restraint.\n\n\nThis is a legitimate question: Can we subclass something and have some of its methods fail (including with `NotImplementedError`s) because something in the implementation (not the input of the instance) is not provided? That is what happens here with `an_element()` (and possibly pickling, which I haven't checked).\n\nNot for nothing, I expect `_test_category` to fail because the category is not a subcategory of `Sets`.\n\n> > While it is not explicitly documented that `Element` is a required attribute on any subclass, it is quite implicit by the points I\u2019ve made on #34534.\n\n> \n> I'm quite intrigued with the phrasing \"quite implicit\". But setting this aside: It's definitely not clear that `Element` is a required. And just in the message that you replied to I explained that `Parent` implements both codepaths. So no, it's just your personal interpretation, and you already know that I disagree.\n\n\nI don't see any code path that explicitly deals with `Element`. Actually, I think you're right about `Element` not being required, thinking about fa\u00e7ade parents. However, it does explicitly use `_element_constructor_` and the error types clearly indicate that it is expected to be provided (they just do not appear an instance creation). Note that when it is not an empty set, then IIRC there is a test saying that for Python classes, the elements must be a subclass of the `Parent.category().ElementMethods` (which is created dynamically from the `Parent.Element` attribute and making it required). Coupled with the `_test_category`, which has no indication that it should be moved up to the category, `_element_constructor_` needs to be provided. (Frankly, I don't see it as too much of a difference.)\n\n> > Furthermore, because Drinfeld modules are morphisms, there is further tension with the `Parent.__call__`, where they cannot behave like morphisms because that directly contradicts its documentation and implementation. (This is something we need to figure out with morphisms (which are an `Element` subclass) that are also a proper `Parent` with its own `Element` class.)\n\n> \n> To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.\n\n\nThis is the problem: These are not in `Sets()` but `Parent` requires an `_element_constructor_` and to be an object of `Sets()`. There might be a way to hack around this, but they are still hacks.",
    "created_at": "2022-09-18T01:35:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672206",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:209'></a>
Replying to [Matthias Köppe](#comment%3A208):
> Replying to [Travis Scrimshaw](#comment%3A207):
> > Replying to [Matthias Köppe](#comment%3A203):
> > > Replying to [Travis Scrimshaw](#comment%3A200):
> > > > as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`

> > > 
> > > The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.

> > 
> > So are you saying “just ignore the methods in that class that we don’t intend to use because they are broken?” 

> 
> No, I'm not saying that. Read it again. You claimed that `Element` and `_element_constructor_` are required. They are not, and I've explained it in detail.


Then what makes them required? Does it need to fail upon instance creation? I do not see where you have made clear what makes something required. All I recall and can quickly see is that you have said in detail is what it should be used for (which I think we agree that we should refactor out parts dealing with `Element`). I am sorry if it has gotten lost in our discussion.

> > So can I use, say, `Polyhedron` to be a base class of `AlternatingSignMatrix` without implementing its `@abstract_method`s?

> 
> No, Travis, I'm not saying that. Invalid argumentative tactics "akin" to those you used earlier. Please use more restraint.


This is a legitimate question: Can we subclass something and have some of its methods fail (including with `NotImplementedError`s) because something in the implementation (not the input of the instance) is not provided? That is what happens here with `an_element()` (and possibly pickling, which I haven't checked).

Not for nothing, I expect `_test_category` to fail because the category is not a subcategory of `Sets`.

> > While it is not explicitly documented that `Element` is a required attribute on any subclass, it is quite implicit by the points I’ve made on #34534.

> 
> I'm quite intrigued with the phrasing "quite implicit". But setting this aside: It's definitely not clear that `Element` is a required. And just in the message that you replied to I explained that `Parent` implements both codepaths. So no, it's just your personal interpretation, and you already know that I disagree.


I don't see any code path that explicitly deals with `Element`. Actually, I think you're right about `Element` not being required, thinking about façade parents. However, it does explicitly use `_element_constructor_` and the error types clearly indicate that it is expected to be provided (they just do not appear an instance creation). Note that when it is not an empty set, then IIRC there is a test saying that for Python classes, the elements must be a subclass of the `Parent.category().ElementMethods` (which is created dynamically from the `Parent.Element` attribute and making it required). Coupled with the `_test_category`, which has no indication that it should be moved up to the category, `_element_constructor_` needs to be provided. (Frankly, I don't see it as too much of a difference.)

> > Furthermore, because Drinfeld modules are morphisms, there is further tension with the `Parent.__call__`, where they cannot behave like morphisms because that directly contradicts its documentation and implementation. (This is something we need to figure out with morphisms (which are an `Element` subclass) that are also a proper `Parent` with its own `Element` class.)

> 
> To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.


This is the problem: These are not in `Sets()` but `Parent` requires an `_element_constructor_` and to be an object of `Sets()`. There might be a way to hack around this, but they are still hacks.



---

archive/issue_comments_672207.json:
```json
{
    "body": "<a id='comment:210'></a>\nReplying to [Travis Scrimshaw](#comment%3A209):\n> > To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.\n\n> \n> This is the problem: These are not in `Sets()` but `Parent` requires an `_element_constructor_`\n\n\nNo it doesn't.\n\n> and to be an object of `Sets()`. \n\n\nNo it doesn't.\n\n(Is this the argument clinic or just contradiction?)",
    "created_at": "2022-09-18T02:52:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672207",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:210'></a>
Replying to [Travis Scrimshaw](#comment%3A209):
> > To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.

> 
> This is the problem: These are not in `Sets()` but `Parent` requires an `_element_constructor_`


No it doesn't.

> and to be an object of `Sets()`. 


No it doesn't.

(Is this the argument clinic or just contradiction?)



---

archive/issue_comments_672208.json:
```json
{
    "body": "<a id='comment:211'></a>\nReplying to [Travis Scrimshaw](#comment%3A209):\n> I expect `_test_category` to fail because the category is not a subcategory of `Sets`.\n\n\nNice find. I'd propose to modify this one.",
    "created_at": "2022-09-18T03:00:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672208",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:211'></a>
Replying to [Travis Scrimshaw](#comment%3A209):
> I expect `_test_category` to fail because the category is not a subcategory of `Sets`.


Nice find. I'd propose to modify this one.



---

archive/issue_comments_672209.json:
```json
{
    "body": "<a id='comment:212'></a>\nReplying to [Travis Scrimshaw](#comment%3A209):\n> I don't see any code path that explicitly deals with `Element`.\n\n\nIt's here:\n\n```\n    # This probably should go into Sets().Parent\n    @lazy_attribute\n    def element_class(self):\n        try:  # if hasattr(self, 'Element'):\n            return self.__make_element_class__(self.Element,\n                                               name=\"%s.element_class\" % self.__class__.__name__,\n                                               module=self.__class__.__module__)\n        except AttributeError:  # else:\n            return NotImplemented\n```\n\nSo this implements one of these hooks that I mentioned. `element_class` only shows up as an attribute when `Element` is provided by the subclass or category.",
    "created_at": "2022-09-18T03:04:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672209",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:212'></a>
Replying to [Travis Scrimshaw](#comment%3A209):
> I don't see any code path that explicitly deals with `Element`.


It's here:

```
    # This probably should go into Sets().Parent
    @lazy_attribute
    def element_class(self):
        try:  # if hasattr(self, 'Element'):
            return self.__make_element_class__(self.Element,
                                               name="%s.element_class" % self.__class__.__name__,
                                               module=self.__class__.__module__)
        except AttributeError:  # else:
            return NotImplemented
```

So this implements one of these hooks that I mentioned. `element_class` only shows up as an attribute when `Element` is provided by the subclass or category.



---

archive/issue_comments_672210.json:
```json
{
    "body": "<a id='comment:213'></a>\nReplying to [Travis Scrimshaw](#comment%3A209):\n> it does explicitly use `_element_constructor_` and the error types clearly indicate that it is expected to be provided\n\n\nNo, it doesn't. It uses `_element_constructor` (no trailing underscore), which is a cdef and can be `None` (it's set to a callable in `_set_element_constructor`).",
    "created_at": "2022-09-18T03:13:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672210",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:213'></a>
Replying to [Travis Scrimshaw](#comment%3A209):
> it does explicitly use `_element_constructor_` and the error types clearly indicate that it is expected to be provided


No, it doesn't. It uses `_element_constructor` (no trailing underscore), which is a cdef and can be `None` (it's set to a callable in `_set_element_constructor`).



---

archive/issue_comments_672211.json:
```json
{
    "body": "<a id='comment:4'></a>\nFor pickling\n\n```\nsage: Fq.<z2> = GF(3^2)\n....: FqX.<X> = Fq[]\n....: K.<z> = Fq.extension(6)\n....: phi = DrinfeldModule(FqX, [z, 1, 1])\n....: phi\nDrinfeld module defined by X |--> t^2 + t + z over base Ring morphism:\n  From: Univariate Polynomial Ring in X over Finite Field in z2 of size 3^2\n  To:   Finite Field in z of size 3^12\n  Defn: X |--> z\nsage: loads(dumps(phi)) is phi  # this is not really testing pickling because of UniqueRepresentation\nTrue\n```\nNow when I explicitly try to load the pickle\n\n```\nsage: dumps(phi)\nb'x\\x9c\\x85\\x96\\x87\\x7f\\x14E\\x14\\xc7C(!\\x0b\\x02\\x8a\\x15\\x1b\\xf6\\xc3\\x12)\\x8ab\\x8f$\\x11\\x8c\\x1c\\xf8\\x10=K\\\\7{s7\\x93l\\xb9\\xdf\\x96@\\xd0S,\\x9bM\\xec\\x15\\xc1\\x82\\x15{\\xef\\xbd\\xf7\\x8a\\xbd\\xf7\\xfe_8\\xdb\\xcc%!\\x1f?\\xf9|.3\\xdf\\xf7\\xe6\\xcd\\xcc\\x9bWvM\\xbd\\xeeje\\xd6\\xe4z\\x8e\\xaf{\\xbe\\xc3\\x9a|K\\xc0g\\xaa\\xc3*\\x0es\\x99\\xe5i\\x9e\\xb0-\\xc5\\xb7\\x1cV\\xf4u\\xa6\\xa0.Y\\xe0\\x08\\xab\\xec6\\x95|K\\x8f\\xe4jI0\\xa3\\xd8T\\x94\\xb4$\\x07\\xaai\\x17}\\x83I\\xb9\\xb0\\x84\\xc7\\xd4a\\\\i\\x8bqKJ\\x97$\\x10cj-Wl\\xa3\\xd7\\xb2M\\xa1\\x19M\\xb6\\xc3\\xd4\\xc1\\xa9\\x1a\\xc9\\x95\\xa5\\x0e[\\xf6\\x1f\\xa2\\x88\\xa0>7\\xfc*%M\\xf7l\\xa7W)3\\x8b9BW\\xd3\\xb9\\xea[\\x15\\xa1wG[\\x8e\\x1du\\x8da\\xdb\\xdd~E-\\x1bv\\xa7f(\\x18W\\x98TWW\\x97\\x9c\\xbb-\\xba+\\xc6\\x07\\x98@hholo(\\x8c\\x952G\\x9f\\x83\\x89!\\x1as\\xb5\\xb7\\x10\\x96\\xc7\\xca\\xccQL\\xad\\x9b\\xa9\\xd9\\x04Ja\\x9c\\\\P\\x9e\\xdf\\xc31)\\xc0d\\xc2\\x16\\x851\\x12\\xac\\xc6\\x94\\x00SGqB\\x8d\\x03VK/\\xaa%C\\x9aK\\xec2\\x83\\x99\\xf2\\xa1\\x14L\\xfb\\xff\\xb5\\x91L\\xd5m+\\xb9\\xb0\\xed(\\x99/\\xd4\\xe1\\xee\\xdc2\\xc7\\xc7\\xe6x\\x03o\\xccq%>\\xde<l\\x15`:a\\xebx\\xb6\\n\\xdb\\x04\\xd86\\x1f\\xdfD\\x9e\\xc7\\xc2v\\\\\\xe1Ra{\\xc2\\x0e\\xe9\\x829\\x98\\x11`G\\xc2N\\xfd\\xf9|\\xbe\\x7f\\xc0\\xc3\\xceU\\xec\\xe2aW\\xc2L.\\x17\\xef\\x96\\x97hw\\xc2\\x1e\\x1d\\xd8s\\x88\\xd3\\xd2\\xa0\\x19\\xe2\\xc1(r\\x14\\x19(\\n\\xf6J\\xad\\xcf\\xc5\\xde\\x01\\xf6!\\xe4\\x92}g\\x11\\xf6\\xe53C\\xecG\\xd8\\x9fg:\\xb3q@\\x80&\\xc2\\x81<\\x96\\xcd&\\xcc\\x89d\\\\\\x9ek.a^B\\x0f\"\\x1c\\x1cS\\xa9;\\x9fpHB\\x0f%,\\xc8t\\x0f#\\x1c\\x9e\\xd0#\\x08Gf\\xf4(\\xc2\\xd1\\t=\\x86\\xd0\\x9c\\xd1c\\t\\x0b\\x13\\xdaBh\\xcd\\xec\\xb6\\x11\\x8eK\\xe8\"\\xc2\\xe2\\x8c\\x1eOhO\\xe8\\t\\x84%\\x19\\xcd\\x13\\x96&t\\x19\\xe1\\xc4\\x8c\\x12ayBO\"\\xac\\xc8\\xe8\\xc9\\x84S\\x12Z \\x9c\\x9a\\x9d\\xe14\\xc2\\xe9\\t=\\x83\\xd0\\xc1\\x06\\x06B\\x9c\\xd9\\x07\\x95pVA\\x91^\\xa9h\\x8ePK2\\xf3<h\\x89\\xf3:\\tz\\xea2\\x1d\\xc5\\x00\\x8cP\\x8a\\x1f\\xad\\xdfC\\xb9\\n\\xeeA\\x10\\xba\\x927\\xd25\\xf9 \\xb6#dv\\x9bZe0~\\xa2\\t\\xbaG\\x7fHn\\x9bj\\n\\xe2b\\xa1\\xb49v\\'\\xb3\\x84\\xef\\xb6ZE\\xdb\\xb4\\x9d\\n\\x17\\xee0\\x15\\x18#\\xf6\\x94f\\\\\\xe6)\\x8blS\\x81\\x99\\xe3]<=\\x96)\\\\]\\xea\\x19\\x86\\x12\\xfd\\xa8&\\xf3x\\x14-\\x16\\x1f\\xf9W\\xb7\\x99\\x8b\\x94M\\xcdU5\\xab\\xa8j\\xc5\\xa2\\xf0DOt\\x9f\\x88)K\\xe2\\x7f\\xcdV\\xb19\\x15$@\\x81=\\xab\\x8aJ\\x08\\x10\\x9c\\xb86\\xa8+\\x85\\xc7Um\\x95\\xb0M\\xb8\\x85\\xc9\\x92\\xb4\\x08\\x99e\\xa2\\xd3\\x8fV\\xc1\\x0b\\xe1\\x13z\\xb8[\\x98.E\\x99\\xb1f\\xd7\\xb5u\\xa1\\xc5\\x1a+C\\xac\"\\xf4\\x0e\\xd3Xh\\x9b\\xa6\\xef%\\x1a\\xabC\\x9cM8GjL\\xa9\\xd1X!\\x1d\\xa6\\x19\\xa8\\x868\\x97p\\x9e\\x14F\\xa7\\xa95\\xbc&\\xc4\\xf9\\x84\\x0b\\xa4dj\\xcd\\xb2\\xc5V\\x0fs\\\\\\x86\\x0bC\\\\D\\x08\\xa4t\\x82\\x94\\xa6\\xc6\\xfaB\\x84\\x84~\\t\\'\\xc6\\x17\\xe9\\x11\\xae\\xac\\xf2\\x90\\x81t1\\xe1\\x92t\\x8f\\xda\\xa3]\\x1a\\xe22\\xc2\\xe5\\xa9\\x95\\xa4N\\xe2\\x8a\\x10W\\x12\\xae\\x92i~5\\xe1\\x9a*\\xae\\xad\\xe2\\xba\\\\\\xa1!r\\x96|qMXX\\xcb\\xbb\\n\\x8d\\xd1\\\\\\xb7Sr\\xbd$\\x91\\xf3T\\xe1J\\xc8\\x1c=\\xdaw\\xdd@|\\xe3\\xb8)\\xa9^o\\x85\\xa9\\xd2\\xb3X\\x9f/\\x8c\\x8f\\xa8!J\\x1en\\xc8\\xc7;\\xcbF\\xb1\\x929\\xb8\\xb1\\xbd\\xde\\xf7p\\x13\\xe1\\xe68\\xa8=l\\x08p\\x8b<\\xc7\\xad\\x84\\xdb:p\\xfb\\xe8Q\\x9a\\xd6Ru0G\\x06#\\xbc\\xa6\\xfa\\xb7\\x8eT\\xc3\\x1d2\\x18\\xa7\\xf4\\xe1N\\xc2F\\x1e\\x8dg\\xf4\\xe1.\\xc2\\xdd\\xd9\\xf8\\x1e\\xc2\\xbd,\\xc0}\\x84\\xfb7\\x13\\x81\\xc3;\\xa72\\xb49\\xcax{\\x80\\x0fM\\xae,c\\x94\\xa8\\\\\\xcbt\\x18L!a\\xaa\\xb2\\xe3\\xc9%\\x0fr\\x99!#\\xea\\xf8\\x02<\\x14\\xe0a\\xc2#\\x85\\xfa\\xa8\\xe9\\xcc\\xc5\\xa3\\x01\\x1e\\xe3\\xd3\\xb8\\xac\\xc3\\x8f\\xe7\\xe2\\x12\"\\x0b\\xeb\\x13\\x84\\'\\x93\\x12\\xf2\\x14\\xe1\\xe9\\x8c>Cx6\\xa1\\xcf\\x11\\x9e\\xcf\\xca\\xcd\\x0b\\x84\\x17\\x13\\xfa\\x12\\xe1\\xe5\\xb8\\xdc\\xbc\\xd2\\x87W\\t\\xaf\\xc5OR\\x16=\\x9ac\\xe3\\xf5\\xa4\\xd4\\xbcAx31\\xf6\\x16\\xe1\\xed\\xfe\\xa4\\x81D\\r\\n\\xef\\xf4G\\xe5\\xe6\\xdd*\\xde\\xf3\\xf0>\\xe1\\x83\\xf8\\xb0\\x05|\\x18\\xe0\\xa3\\xa8S|L\\xd8$=9\\xd2u\\xcc\\xd7\\rQd\\x9a\\x95\\x06\\x95\\xab\\xb4f\\xa4%\\x05\\xf8D&\\xeb\\xa7!>#|.M}A\\xf8\\xb2\\x8a\\xaf\\xaa\\xf8:\\xc7\\xd7\\xf2M\\\\\\xc6\\x1c_7\\xc0\\xd7\\xe7\\xb9\\x8c\\xa28\\x1c3\\x1f\\xe2\\x9b\\xe1\\xdf\\x072c|f\\xc9\\x0f\\xa1\\xe5\\xe9@M\\xbf.\\x14|\\x9b\\xeb\\xc0w|\\xa3\\xc6\\xbb\\x06\\xa2n\\xf7=\\xe1\\x87\\xc4Z\\xa7\\xe6\\xc6\\xf5\\x11?\\xe6eT\\xfeD\\xf89\\xc0/U\\xfc\\x1a\\xdf\\xdd\\xd2L\\x86\\xdf\\xf8\\x067\\xc4\\xef\\x84?\\xfa\\xf0g\\x15\\x7f\\x85\\xf8\\x9b\\xf0O\\xd3\\xbf\\xc6\\x7f\\x89\\xd8'\n```\nin a new Sage session:\n\n```\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/sage-build/src/sage/misc/cachefunc.pyx:985, in sage.misc.cachefunc.CachedFunction.__call__()\n    984 try:\n--> 985     return self.cache[k]\n    986 except TypeError:  # k is not hashable\n\nFile ~/sage-build/src/sage/misc/weak_dict.pyx:704, in sage.misc.weak_dict.WeakValueDictionary.__getitem__()\n    703 if wr == NULL:\n--> 704     raise KeyError(k)\n    705 out = PyWeakref_GetObject(wr)\n\nKeyError: ((<class 'sage.categories.drinfeld_modules.DrinfeldModules'>, Ring morphism:\n  From: Univariate Polynomial Ring in X over Finite Field in z2 of size 3^2\n  To:   Finite Field in z of size 3^12\n  Defn: X |--> z), (('name', 't'),))\n\nDuring handling of the above exception, another exception occurred:\n\nTypeError                                 Traceback (most recent call last)\nInput In [2], in <cell line: 1>()\n----> 1 loads(b'x\\x9c\\x85\\x96\\x87\\x7f\\x14E\\x14\\xc7C(!\\x0b\\x02\\x8a\\x15\\x1b\\xf6\\xc3\\x12)\\x8ab\\x8f$\\x11\\x8c\\x1c\\xf8\\x10=K\\\\7{s7\\x93l\\xb9\\xdf\\x96@\\xd0S,\\x9bM\\xec\\x15\\xc1\\x82\\x15{\\xef\\xbd\\xf7\\x8a\\xbd\\xf7\\xfe_8\\xdb\\xcc%!\\x1f?\\xf9|.3\\xdf\\xf7\\xe6\\xcd\\xcc\\x9bWvM\\xbd\\xeeje\\xd6\\xe4z\\x8e\\xaf{\\xbe\\xc3\\x9a|K\\xc0g\\xaa\\xc3*\\x0es\\x99\\xe5i\\x9e\\xb0-\\xc5\\xb7\\x1cV\\xf4u\\xa6\\xa0.Y\\xe0\\x08\\xab\\xec6\\x95|K\\x8f\\xe4jI0\\xa3\\xd8T\\x94\\xb4$\\x07\\xaai\\x17}\\x83I\\xb9\\xb0\\x84\\xc7\\xd4a\\\\i\\x8bqKJ\\x97$\\x10cj-Wl\\xa3\\xd7\\xb2M\\xa1\\x19M\\xb6\\xc3\\xd4\\xc1\\xa9\\x1a\\xc9\\x95\\xa5\\x0e[\\xf6\\x1f\\xa2\\x88\\xa0>7\\xfc*%M\\xf7l\\xa7W)3\\x8b9BW\\xd3\\xb9\\xea[\\x15\\xa1wG[\\x8e\\x1du\\x8da\\xdb\\xdd~E-\\x1bv\\xa7f(\\x18W\\x98TWW\\x97\\x9c\\xbb-\\xba+\\xc6\\x07\\x98@hholo(\\x8c\\x952G\\x9f\\x83\\x89!\\x1as\\xb5\\xb7\\x10\\x96\\xc7\\xca\\xccQL\\xad\\x9b\\xa9\\xd9\\x04Ja\\x9c\\\\P\\x9e\\xdf\\xc31)\\xc0d\\xc2\\x16\\x851\\x12\\xac\\xc6\\x94\\x00SGqB\\x8d\\x03VK/\\xaa%C\\x9aK\\xec2\\x83\\x99\\xf2\\xa1\\x14L\\xfb\\xff\\xb5\\x91L\\xd5m+\\xb9\\xb0\\xed(\\x99/\\xd4\\xe1\\xee\\xdc2\\xc7\\xc7\\xe6x\\x03o\\xccq%>\\xde<l\\x15`:a\\xebx\\xb6\\n\\xdb\\x04\\xd86\\x1f\\xdfD\\x9e\\xc7\\xc2v\\\\\\xe1Ra{\\xc2\\x0e\\xe9\\x829\\x98\\x11`G\\xc2N\\xfd\\xf9|\\xbe\\x7f\\xc0\\xc3\\xceU\\xec\\xe2aW\\xc2L.\\x17\\xef\\x96\\x97hw\\xc2\\x1e\\x1d\\xd8s\\x88\\xd3\\xd2\\xa0\\x19\\xe2\\xc1(r\\x14\\x19(\\n\\xf6J\\xad\\xcf\\xc5\\xde\\x01\\xf6!\\xe4\\x92}g\\x11\\xf6\\xe53C\\xecG\\xd8\\x9fg:\\xb3q@\\x80&\\xc2\\x81<\\x96\\xcd&\\xcc\\x89d\\\\\\x9ek.a^B\\x0f\"\\x1c\\x1cS\\xa9;\\x9fpHB\\x0f%,\\xc8t\\x0f#\\x1c\\x9e\\xd0#\\x08Gf\\xf4(\\xc2\\xd1\\t=\\x86\\xd0\\x9c\\xd1c\\t\\x0b\\x13\\xdaBh\\xcd\\xec\\xb6\\x11\\x8eK\\xe8\"\\xc2\\xe2\\x8c\\x1eOhO\\xe8\\t\\x84%\\x19\\xcd\\x13\\x96&t\\x19\\xe1\\xc4\\x8c\\x12ayBO\"\\xac\\xc8\\xe8\\xc9\\x84S\\x12Z \\x9c\\x9a\\x9d\\xe14\\xc2\\xe9\\t=\\x83\\xd0\\xc1\\x06\\x06B\\x9c\\xd9\\x07\\x95pVA\\x91^\\xa9h\\x8ePK2\\xf3<h\\x89\\xf3:\\tz\\xea2\\x1d\\xc5\\x00\\x8cP\\x8a\\x1f\\xad\\xdfC\\xb9\\n\\xeeA\\x10\\xba\\x927\\xd25\\xf9 \\xb6#dv\\x9bZe0~\\xa2\\t\\xbaG\\x7fHn\\x9bj\\n\\xe2b\\xa1\\xb49v\\'\\xb3\\x84\\xef\\xb6ZE\\xdb\\xb4\\x9d\\n\\x17\\xee0\\x15\\x18#\\xf6\\x94f\\\\\\xe6)\\x8blS\\x81\\x99\\xe3]<=\\x96)\\\\]\\xea\\x19\\x86\\x12\\xfd\\xa8&\\xf3x\\x14-\\x16\\x1f\\xf9W\\xb7\\x99\\x8b\\x94M\\xcdU5\\xab\\xa8j\\xc5\\xa2\\xf0DOt\\x9f\\x88)K\\xe2\\x7f\\xcdV\\xb19\\x15$@\\x81=\\xab\\x8aJ\\x08\\x10\\x9c\\xb86\\xa8+\\x85\\xc7Um\\x95\\xb0M\\xb8\\x85\\xc9\\x92\\xb4\\x08\\x99e\\xa2\\xd3\\x8fV\\xc1\\x0b\\xe1\\x13z\\xb8[\\x98.E\\x99\\xb1f\\xd7\\xb5u\\xa1\\xc5\\x1a+C\\xac\"\\xf4\\x0e\\xd3Xh\\x9b\\xa6\\xef%\\x1a\\xabC\\x9cM8GjL\\xa9\\xd1X!\\x1d\\xa6\\x19\\xa8\\x868\\x97p\\x9e\\x14F\\xa7\\xa95\\xbc&\\xc4\\xf9\\x84\\x0b\\xa4dj\\xcd\\xb2\\xc5V\\x0fs\\\\\\x86\\x0bC\\\\D\\x08\\xa4t\\x82\\x94\\xa6\\xc6\\xfaB\\x84\\x84~\\t\\'\\xc6\\x17\\xe9\\x11\\xae\\xac\\xf2\\x90\\x81t1\\xe1\\x92t\\x8f\\xda\\xa3]\\x1a\\xe22\\xc2\\xe5\\xa9\\x95\\xa4N\\xe2\\x8a\\x10W\\x12\\xae\\x92i~5\\xe1\\x9a*\\xae\\xad\\xe2\\xba\\\\\\xa1!r\\x96|qMXX\\xcb\\xbb\\n\\x8d\\xd1\\\\\\xb7Sr\\xbd$\\x91\\xf3T\\xe1J\\xc8\\x1c=\\xdaw\\xdd@|\\xe3\\xb8)\\xa9^o\\x85\\xa9\\xd2\\xb3X\\x9f/\\x8c\\x8f\\xa8!J\\x1en\\xc8\\xc7;\\xcbF\\xb1\\x929\\xb8\\xb1\\xbd\\xde\\xf7p\\x13\\xe1\\xe68\\xa8=l\\x08p\\x8b<\\xc7\\xad\\x84\\xdb:p\\xfb\\xe8Q\\x9a\\xd6Ru0G\\x06#\\xbc\\xa6\\xfa\\xb7\\x8eT\\xc3\\x1d2\\x18\\xa7\\xf4\\xe1N\\xc2F\\x1e\\x8dg\\xf4\\xe1.\\xc2\\xdd\\xd9\\xf8\\x1e\\xc2\\xbd,\\xc0}\\x84\\xfb7\\x13\\x81\\xc3;\\xa72\\xb49\\xcax{\\x80\\x0fM\\xae,c\\x94\\xa8\\\\\\xcbt\\x18L!a\\xaa\\xb2\\xe3\\xc9%\\x0fr\\x99!#\\xea\\xf8\\x02<\\x14\\xe0a\\xc2#\\x85\\xfa\\xa8\\xe9\\xcc\\xc5\\xa3\\x01\\x1e\\xe3\\xd3\\xb8\\xac\\xc3\\x8f\\xe7\\xe2\\x12\"\\x0b\\xeb\\x13\\x84\\'\\x93\\x12\\xf2\\x14\\xe1\\xe9\\x8c>Cx6\\xa1\\xcf\\x11\\x9e\\xcf\\xca\\xcd\\x0b\\x84\\x17\\x13\\xfa\\x12\\xe1\\xe5\\xb8\\xdc\\xbc\\xd2\\x87W\\t\\xaf\\xc5OR\\x16=\\x9ac\\xe3\\xf5\\xa4\\xd4\\xbcAx31\\xf6\\x16\\xe1\\xed\\xfe\\xa4\\x81D\\r\\n\\xef\\xf4G\\xe5\\xe6\\xdd*\\xde\\xf3\\xf0>\\xe1\\x83\\xf8\\xb0\\x05|\\x18\\xe0\\xa3\\xa8S|L\\xd8$=9\\xd2u\\xcc\\xd7\\rQd\\x9a\\x95\\x06\\x95\\xab\\xb4f\\xa4%\\x05\\xf8D&\\xeb\\xa7!>#|.M}A\\xf8\\xb2\\x8a\\xaf\\xaa\\xf8:\\xc7\\xd7\\xf2M\\\\\\xc6\\x1c_7\\xc0\\xd7\\xe7\\xb9\\x8c\\xa28\\x1c3\\x1f\\xe2\\x9b\\xe1\\xdf\\x072c|f\\xc9\\x0f\\xa1\\xe5\\xe9@M\\xbf.\\x14|\\x9b\\xeb\\xc0w|\\xa3\\xc6\\xbb\\x06\\xa2n\\xf7=\\xe1\\x87\\xc4Z\\xa7\\xe6\\xc6\\xf5\\x11?\\xe6eT\\xfeD\\xf89\\xc0/U\\xfc\\x1a\\xdf\\xdd\\xd2L\\x86\\xdf\\xf8\\x067\\xc4\\xef\\x84?\\xfa\\xf0g\\x15\\x7f\\x85\\xf8\\x9b\\xf0O\\xd3\\xbf\\xc6\\x7f\\x89\\xd8')\n\nFile ~/sage-build/src/sage/misc/persist.pyx:991, in sage.misc.persist.loads()\n    989 unpickler = SageUnpickler(io.BytesIO(s), **kwargs)\n    990 global already_unpickled\n--> 991 ans = unpickler.load()\n    992 already_unpickled = { }\n    993 return ans\n\nFile ~/sage-build/src/sage/structure/unique_representation.py:1161, in unreduce(cls, args, keywords)\n   1149 def unreduce(cls, args, keywords):\n   1150     \"\"\"\n   1151     Calls a class on the given arguments::\n   1152 \n   (...)\n   1159 \n   1160     \"\"\"\n-> 1161     return cls(*args, **keywords)\n\nFile ~/sage-build/src/sage/misc/classcall_metaclass.pyx:320, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__()\n    318 \"\"\"\n    319 if cls.classcall is not None:\n--> 320     return cls.classcall(cls, *args, **kwds)\n    321 else:\n    322     # Fast version of type.__call__(cls, *args, **kwds)\n\nFile ~/sage-build/src/sage/categories/category.py:447, in Category.__classcall__(cls, *args, **options)\n    445 if isinstance(cls, DynamicMetaclass):\n    446     cls = cls.__base__\n--> 447 return super().__classcall__(cls, *args, **options)\n\nFile ~/sage-build/src/sage/misc/cachefunc.pyx:990, in sage.misc.cachefunc.CachedFunction.__call__()\n    988         return self.cache[k]\n    989 except KeyError:\n--> 990     w = self.f(*args, **kwds)\n    991     self.cache[k] = w\n    992     return w\n\nFile ~/sage-build/src/sage/structure/unique_representation.py:1007, in CachedRepresentation.__classcall__(cls, *args, **options)\n    992 @weak_cached_function(cache=128)  # automatically a staticmethod\n    993 def __classcall__(cls, *args, **options):\n    994     \"\"\"\n    995     Construct a new object of this class or reuse an existing one.\n    996 \n   (...)\n   1005         True\n   1006     \"\"\"\n-> 1007     instance = typecall(cls, *args, **options)\n   1008     assert isinstance( instance, cls )\n   1009     if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:\n\nFile ~/sage-build/src/sage/misc/classcall_metaclass.pyx:471, in sage.misc.classcall_metaclass.typecall()\n    469     2\n    470 \"\"\"\n--> 471 return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n    472 \n    473 \n\nFile ~/sage-build/src/sage/categories/drinfeld_modules.py:220, in DrinfeldModules.__init__(self, base, name)\n    218     raise TypeError('base codomain must be a field')\n    219 # Check base is a non zero morphism\n--> 220 if base(X).is_zero():\n    221     raise ValueError('base must be a non zero morphism')\n    222 # Build K{t}\n\nFile ~/sage-build/src/sage/categories/map.pyx:769, in sage.categories.map.Map.__call__()\n    767 if P is D: # we certainly want to call _call_/with_args\n    768     if not args and not kwds:\n--> 769         return self._call_(x)\n    770     return self._call_with_args(x, args, kwds)\n    771 # Is there coercion?\n\nFile ~/sage-build/src/sage/rings/morphism.pyx:2054, in sage.rings.morphism.RingHomomorphism_im_gens._call_()\n   2052     2*x + 3*y + 2*z\n   2053 \"\"\"\n-> 2054 return x._im_gens_(self.codomain(), self.im_gens(), base_map=self.base_map())\n   2055 \n   2056 \n\nFile ~/sage-build/src/sage/rings/polynomial/polynomial_element.pyx:1305, in sage.rings.polynomial.polynomial_element.Polynomial._im_gens_()\n   1303 if base_map is None:\n   1304     base_map = codomain.coerce_map_from(self.base_ring())\n-> 1305 result = base_map(self.get_unsafe(d))\n   1306 i = d - 1\n   1307 while i >= 0:\n\nTypeError: 'NoneType' object is not callable\n```\nI am not even sure what is failing here actually.",
    "created_at": "2022-09-18T03:16:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672211",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:4'></a>
For pickling

```
sage: Fq.<z2> = GF(3^2)
....: FqX.<X> = Fq[]
....: K.<z> = Fq.extension(6)
....: phi = DrinfeldModule(FqX, [z, 1, 1])
....: phi
Drinfeld module defined by X |--> t^2 + t + z over base Ring morphism:
  From: Univariate Polynomial Ring in X over Finite Field in z2 of size 3^2
  To:   Finite Field in z of size 3^12
  Defn: X |--> z
sage: loads(dumps(phi)) is phi  # this is not really testing pickling because of UniqueRepresentation
True
```
Now when I explicitly try to load the pickle

```
sage: dumps(phi)
b'x\x9c\x85\x96\x87\x7f\x14E\x14\xc7C(!\x0b\x02\x8a\x15\x1b\xf6\xc3\x12)\x8ab\x8f$\x11\x8c\x1c\xf8\x10=K\\7{s7\x93l\xb9\xdf\x96@\xd0S,\x9bM\xec\x15\xc1\x82\x15{\xef\xbd\xf7\x8a\xbd\xf7\xfe_8\xdb\xcc%!\x1f?\xf9|.3\xdf\xf7\xe6\xcd\xcc\x9bWvM\xbd\xeeje\xd6\xe4z\x8e\xaf{\xbe\xc3\x9a|K\xc0g\xaa\xc3*\x0es\x99\xe5i\x9e\xb0-\xc5\xb7\x1cV\xf4u\xa6\xa0.Y\xe0\x08\xab\xec6\x95|K\x8f\xe4jI0\xa3\xd8T\x94\xb4$\x07\xaai\x17}\x83I\xb9\xb0\x84\xc7\xd4a\\i\x8bqKJ\x97$\x10cj-Wl\xa3\xd7\xb2M\xa1\x19M\xb6\xc3\xd4\xc1\xa9\x1a\xc9\x95\xa5\x0e[\xf6\x1f\xa2\x88\xa0>7\xfc*%M\xf7l\xa7W)3\x8b9BW\xd3\xb9\xea[\x15\xa1wG[\x8e\x1du\x8da\xdb\xdd~E-\x1bv\xa7f(\x18W\x98TWW\x97\x9c\xbb-\xba+\xc6\x07\x98@hholo(\x8c\x952G\x9f\x83\x89!\x1as\xb5\xb7\x10\x96\xc7\xca\xccQL\xad\x9b\xa9\xd9\x04Ja\x9c\\P\x9e\xdf\xc31)\xc0d\xc2\x16\x851\x12\xac\xc6\x94\x00SGqB\x8d\x03VK/\xaa%C\x9aK\xec2\x83\x99\xf2\xa1\x14L\xfb\xff\xb5\x91L\xd5m+\xb9\xb0\xed(\x99/\xd4\xe1\xee\xdc2\xc7\xc7\xe6x\x03o\xccq%>\xde<l\x15`:a\xebx\xb6\n\xdb\x04\xd86\x1f\xdfD\x9e\xc7\xc2v\\\xe1Ra{\xc2\x0e\xe9\x829\x98\x11`G\xc2N\xfd\xf9|\xbe\x7f\xc0\xc3\xceU\xec\xe2aW\xc2L.\x17\xef\x96\x97hw\xc2\x1e\x1d\xd8s\x88\xd3\xd2\xa0\x19\xe2\xc1(r\x14\x19(\n\xf6J\xad\xcf\xc5\xde\x01\xf6!\xe4\x92}g\x11\xf6\xe53C\xecG\xd8\x9fg:\xb3q@\x80&\xc2\x81<\x96\xcd&\xcc\x89d\\\x9ek.a^B\x0f"\x1c\x1cS\xa9;\x9fpHB\x0f%,\xc8t\x0f#\x1c\x9e\xd0#\x08Gf\xf4(\xc2\xd1\t=\x86\xd0\x9c\xd1c\t\x0b\x13\xdaBh\xcd\xec\xb6\x11\x8eK\xe8"\xc2\xe2\x8c\x1eOhO\xe8\t\x84%\x19\xcd\x13\x96&t\x19\xe1\xc4\x8c\x12ayBO"\xac\xc8\xe8\xc9\x84S\x12Z \x9c\x9a\x9d\xe14\xc2\xe9\t=\x83\xd0\xc1\x06\x06B\x9c\xd9\x07\x95pVA\x91^\xa9h\x8ePK2\xf3<h\x89\xf3:\tz\xea2\x1d\xc5\x00\x8cP\x8a\x1f\xad\xdfC\xb9\n\xeeA\x10\xba\x927\xd25\xf9 \xb6#dv\x9bZe0~\xa2\t\xbaG\x7fHn\x9bj\n\xe2b\xa1\xb49v\'\xb3\x84\xef\xb6ZE\xdb\xb4\x9d\n\x17\xee0\x15\x18#\xf6\x94f\\\xe6)\x8blS\x81\x99\xe3]<=\x96)\\]\xea\x19\x86\x12\xfd\xa8&\xf3x\x14-\x16\x1f\xf9W\xb7\x99\x8b\x94M\xcdU5\xab\xa8j\xc5\xa2\xf0DOt\x9f\x88)K\xe2\x7f\xcdV\xb19\x15$@\x81=\xab\x8aJ\x08\x10\x9c\xb86\xa8+\x85\xc7Um\x95\xb0M\xb8\x85\xc9\x92\xb4\x08\x99e\xa2\xd3\x8fV\xc1\x0b\xe1\x13z\xb8[\x98.E\x99\xb1f\xd7\xb5u\xa1\xc5\x1a+C\xac"\xf4\x0e\xd3Xh\x9b\xa6\xef%\x1a\xabC\x9cM8GjL\xa9\xd1X!\x1d\xa6\x19\xa8\x868\x97p\x9e\x14F\xa7\xa95\xbc&\xc4\xf9\x84\x0b\xa4dj\xcd\xb2\xc5V\x0fs\\\x86\x0bC\\D\x08\xa4t\x82\x94\xa6\xc6\xfaB\x84\x84~\t\'\xc6\x17\xe9\x11\xae\xac\xf2\x90\x81t1\xe1\x92t\x8f\xda\xa3]\x1a\xe22\xc2\xe5\xa9\x95\xa4N\xe2\x8a\x10W\x12\xae\x92i~5\xe1\x9a*\xae\xad\xe2\xba\\\xa1!r\x96|qMXX\xcb\xbb\n\x8d\xd1\\\xb7Sr\xbd$\x91\xf3T\xe1J\xc8\x1c=\xdaw\xdd@|\xe3\xb8)\xa9^o\x85\xa9\xd2\xb3X\x9f/\x8c\x8f\xa8!J\x1en\xc8\xc7;\xcbF\xb1\x929\xb8\xb1\xbd\xde\xf7p\x13\xe1\xe68\xa8=l\x08p\x8b<\xc7\xad\x84\xdb:p\xfb\xe8Q\x9a\xd6Ru0G\x06#\xbc\xa6\xfa\xb7\x8eT\xc3\x1d2\x18\xa7\xf4\xe1N\xc2F\x1e\x8dg\xf4\xe1.\xc2\xdd\xd9\xf8\x1e\xc2\xbd,\xc0}\x84\xfb7\x13\x81\xc3;\xa72\xb49\xcax{\x80\x0fM\xae,c\x94\xa8\\\xcbt\x18L!a\xaa\xb2\xe3\xc9%\x0fr\x99!#\xea\xf8\x02<\x14\xe0a\xc2#\x85\xfa\xa8\xe9\xcc\xc5\xa3\x01\x1e\xe3\xd3\xb8\xac\xc3\x8f\xe7\xe2\x12"\x0b\xeb\x13\x84\'\x93\x12\xf2\x14\xe1\xe9\x8c>Cx6\xa1\xcf\x11\x9e\xcf\xca\xcd\x0b\x84\x17\x13\xfa\x12\xe1\xe5\xb8\xdc\xbc\xd2\x87W\t\xaf\xc5OR\x16=\x9ac\xe3\xf5\xa4\xd4\xbcAx31\xf6\x16\xe1\xed\xfe\xa4\x81D\r\n\xef\xf4G\xe5\xe6\xdd*\xde\xf3\xf0>\xe1\x83\xf8\xb0\x05|\x18\xe0\xa3\xa8S|L\xd8$=9\xd2u\xcc\xd7\rQd\x9a\x95\x06\x95\xab\xb4f\xa4%\x05\xf8D&\xeb\xa7!>#|.M}A\xf8\xb2\x8a\xaf\xaa\xf8:\xc7\xd7\xf2M\\\xc6\x1c_7\xc0\xd7\xe7\xb9\x8c\xa28\x1c3\x1f\xe2\x9b\xe1\xdf\x072c|f\xc9\x0f\xa1\xe5\xe9@M\xbf.\x14|\x9b\xeb\xc0w|\xa3\xc6\xbb\x06\xa2n\xf7=\xe1\x87\xc4Z\xa7\xe6\xc6\xf5\x11?\xe6eT\xfeD\xf89\xc0/U\xfc\x1a\xdf\xdd\xd2L\x86\xdf\xf8\x067\xc4\xef\x84?\xfa\xf0g\x15\x7f\x85\xf8\x9b\xf0O\xd3\xbf\xc6\x7f\x89\xd8'
```
in a new Sage session:

```
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
File ~/sage-build/src/sage/misc/cachefunc.pyx:985, in sage.misc.cachefunc.CachedFunction.__call__()
    984 try:
--> 985     return self.cache[k]
    986 except TypeError:  # k is not hashable

File ~/sage-build/src/sage/misc/weak_dict.pyx:704, in sage.misc.weak_dict.WeakValueDictionary.__getitem__()
    703 if wr == NULL:
--> 704     raise KeyError(k)
    705 out = PyWeakref_GetObject(wr)

KeyError: ((<class 'sage.categories.drinfeld_modules.DrinfeldModules'>, Ring morphism:
  From: Univariate Polynomial Ring in X over Finite Field in z2 of size 3^2
  To:   Finite Field in z of size 3^12
  Defn: X |--> z), (('name', 't'),))

During handling of the above exception, another exception occurred:

TypeError                                 Traceback (most recent call last)
Input In [2], in <cell line: 1>()
----> 1 loads(b'x\x9c\x85\x96\x87\x7f\x14E\x14\xc7C(!\x0b\x02\x8a\x15\x1b\xf6\xc3\x12)\x8ab\x8f$\x11\x8c\x1c\xf8\x10=K\\7{s7\x93l\xb9\xdf\x96@\xd0S,\x9bM\xec\x15\xc1\x82\x15{\xef\xbd\xf7\x8a\xbd\xf7\xfe_8\xdb\xcc%!\x1f?\xf9|.3\xdf\xf7\xe6\xcd\xcc\x9bWvM\xbd\xeeje\xd6\xe4z\x8e\xaf{\xbe\xc3\x9a|K\xc0g\xaa\xc3*\x0es\x99\xe5i\x9e\xb0-\xc5\xb7\x1cV\xf4u\xa6\xa0.Y\xe0\x08\xab\xec6\x95|K\x8f\xe4jI0\xa3\xd8T\x94\xb4$\x07\xaai\x17}\x83I\xb9\xb0\x84\xc7\xd4a\\i\x8bqKJ\x97$\x10cj-Wl\xa3\xd7\xb2M\xa1\x19M\xb6\xc3\xd4\xc1\xa9\x1a\xc9\x95\xa5\x0e[\xf6\x1f\xa2\x88\xa0>7\xfc*%M\xf7l\xa7W)3\x8b9BW\xd3\xb9\xea[\x15\xa1wG[\x8e\x1du\x8da\xdb\xdd~E-\x1bv\xa7f(\x18W\x98TWW\x97\x9c\xbb-\xba+\xc6\x07\x98@hholo(\x8c\x952G\x9f\x83\x89!\x1as\xb5\xb7\x10\x96\xc7\xca\xccQL\xad\x9b\xa9\xd9\x04Ja\x9c\\P\x9e\xdf\xc31)\xc0d\xc2\x16\x851\x12\xac\xc6\x94\x00SGqB\x8d\x03VK/\xaa%C\x9aK\xec2\x83\x99\xf2\xa1\x14L\xfb\xff\xb5\x91L\xd5m+\xb9\xb0\xed(\x99/\xd4\xe1\xee\xdc2\xc7\xc7\xe6x\x03o\xccq%>\xde<l\x15`:a\xebx\xb6\n\xdb\x04\xd86\x1f\xdfD\x9e\xc7\xc2v\\\xe1Ra{\xc2\x0e\xe9\x829\x98\x11`G\xc2N\xfd\xf9|\xbe\x7f\xc0\xc3\xceU\xec\xe2aW\xc2L.\x17\xef\x96\x97hw\xc2\x1e\x1d\xd8s\x88\xd3\xd2\xa0\x19\xe2\xc1(r\x14\x19(\n\xf6J\xad\xcf\xc5\xde\x01\xf6!\xe4\x92}g\x11\xf6\xe53C\xecG\xd8\x9fg:\xb3q@\x80&\xc2\x81<\x96\xcd&\xcc\x89d\\\x9ek.a^B\x0f"\x1c\x1cS\xa9;\x9fpHB\x0f%,\xc8t\x0f#\x1c\x9e\xd0#\x08Gf\xf4(\xc2\xd1\t=\x86\xd0\x9c\xd1c\t\x0b\x13\xdaBh\xcd\xec\xb6\x11\x8eK\xe8"\xc2\xe2\x8c\x1eOhO\xe8\t\x84%\x19\xcd\x13\x96&t\x19\xe1\xc4\x8c\x12ayBO"\xac\xc8\xe8\xc9\x84S\x12Z \x9c\x9a\x9d\xe14\xc2\xe9\t=\x83\xd0\xc1\x06\x06B\x9c\xd9\x07\x95pVA\x91^\xa9h\x8ePK2\xf3<h\x89\xf3:\tz\xea2\x1d\xc5\x00\x8cP\x8a\x1f\xad\xdfC\xb9\n\xeeA\x10\xba\x927\xd25\xf9 \xb6#dv\x9bZe0~\xa2\t\xbaG\x7fHn\x9bj\n\xe2b\xa1\xb49v\'\xb3\x84\xef\xb6ZE\xdb\xb4\x9d\n\x17\xee0\x15\x18#\xf6\x94f\\\xe6)\x8blS\x81\x99\xe3]<=\x96)\\]\xea\x19\x86\x12\xfd\xa8&\xf3x\x14-\x16\x1f\xf9W\xb7\x99\x8b\x94M\xcdU5\xab\xa8j\xc5\xa2\xf0DOt\x9f\x88)K\xe2\x7f\xcdV\xb19\x15$@\x81=\xab\x8aJ\x08\x10\x9c\xb86\xa8+\x85\xc7Um\x95\xb0M\xb8\x85\xc9\x92\xb4\x08\x99e\xa2\xd3\x8fV\xc1\x0b\xe1\x13z\xb8[\x98.E\x99\xb1f\xd7\xb5u\xa1\xc5\x1a+C\xac"\xf4\x0e\xd3Xh\x9b\xa6\xef%\x1a\xabC\x9cM8GjL\xa9\xd1X!\x1d\xa6\x19\xa8\x868\x97p\x9e\x14F\xa7\xa95\xbc&\xc4\xf9\x84\x0b\xa4dj\xcd\xb2\xc5V\x0fs\\\x86\x0bC\\D\x08\xa4t\x82\x94\xa6\xc6\xfaB\x84\x84~\t\'\xc6\x17\xe9\x11\xae\xac\xf2\x90\x81t1\xe1\x92t\x8f\xda\xa3]\x1a\xe22\xc2\xe5\xa9\x95\xa4N\xe2\x8a\x10W\x12\xae\x92i~5\xe1\x9a*\xae\xad\xe2\xba\\\xa1!r\x96|qMXX\xcb\xbb\n\x8d\xd1\\\xb7Sr\xbd$\x91\xf3T\xe1J\xc8\x1c=\xdaw\xdd@|\xe3\xb8)\xa9^o\x85\xa9\xd2\xb3X\x9f/\x8c\x8f\xa8!J\x1en\xc8\xc7;\xcbF\xb1\x929\xb8\xb1\xbd\xde\xf7p\x13\xe1\xe68\xa8=l\x08p\x8b<\xc7\xad\x84\xdb:p\xfb\xe8Q\x9a\xd6Ru0G\x06#\xbc\xa6\xfa\xb7\x8eT\xc3\x1d2\x18\xa7\xf4\xe1N\xc2F\x1e\x8dg\xf4\xe1.\xc2\xdd\xd9\xf8\x1e\xc2\xbd,\xc0}\x84\xfb7\x13\x81\xc3;\xa72\xb49\xcax{\x80\x0fM\xae,c\x94\xa8\\\xcbt\x18L!a\xaa\xb2\xe3\xc9%\x0fr\x99!#\xea\xf8\x02<\x14\xe0a\xc2#\x85\xfa\xa8\xe9\xcc\xc5\xa3\x01\x1e\xe3\xd3\xb8\xac\xc3\x8f\xe7\xe2\x12"\x0b\xeb\x13\x84\'\x93\x12\xf2\x14\xe1\xe9\x8c>Cx6\xa1\xcf\x11\x9e\xcf\xca\xcd\x0b\x84\x17\x13\xfa\x12\xe1\xe5\xb8\xdc\xbc\xd2\x87W\t\xaf\xc5OR\x16=\x9ac\xe3\xf5\xa4\xd4\xbcAx31\xf6\x16\xe1\xed\xfe\xa4\x81D\r\n\xef\xf4G\xe5\xe6\xdd*\xde\xf3\xf0>\xe1\x83\xf8\xb0\x05|\x18\xe0\xa3\xa8S|L\xd8$=9\xd2u\xcc\xd7\rQd\x9a\x95\x06\x95\xab\xb4f\xa4%\x05\xf8D&\xeb\xa7!>#|.M}A\xf8\xb2\x8a\xaf\xaa\xf8:\xc7\xd7\xf2M\\\xc6\x1c_7\xc0\xd7\xe7\xb9\x8c\xa28\x1c3\x1f\xe2\x9b\xe1\xdf\x072c|f\xc9\x0f\xa1\xe5\xe9@M\xbf.\x14|\x9b\xeb\xc0w|\xa3\xc6\xbb\x06\xa2n\xf7=\xe1\x87\xc4Z\xa7\xe6\xc6\xf5\x11?\xe6eT\xfeD\xf89\xc0/U\xfc\x1a\xdf\xdd\xd2L\x86\xdf\xf8\x067\xc4\xef\x84?\xfa\xf0g\x15\x7f\x85\xf8\x9b\xf0O\xd3\xbf\xc6\x7f\x89\xd8')

File ~/sage-build/src/sage/misc/persist.pyx:991, in sage.misc.persist.loads()
    989 unpickler = SageUnpickler(io.BytesIO(s), **kwargs)
    990 global already_unpickled
--> 991 ans = unpickler.load()
    992 already_unpickled = { }
    993 return ans

File ~/sage-build/src/sage/structure/unique_representation.py:1161, in unreduce(cls, args, keywords)
   1149 def unreduce(cls, args, keywords):
   1150     """
   1151     Calls a class on the given arguments::
   1152 
   (...)
   1159 
   1160     """
-> 1161     return cls(*args, **keywords)

File ~/sage-build/src/sage/misc/classcall_metaclass.pyx:320, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__()
    318 """
    319 if cls.classcall is not None:
--> 320     return cls.classcall(cls, *args, **kwds)
    321 else:
    322     # Fast version of type.__call__(cls, *args, **kwds)

File ~/sage-build/src/sage/categories/category.py:447, in Category.__classcall__(cls, *args, **options)
    445 if isinstance(cls, DynamicMetaclass):
    446     cls = cls.__base__
--> 447 return super().__classcall__(cls, *args, **options)

File ~/sage-build/src/sage/misc/cachefunc.pyx:990, in sage.misc.cachefunc.CachedFunction.__call__()
    988         return self.cache[k]
    989 except KeyError:
--> 990     w = self.f(*args, **kwds)
    991     self.cache[k] = w
    992     return w

File ~/sage-build/src/sage/structure/unique_representation.py:1007, in CachedRepresentation.__classcall__(cls, *args, **options)
    992 @weak_cached_function(cache=128)  # automatically a staticmethod
    993 def __classcall__(cls, *args, **options):
    994     """
    995     Construct a new object of this class or reuse an existing one.
    996 
   (...)
   1005         True
   1006     """
-> 1007     instance = typecall(cls, *args, **options)
   1008     assert isinstance( instance, cls )
   1009     if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:

File ~/sage-build/src/sage/misc/classcall_metaclass.pyx:471, in sage.misc.classcall_metaclass.typecall()
    469     2
    470 """
--> 471 return (<PyTypeObject*>type).tp_call(cls, args, kwds)
    472 
    473 

File ~/sage-build/src/sage/categories/drinfeld_modules.py:220, in DrinfeldModules.__init__(self, base, name)
    218     raise TypeError('base codomain must be a field')
    219 # Check base is a non zero morphism
--> 220 if base(X).is_zero():
    221     raise ValueError('base must be a non zero morphism')
    222 # Build K{t}

File ~/sage-build/src/sage/categories/map.pyx:769, in sage.categories.map.Map.__call__()
    767 if P is D: # we certainly want to call _call_/with_args
    768     if not args and not kwds:
--> 769         return self._call_(x)
    770     return self._call_with_args(x, args, kwds)
    771 # Is there coercion?

File ~/sage-build/src/sage/rings/morphism.pyx:2054, in sage.rings.morphism.RingHomomorphism_im_gens._call_()
   2052     2*x + 3*y + 2*z
   2053 """
-> 2054 return x._im_gens_(self.codomain(), self.im_gens(), base_map=self.base_map())
   2055 
   2056 

File ~/sage-build/src/sage/rings/polynomial/polynomial_element.pyx:1305, in sage.rings.polynomial.polynomial_element.Polynomial._im_gens_()
   1303 if base_map is None:
   1304     base_map = codomain.coerce_map_from(self.base_ring())
-> 1305 result = base_map(self.get_unsafe(d))
   1306 i = d - 1
   1307 while i >= 0:

TypeError: 'NoneType' object is not callable
```
I am not even sure what is failing here actually.



---

archive/issue_comments_672212.json:
```json
{
    "body": "<a id='comment:5'></a>\nSage polynomials are involved, won't touch ;)",
    "created_at": "2022-09-18T03:19:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672212",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:5'></a>
Sage polynomials are involved, won't touch ;)



---

archive/issue_comments_672213.json:
```json
{
    "body": "<a id='comment:6'></a>\ncomment:213:\n\nThere really isn't much difference between `self._element_constructor_` and `self._element_constructor`. There might be some technical reason for having two, but the use is basically the same.\n\nNote that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`. Which while this has [some documentation](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions) to say it will be `None`, it also says this is a compile-time warning; basically, don't rely on it. The fact that it works without an `Element` or `_element_constructor_` looks a lot more like luck; it is definitely very brittle.\n\ncomment:210,[comment:211](#comment%3A211):\n\nAnother point about a `Parent` being a `Sets()` object is in `_init_category_`:\n\n```python\n        if can_assign_class(self) and not isinstance(self, Sets_parent_class):\n```\nThis isn't as strong as the `_test_category`, but it is special treatment for `Sets()`.\n\nYes we can change these things (in addition to the documentation), but we could change anything in these classes to be whatever we want.\n\n---\n\nHere is a proposal that will have a very limited impact on Sage at-large but solve the issues here:\n\nWe separate the stuff within `Parent` that deals with all of the set-like stuff (e.g., `_element_constructor`, `Element`, `_element_constructor_` `__contains__`, `__call__`) into a subclass `Bar` that inherits from `Foo` (names to be decided) and change the `Map._codomain` from `Parent` to `Foo`. This will have no impact on downstream classes that continue to inherit from `Bar`.\n\nI would propose `Foo` be `CategoryObject` and `Bar` be `Parent` to make the transition essentially seamless. (For this ticket even, we could just change `Map._codomain` to a `CategoryObject` and then have `DrinfeldModule` inherit from that as I am still willing to accept that.)\n\nThat way we make `Parent` something that really should be an object of `Sets()` and `CategoryObject()` work more generally, giving the clarification you want as well.",
    "created_at": "2022-09-18T04:05:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672213",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:6'></a>
comment:213:

There really isn't much difference between `self._element_constructor_` and `self._element_constructor`. There might be some technical reason for having two, but the use is basically the same.

Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`. Which while this has [some documentation](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions) to say it will be `None`, it also says this is a compile-time warning; basically, don't rely on it. The fact that it works without an `Element` or `_element_constructor_` looks a lot more like luck; it is definitely very brittle.

comment:210,[comment:211](#comment%3A211):

Another point about a `Parent` being a `Sets()` object is in `_init_category_`:

```python
        if can_assign_class(self) and not isinstance(self, Sets_parent_class):
```
This isn't as strong as the `_test_category`, but it is special treatment for `Sets()`.

Yes we can change these things (in addition to the documentation), but we could change anything in these classes to be whatever we want.

---

Here is a proposal that will have a very limited impact on Sage at-large but solve the issues here:

We separate the stuff within `Parent` that deals with all of the set-like stuff (e.g., `_element_constructor`, `Element`, `_element_constructor_` `__contains__`, `__call__`) into a subclass `Bar` that inherits from `Foo` (names to be decided) and change the `Map._codomain` from `Parent` to `Foo`. This will have no impact on downstream classes that continue to inherit from `Bar`.

I would propose `Foo` be `CategoryObject` and `Bar` be `Parent` to make the transition essentially seamless. (For this ticket even, we could just change `Map._codomain` to a `CategoryObject` and then have `DrinfeldModule` inherit from that as I am still willing to accept that.)

That way we make `Parent` something that really should be an object of `Sets()` and `CategoryObject()` work more generally, giving the clarification you want as well.



---

archive/issue_comments_672214.json:
```json
{
    "body": "<a id='comment:7'></a>\nYou proposed exactly that before, and I have already explained in detail why it's a bad idea.[comment:194](#comment%3A194)",
    "created_at": "2022-09-18T04:11:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672214",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:7'></a>
You proposed exactly that before, and I have already explained in detail why it's a bad idea.[comment:194](#comment%3A194)



---

archive/issue_comments_672215.json:
```json
{
    "body": "<a id='comment:218'></a>\nReplying to [Travis Scrimshaw](#comment%3A216):\n> Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`.\n\n\nYou're really trying to tell me that `Parent.__cinit__` forgets to initialize all of the slots except for `_action_hash`?\n\n> Which while this has [some documentation](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions) to say it will be `None`, it also says this is a compile-time warning; basically, don't rely on it.\n\n\nNo it doesn't. The compile-time warnings are for locals, not for cdef class slots.\n\n> The fact that it works without an `Element` or `_element_constructor_` looks a lot more like luck; it is definitely very brittle.\n\n\nNope.",
    "created_at": "2022-09-18T04:33:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672215",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:218'></a>
Replying to [Travis Scrimshaw](#comment%3A216):
> Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`.


You're really trying to tell me that `Parent.__cinit__` forgets to initialize all of the slots except for `_action_hash`?

> Which while this has [some documentation](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions) to say it will be `None`, it also says this is a compile-time warning; basically, don't rely on it.


No it doesn't. The compile-time warnings are for locals, not for cdef class slots.

> The fact that it works without an `Element` or `_element_constructor_` looks a lot more like luck; it is definitely very brittle.


Nope.



---

archive/issue_comments_672216.json:
```json
{
    "body": "<a id='comment:219'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A218):\n> Replying to [Travis Scrimshaw](#comment%3A216):\n> > Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`.\n\n> \n> You're really trying to tell me that `Parent.__cinit__` forgets to initialize all of the slots except for `_action_hash`?\n\n\nI said initialization, which includes `__init__`.\n\n> > Which while this has [some documentation](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions) to say it will be `None`, it also says this is a compile-time warning; basically, don't rely on it.\n\n> \n> No it doesn't. The compile-time warnings are for locals, not for cdef class slots.\n\n\nThen where it is documented that this is something you can rely on and is acceptable? I was taught very early on never to rely on this in C++. I don't see slots as that different than local variables.\n\n> > The fact that it works without an `Element` or `_element_constructor_` looks a lot more like luck; it is definitely very brittle.\n\n> \n> Nope.\n\n\nSince `_element_constructor_` is not required, I should be free to use that variable as I want, right? I can't simply set it equal to `2`:\n\n```\nsage: class Foo(Parent):\n....:     def __init__(self):\n....:         self._element_constructor_ = 2\n....:         super().__init__(category=Objects())\n....:         \nsage: F = Foo()\n...\nAssertionError: \n```\nThe fact that it is raising `NotImplementedError`s also says [this should be implemented](https://docs.python.org/3/library/exceptions.html#NotImplementedError).",
    "created_at": "2022-09-18T04:44:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672216",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:219'></a>
Replying to [Matthias Köppe](#comment%3A218):
> Replying to [Travis Scrimshaw](#comment%3A216):
> > Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`.

> 
> You're really trying to tell me that `Parent.__cinit__` forgets to initialize all of the slots except for `_action_hash`?


I said initialization, which includes `__init__`.

> > Which while this has [some documentation](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions) to say it will be `None`, it also says this is a compile-time warning; basically, don't rely on it.

> 
> No it doesn't. The compile-time warnings are for locals, not for cdef class slots.


Then where it is documented that this is something you can rely on and is acceptable? I was taught very early on never to rely on this in C++. I don't see slots as that different than local variables.

> > The fact that it works without an `Element` or `_element_constructor_` looks a lot more like luck; it is definitely very brittle.

> 
> Nope.


Since `_element_constructor_` is not required, I should be free to use that variable as I want, right? I can't simply set it equal to `2`:

```
sage: class Foo(Parent):
....:     def __init__(self):
....:         self._element_constructor_ = 2
....:         super().__init__(category=Objects())
....:         
sage: F = Foo()
...
AssertionError: 
```
The fact that it is raising `NotImplementedError`s also says [this should be implemented](https://docs.python.org/3/library/exceptions.html#NotImplementedError).



---

archive/issue_comments_672217.json:
```json
{
    "body": "<a id='comment:220'></a>\nIn Python's data model it makes absolutely no sense to have a slot that is typed as a Python object to be uninitialized. Just think about what the garbage collector / refcounting could possibly do with that.",
    "created_at": "2022-09-18T04:50:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672217",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:220'></a>
In Python's data model it makes absolutely no sense to have a slot that is typed as a Python object to be uninitialized. Just think about what the garbage collector / refcounting could possibly do with that.



---

archive/issue_comments_672218.json:
```json
{
    "body": "<a id='comment:221'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A217):\n> You proposed exactly that before, and I have already explained in detail why it's a bad idea.[comment:194](#comment%3A194)\n\n\nI think it is clear that there is a reason to model the distinction between an object in `Sets()`, which has a lot of extra infrastructure attached to it, and those that are not.  There is also a big difference between something that might not have elements (based on input) and something that will never have any by design. You also get rid of those pesky methods related to elements from the module that serve as a point of confusion to the user.",
    "created_at": "2022-09-18T04:50:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672218",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:221'></a>
Replying to [Matthias Köppe](#comment%3A217):
> You proposed exactly that before, and I have already explained in detail why it's a bad idea.[comment:194](#comment%3A194)


I think it is clear that there is a reason to model the distinction between an object in `Sets()`, which has a lot of extra infrastructure attached to it, and those that are not.  There is also a big difference between something that might not have elements (based on input) and something that will never have any by design. You also get rid of those pesky methods related to elements from the module that serve as a point of confusion to the user.



---

archive/issue_comments_672219.json:
```json
{
    "body": "<a id='comment:222'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A220):\n> In Python's data model it makes absolutely no sense to have a slot that is typed as a Python object to be uninitialized. Just think about what the garbage collector / refcounting could possibly do with that.\n\n\nI basically agree, but we do have weak refs. Also what is special about `None`? What if Cython decides to change it to `int(0)`?",
    "created_at": "2022-09-18T04:52:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672219",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:222'></a>
Replying to [Matthias Köppe](#comment%3A220):
> In Python's data model it makes absolutely no sense to have a slot that is typed as a Python object to be uninitialized. Just think about what the garbage collector / refcounting could possibly do with that.


I basically agree, but we do have weak refs. Also what is special about `None`? What if Cython decides to change it to `int(0)`?



---

archive/issue_comments_672220.json:
```json
{
    "body": "<a id='comment:223'></a>\nReplying to [Travis Scrimshaw](#comment%3A219):\n> Replying to [Matthias K\u00f6ppe](#comment%3A218):\n> > Replying to [Travis Scrimshaw](#comment%3A216):\n> > > Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`.\n\n> > \n> > You're really trying to tell me that `Parent.__cinit__` forgets to initialize all of the slots except for `_action_hash`?\n\n> \n> I said initialization, which includes `__init__`.\n\n\nAlso `Parent.__init__` does not initialize all declared slots.\n\nYou're forgetting `__new__`, which does the initialization of all slots.\nIn the Cython-generated C code (parent.c), you can find it as `__pyx_tp_new_4sage_9structure_6parent_Parent`.",
    "created_at": "2022-09-18T04:53:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672220",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:223'></a>
Replying to [Travis Scrimshaw](#comment%3A219):
> Replying to [Matthias Köppe](#comment%3A218):
> > Replying to [Travis Scrimshaw](#comment%3A216):
> > > Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`.

> > 
> > You're really trying to tell me that `Parent.__cinit__` forgets to initialize all of the slots except for `_action_hash`?

> 
> I said initialization, which includes `__init__`.


Also `Parent.__init__` does not initialize all declared slots.

You're forgetting `__new__`, which does the initialization of all slots.
In the Cython-generated C code (parent.c), you can find it as `__pyx_tp_new_4sage_9structure_6parent_Parent`.



---

archive/issue_comments_672221.json:
```json
{
    "body": "<a id='comment:224'></a>\nReplying to [Travis Scrimshaw](#comment%3A222):\n> Replying to [Matthias K\u00f6ppe](#comment%3A220):\n> > In Python's data model it makes absolutely no sense to have a slot that is typed as a Python object to be uninitialized. Just think about what the garbage collector / refcounting could possibly do with that.\n\n> \n> I basically agree, but we do have weak refs.\n\n\nThis is getting silly.",
    "created_at": "2022-09-18T04:54:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672221",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:224'></a>
Replying to [Travis Scrimshaw](#comment%3A222):
> Replying to [Matthias Köppe](#comment%3A220):
> > In Python's data model it makes absolutely no sense to have a slot that is typed as a Python object to be uninitialized. Just think about what the garbage collector / refcounting could possibly do with that.

> 
> I basically agree, but we do have weak refs.


This is getting silly.



---

archive/issue_comments_672222.json:
```json
{
    "body": "<a id='comment:5'></a>\nWell, we can continue that discussion on the subsequent tickets.\n\nFor here, can you live with this: Change `Map._codomain` to `CategoryObject` and we revert `DrinfeldMorphism` to inherit from `CategoryObject` as it doesn\u2019t use anything else in `Parent` other than to make the morphism code work.\n\nI know you won\u2019t be perfectly happy with this, but it is a fair concession on my part as well and it allows the code to be included without having to settle any contentious issues.",
    "created_at": "2022-09-18T05:26:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672222",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:5'></a>
Well, we can continue that discussion on the subsequent tickets.

For here, can you live with this: Change `Map._codomain` to `CategoryObject` and we revert `DrinfeldMorphism` to inherit from `CategoryObject` as it doesn’t use anything else in `Parent` other than to make the morphism code work.

I know you won’t be perfectly happy with this, but it is a fair concession on my part as well and it allows the code to be included without having to settle any contentious issues.



---

archive/issue_comments_672223.json:
```json
{
    "body": "<a id='comment:226'></a>\nReplying to [Travis Scrimshaw](#comment%3A225):\n> Change `Map._codomain` to `CategoryObject` \n\n\nNo, now *that* would be a radical change.\n\n> and we revert `DrinfeldMorphism` to inherit from `CategoryObject`\n\n\nI have already said in[comment:202](#comment%3A202) that I oppose adding direct uses of `CategoryObject`, for which there's no precedence in the code (other than 2 bad examples -[comment:113](#comment%3A113))",
    "created_at": "2022-09-18T05:37:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672223",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:226'></a>
Replying to [Travis Scrimshaw](#comment%3A225):
> Change `Map._codomain` to `CategoryObject` 


No, now *that* would be a radical change.

> and we revert `DrinfeldMorphism` to inherit from `CategoryObject`


I have already said in[comment:202](#comment%3A202) that I oppose adding direct uses of `CategoryObject`, for which there's no precedence in the code (other than 2 bad examples -[comment:113](#comment%3A113))



---

archive/issue_comments_672224.json:
```json
{
    "body": "<a id='comment:227'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A226):\n> Replying to [Travis Scrimshaw](#comment%3A225):\n> > Change `Map._codomain` to `CategoryObject` \n\n> \n> No, now *that* would be a radical change.\n\n\n... specifically, it's API-breaking on the Cython level.",
    "created_at": "2022-09-18T05:39:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672224",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:227'></a>
Replying to [Matthias Köppe](#comment%3A226):
> Replying to [Travis Scrimshaw](#comment%3A225):
> > Change `Map._codomain` to `CategoryObject` 

> 
> No, now *that* would be a radical change.


... specifically, it's API-breaking on the Cython level.



---

archive/issue_comments_672225.json:
```json
{
    "body": "<a id='comment:228'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A227):\n> Replying to [Matthias K\u00f6ppe](#comment%3A226):\n> > Replying to [Travis Scrimshaw](#comment%3A225):\n> > > Change `Map._codomain` to `CategoryObject` \n\n> > \n> > No, now *that* would be a radical change.\n\n> \n> ... specifically, it's API-breaking on the Cython level.\n\n\nHow? It is broadening the definition; it still accepts any `Parent` subclass.\n\nSpeaking of #28485, what do we want to do with objects that want to be in `Sets()` but do not want to implement elements (say, because we don\u2019t have a basis and any way to really represent them)? Do we want to have some kind of generic element object (similar to what the manifolds code does)?\n\nThere is also even less of a precedent for having a `Parent` without an `_element_constructor_`. You even opened a ticket for dealing with the only other case within Sage as far as I know.\n\nIf you\u2019re going to be unwilling to make any compromise, then we need to ask sage-devel and settle this by a group vote.",
    "created_at": "2022-09-18T06:03:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672225",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:228'></a>
Replying to [Matthias Köppe](#comment%3A227):
> Replying to [Matthias Köppe](#comment%3A226):
> > Replying to [Travis Scrimshaw](#comment%3A225):
> > > Change `Map._codomain` to `CategoryObject` 

> > 
> > No, now *that* would be a radical change.

> 
> ... specifically, it's API-breaking on the Cython level.


How? It is broadening the definition; it still accepts any `Parent` subclass.

Speaking of #28485, what do we want to do with objects that want to be in `Sets()` but do not want to implement elements (say, because we don’t have a basis and any way to really represent them)? Do we want to have some kind of generic element object (similar to what the manifolds code does)?

There is also even less of a precedent for having a `Parent` without an `_element_constructor_`. You even opened a ticket for dealing with the only other case within Sage as far as I know.

If you’re going to be unwilling to make any compromise, then we need to ask sage-devel and settle this by a group vote.



---

archive/issue_comments_672226.json:
```json
{
    "body": "<a id='comment:9'></a>\nA quick comment to mention a family of classes in Sage that are widely used, and which (I think) are parents without elements: projective spaces. These are objects which are central mathematical objects, they are parents but they do not support\u00a0`element_class`, `_element_constructor_`, etc. and they don't have any element class. I believe that there is no problem with their implementation.\n\nPlease check this example:\n\n```\nsage: E = ProjectiveSpace(2, QQ)\nsage: isinstance(E, Parent)\nTrue\nsage: E._element_constructor_\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n/usr/lib/python3/dist-packages/sage/structure/category_object.pyx in sage.structure.category_object.CategoryObject.getattr_from_category (build/cythonized/sage/structure/category_object.c:7175)()\n    838         try:\n--> 839             return self.__cached_methods[name]\n    840         except KeyError:\n\nKeyError: '_element_constructor_'\n\nDuring handling of the above exception, another exception occurred:\n\nAttributeError                            Traceback (most recent call last)\n<ipython-input-14-9183d16129b9> in <module>\n----> 1 E._element_constructor_\n\n/usr/lib/python3/dist-packages/sage/structure/category_object.pyx in sage.structure.category_object.CategoryObject.__getattr__ (build/cythonized/sage/structure/category_object.c:7094)()\n    831             AttributeError: 'PrimeNumbers_with_category' object has no attribute 'sadfasdf'\n    832         \"\"\"\n--> 833         return self.getattr_from_category(name)\n    834 \n    835     cdef getattr_from_category(self, name):\n\n/usr/lib/python3/dist-packages/sage/structure/category_object.pyx in sage.structure.category_object.CategoryObject.getattr_from_category (build/cythonized/sage/structure/category_object.c:7260)()\n    846                 cls = self._category.parent_class\n    847 \n--> 848             attr = getattr_from_other_class(self, cls, name)\n    849             self.__cached_methods[name] = attr\n    850             return attr\n\n/usr/lib/python3/dist-packages/sage/cpython/getattr.pyx in sage.cpython.getattr.getattr_from_other_class (build/cythonized/sage/cpython/getattr.c:2653)()\n    354         dummy_error_message.cls = type(self)\n    355         dummy_error_message.name = name\n--> 356         raise AttributeError(dummy_error_message)\n    357     cdef PyObject* attr = instance_getattr(cls, name)\n    358     if attr is NULL:\n\nAttributeError: 'ProjectiveSpace_rational_field_with_category' object has no attribute '_element_constructor_'\n```",
    "created_at": "2022-09-18T09:26:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672226",
    "user": "https://github.com/spaenlehauer"
}
```


<a id='comment:9'></a>
A quick comment to mention a family of classes in Sage that are widely used, and which (I think) are parents without elements: projective spaces. These are objects which are central mathematical objects, they are parents but they do not support `element_class`, `_element_constructor_`, etc. and they don't have any element class. I believe that there is no problem with their implementation.

Please check this example:

```
sage: E = ProjectiveSpace(2, QQ)
sage: isinstance(E, Parent)
True
sage: E._element_constructor_
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
/usr/lib/python3/dist-packages/sage/structure/category_object.pyx in sage.structure.category_object.CategoryObject.getattr_from_category (build/cythonized/sage/structure/category_object.c:7175)()
    838         try:
--> 839             return self.__cached_methods[name]
    840         except KeyError:

KeyError: '_element_constructor_'

During handling of the above exception, another exception occurred:

AttributeError                            Traceback (most recent call last)
<ipython-input-14-9183d16129b9> in <module>
----> 1 E._element_constructor_

/usr/lib/python3/dist-packages/sage/structure/category_object.pyx in sage.structure.category_object.CategoryObject.__getattr__ (build/cythonized/sage/structure/category_object.c:7094)()
    831             AttributeError: 'PrimeNumbers_with_category' object has no attribute 'sadfasdf'
    832         """
--> 833         return self.getattr_from_category(name)
    834 
    835     cdef getattr_from_category(self, name):

/usr/lib/python3/dist-packages/sage/structure/category_object.pyx in sage.structure.category_object.CategoryObject.getattr_from_category (build/cythonized/sage/structure/category_object.c:7260)()
    846                 cls = self._category.parent_class
    847 
--> 848             attr = getattr_from_other_class(self, cls, name)
    849             self.__cached_methods[name] = attr
    850             return attr

/usr/lib/python3/dist-packages/sage/cpython/getattr.pyx in sage.cpython.getattr.getattr_from_other_class (build/cythonized/sage/cpython/getattr.c:2653)()
    354         dummy_error_message.cls = type(self)
    355         dummy_error_message.name = name
--> 356         raise AttributeError(dummy_error_message)
    357     cdef PyObject* attr = instance_getattr(cls, name)
    358     if attr is NULL:

AttributeError: 'ProjectiveSpace_rational_field_with_category' object has no attribute '_element_constructor_'
```



---

archive/issue_comments_672227.json:
```json
{
    "body": "<a id='comment:230'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A208):\n> To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.\n\n\nYes! Personally, it is my main concern: I'm fine with having parents without elements or using `CategoryObject` but I'm more and more convinced that Drinfeld modules should not be elements and inherit from `RingHomomorphism`. For example, many methods of the class `Morphism` (e.g. `is_injective`) are not really relevant for Drinfeld modules, similarly the composing a \"Drinfeld module\" `phi` with another ring homomorphism is usually not meaningful.\n\nHowever, following basically David's suggestion (see[comment:133](#comment%3A133)), I have a new proposal which, I think, could be a good compromise for everyone (including Travis `:-)`):\n- we keep the current structure where a Drinfeld module is a parent `phi`,\n- we define elements in Drinfeld modules; those will just be skew polynomials (i.e. elements of `L{tau}`) and we even do not need a new class for this (i.e. we simply set `phi.Element = sage.rings.polynomials.skew_polynomial_element.SkewPolynomial_generic_dense` - or possibly a subclass of it, if relevant),\n- if `phi` is a Drinfeld module, we set up a **conversion** map `Fq[X] -> phi` and a **coercion** map `L{tau} -> phi`.\n\nThis solves the problem that a parent has no element.\nThis natively allows for the constructions `phi(a)` and `phi(a)*P` (for `a` in `Fq[X]` and `P` in `L{tau}`) without any acrobatics. \nThis also makes sense with morphisms: a morphism between Drinfeld modules `f : phi -> psi` induces a mapping `L{tau} -> L{tau}` which is the right multiplication by `F` where `F` is the skew polynomial defining `f`. So we can then just implement morphisms as actual maps.\n\nMoreover, as I realized recently, the set `L{tau}` equipped with the action of `Fq[X]` given by `phi` nicely reflects many properties of the Drinfeld module. Here are a few concrete facts illustrating this:\n- `L{tau}`, considered as a module over `L[X]`, is free of finite rank and its rank is equal to the rank of the Drinfeld module (it might also be correct with `Fq[X]` replaced by `A` and `L[X]` replaced by `A (x) L` accordingly but I haven't checked it);\n- as I said above, a morphism between Drinfeld modules induces a map on `L{tau}`; this map commutes with the action of the Drinfeld modules (i.e. it satisfies `f(phi(a)*P) = psi(a)*f(P)` for all `a` and `P`) and its determinant gives what is called the norm of `f`;\n- for `m` in `Fq[X]`, coprime with the characteristic, the quotient of `L{tau}` by `phi(m)` is directly related to the (dual of the) `m`-torsion of `phi`.\n\nIf all of you agree with my proposal, I'll be happy to implement it!",
    "created_at": "2022-09-18T10:09:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672227",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:230'></a>
Replying to [Matthias Köppe](#comment%3A208):
> To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.


Yes! Personally, it is my main concern: I'm fine with having parents without elements or using `CategoryObject` but I'm more and more convinced that Drinfeld modules should not be elements and inherit from `RingHomomorphism`. For example, many methods of the class `Morphism` (e.g. `is_injective`) are not really relevant for Drinfeld modules, similarly the composing a "Drinfeld module" `phi` with another ring homomorphism is usually not meaningful.

However, following basically David's suggestion (see[comment:133](#comment%3A133)), I have a new proposal which, I think, could be a good compromise for everyone (including Travis `:-)`):
- we keep the current structure where a Drinfeld module is a parent `phi`,
- we define elements in Drinfeld modules; those will just be skew polynomials (i.e. elements of `L{tau}`) and we even do not need a new class for this (i.e. we simply set `phi.Element = sage.rings.polynomials.skew_polynomial_element.SkewPolynomial_generic_dense` - or possibly a subclass of it, if relevant),
- if `phi` is a Drinfeld module, we set up a **conversion** map `Fq[X] -> phi` and a **coercion** map `L{tau} -> phi`.

This solves the problem that a parent has no element.
This natively allows for the constructions `phi(a)` and `phi(a)*P` (for `a` in `Fq[X]` and `P` in `L{tau}`) without any acrobatics. 
This also makes sense with morphisms: a morphism between Drinfeld modules `f : phi -> psi` induces a mapping `L{tau} -> L{tau}` which is the right multiplication by `F` where `F` is the skew polynomial defining `f`. So we can then just implement morphisms as actual maps.

Moreover, as I realized recently, the set `L{tau}` equipped with the action of `Fq[X]` given by `phi` nicely reflects many properties of the Drinfeld module. Here are a few concrete facts illustrating this:
- `L{tau}`, considered as a module over `L[X]`, is free of finite rank and its rank is equal to the rank of the Drinfeld module (it might also be correct with `Fq[X]` replaced by `A` and `L[X]` replaced by `A (x) L` accordingly but I haven't checked it);
- as I said above, a morphism between Drinfeld modules induces a map on `L{tau}`; this map commutes with the action of the Drinfeld modules (i.e. it satisfies `f(phi(a)*P) = psi(a)*f(P)` for all `a` and `P`) and its determinant gives what is called the norm of `f`;
- for `m` in `Fq[X]`, coprime with the characteristic, the quotient of `L{tau}` by `phi(m)` is directly related to the (dual of the) `m`-torsion of `phi`.

If all of you agree with my proposal, I'll be happy to implement it!



---

archive/issue_comments_672228.json:
```json
{
    "body": "<a id='comment:231'></a>\nMany thanks for this suggestion, Xavier. It makes complete sense to me and I also believe that this might be a good compromise for everyone.\n\nIn fact, to me, elements in `L{tau}` can play the role of functions on elliptic curves. A difficult thing with Drinfeld modules is that `L{tau}` represents at the same time \"functions\" and morphisms, which can lead to some confusion.\n\nIf we want to make a parallel with elliptic curves, I think that a way to look at this is to consider the `Z`-module structure (edit: this is incorrect, it is not a `Z`-module) on the function field of an elliptic curve obtained by composing functions with the endomorphisms of multiplication by integers (which we can see better by using the analytic lattice representation of a complex elliptic curve). This would somehow be the analog of the `L[X]`-module structure on `L{tau}` that you describe. Does this analogy make sense?\n\nI am slightly uncomfortable because functions are not elements of an elliptic curve, and therefore it bothers me a little bit that `L{tau}` is an element class of a Drinfeld module. I would prefer that Drinfeld modules do not have elements at all, but we have to find some compromise and this solution would be fine with me.\n\nMany thanks again!\n\nP.S. \nReplying to [Xavier Caruso](#comment%3A230):\n> (it might also be correct with `Fq[X]` replaced by `A` and `L[X]` replaced by `A (x) L` accordingly but I haven't checked it);\n\n\nI am not sure, but perhaps the rank-1 Drinfeld modules in Lemma 2.5 in https://arxiv.org/pdf/2203.06970.pdf provide counterexamples (there `A` is the coordinate ring of an imaginary hyperelliptic curve).",
    "created_at": "2022-09-18T12:30:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672228",
    "user": "https://github.com/spaenlehauer"
}
```


<a id='comment:231'></a>
Many thanks for this suggestion, Xavier. It makes complete sense to me and I also believe that this might be a good compromise for everyone.

In fact, to me, elements in `L{tau}` can play the role of functions on elliptic curves. A difficult thing with Drinfeld modules is that `L{tau}` represents at the same time "functions" and morphisms, which can lead to some confusion.

If we want to make a parallel with elliptic curves, I think that a way to look at this is to consider the `Z`-module structure (edit: this is incorrect, it is not a `Z`-module) on the function field of an elliptic curve obtained by composing functions with the endomorphisms of multiplication by integers (which we can see better by using the analytic lattice representation of a complex elliptic curve). This would somehow be the analog of the `L[X]`-module structure on `L{tau}` that you describe. Does this analogy make sense?

I am slightly uncomfortable because functions are not elements of an elliptic curve, and therefore it bothers me a little bit that `L{tau}` is an element class of a Drinfeld module. I would prefer that Drinfeld modules do not have elements at all, but we have to find some compromise and this solution would be fine with me.

Many thanks again!

P.S. 
Replying to [Xavier Caruso](#comment%3A230):
> (it might also be correct with `Fq[X]` replaced by `A` and `L[X]` replaced by `A (x) L` accordingly but I haven't checked it);


I am not sure, but perhaps the rank-1 Drinfeld modules in Lemma 2.5 in https://arxiv.org/pdf/2203.06970.pdf provide counterexamples (there `A` is the coordinate ring of an imaginary hyperelliptic curve).



---

archive/issue_comments_672229.json:
```json
{
    "body": "<a id='comment:232'></a>\nReplying to [Xavier Caruso](#comment%3A230):\n> I have a new proposal which, I think, could be a good compromise for everyone (including Travis `:-)`):\n> - we keep the current structure where a Drinfeld module is a parent `phi`,\n> - we define elements in Drinfeld modules; those will just be skew polynomials (i.e. elements of `L{tau}`) and we even do not need a new class for this (i.e. we simply set `phi.Element = sage.rings.polynomials.skew_polynomial_element.SkewPolynomial_generic_dense` - or possibly a subclass of it, if relevant),\n> - if `phi` is a Drinfeld module, we set up a **conversion** map `Fq[X] -> phi` and a **coercion** map `L{tau} -> phi`.\n\n\nThis sounds like a good alternative and it fixes what I didn't like from what I proposed: the elements are actual skew polynomial, not a new class.",
    "created_at": "2022-09-18T14:39:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672229",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:232'></a>
Replying to [Xavier Caruso](#comment%3A230):
> I have a new proposal which, I think, could be a good compromise for everyone (including Travis `:-)`):
> - we keep the current structure where a Drinfeld module is a parent `phi`,
> - we define elements in Drinfeld modules; those will just be skew polynomials (i.e. elements of `L{tau}`) and we even do not need a new class for this (i.e. we simply set `phi.Element = sage.rings.polynomials.skew_polynomial_element.SkewPolynomial_generic_dense` - or possibly a subclass of it, if relevant),
> - if `phi` is a Drinfeld module, we set up a **conversion** map `Fq[X] -> phi` and a **coercion** map `L{tau} -> phi`.


This sounds like a good alternative and it fixes what I didn't like from what I proposed: the elements are actual skew polynomial, not a new class.



---

archive/issue_comments_672230.json:
```json
{
    "body": "<a id='comment:233'></a>\nReplying to [gh-spaenlehauer](#comment%3A231):\n> I am slightly uncomfortable because functions are not elements of an elliptic curve, and therefore it bothers me a little bit that `L{tau}` is an element class of a Drinfeld module. I would prefer that Drinfeld modules do not have elements at all, but we have to find some compromise and this solution would be fine with me.\n\n\n(P.S. I'd like to mention quickly that I believe that this analogy with functions on elliptic curves has a mathematical formalization via shtukas. In fact, the `L[X]`-module structure of `L{tau}` is described in Goss' book \"Basic Structures of Function Field Arithmetic\" before Definition 6.2.10. From this module structure, we can build a sheaf of `O_X`-modules (in our case, since `A = Fq[X]`, we have `X = P^1`) which mimics the twisted sheaves `O(n)` in projective geometry, see Definition 6.2.10. So you really have a notion of \"functions\" from this module structure, and in some sense this makes Drinfeld modules into projective objects.)",
    "created_at": "2022-09-18T15:38:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672230",
    "user": "https://github.com/spaenlehauer"
}
```


<a id='comment:233'></a>
Replying to [gh-spaenlehauer](#comment%3A231):
> I am slightly uncomfortable because functions are not elements of an elliptic curve, and therefore it bothers me a little bit that `L{tau}` is an element class of a Drinfeld module. I would prefer that Drinfeld modules do not have elements at all, but we have to find some compromise and this solution would be fine with me.


(P.S. I'd like to mention quickly that I believe that this analogy with functions on elliptic curves has a mathematical formalization via shtukas. In fact, the `L[X]`-module structure of `L{tau}` is described in Goss' book "Basic Structures of Function Field Arithmetic" before Definition 6.2.10. From this module structure, we can build a sheaf of `O_X`-modules (in our case, since `A = Fq[X]`, we have `X = P^1`) which mimics the twisted sheaves `O(n)` in projective geometry, see Definition 6.2.10. So you really have a notion of "functions" from this module structure, and in some sense this makes Drinfeld modules into projective objects.)



---

archive/issue_events_099731.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33713#event-99731"
}
```




---

archive/issue_events_099732.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33713#event-99732"
}
```




---

archive/issue_comments_672231.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/52e6d06336bc0802624670c4a4c6f43c6e24961b\">52e6d06</a></td><td><code>(minor) Change a comment in a doctstring</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d6174065977780a9fdaa8d7de4131f1c52e421c3\">d617406</a></td><td><code>Add a better error message in DrinfeldModules when the characteristic is not implemented</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1eab9ee6a594ee1f50148325cbdc23632d1ffc1b\">1eab9ee</a></td><td><code>Fix height method</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bcdfb60284efc88d246625b61b72ae86773ee6d5\">bcdfb60</a></td><td><code>Fix definition of finite drinfeld module in FiniteDrinfeldModule</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b1ce35539c8ed0b00fb0fe302b696538b9bd65a4\">b1ce355</a></td><td><code>Merge branch 'develop' into public/drinfeld_module</code></td></tr></table>\n",
    "created_at": "2022-09-20T16:48:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672231",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/52e6d06336bc0802624670c4a4c6f43c6e24961b">52e6d06</a></td><td><code>(minor) Change a comment in a doctstring</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d6174065977780a9fdaa8d7de4131f1c52e421c3">d617406</a></td><td><code>Add a better error message in DrinfeldModules when the characteristic is not implemented</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1eab9ee6a594ee1f50148325cbdc23632d1ffc1b">1eab9ee</a></td><td><code>Fix height method</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bcdfb60284efc88d246625b61b72ae86773ee6d5">bcdfb60</a></td><td><code>Fix definition of finite drinfeld module in FiniteDrinfeldModule</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b1ce35539c8ed0b00fb0fe302b696538b9bd65a4">b1ce355</a></td><td><code>Merge branch 'develop' into public/drinfeld_module</code></td></tr></table>




---

archive/issue_comments_672232.json:
```json
{
    "body": "**Changing commit** from \"[4412ad191092e9d5bab82d1ad73a669dc83d6f96](https://github.com/sagemath/sagetrac-mirror/commit/4412ad191092e9d5bab82d1ad73a669dc83d6f96)\" to \"[b1ce35539c8ed0b00fb0fe302b696538b9bd65a4](https://github.com/sagemath/sagetrac-mirror/commit/b1ce35539c8ed0b00fb0fe302b696538b9bd65a4)\".",
    "created_at": "2022-09-20T16:48:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672232",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[4412ad191092e9d5bab82d1ad73a669dc83d6f96](https://github.com/sagemath/sagetrac-mirror/commit/4412ad191092e9d5bab82d1ad73a669dc83d6f96)" to "[b1ce35539c8ed0b00fb0fe302b696538b9bd65a4](https://github.com/sagemath/sagetrac-mirror/commit/b1ce35539c8ed0b00fb0fe302b696538b9bd65a4)".



---

archive/issue_comments_672233.json:
```json
{
    "body": "<a id='comment:6'></a>\nIn the last commits, I fixed the `height` method of `DrinfeldModule`, which was\ncompletely wrong. My apologies for that.",
    "created_at": "2022-09-20T16:48:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672233",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:6'></a>
In the last commits, I fixed the `height` method of `DrinfeldModule`, which was
completely wrong. My apologies for that.



---

archive/issue_comments_672234.json:
```json
{
    "body": "<a id='comment:237'></a>\nReplying to [Xavier Caruso](#comment%3A230):\n\n> Yes! Personally, it is my main concern: I'm fine with having parents without elements or using `CategoryObject` but I'm more and more convinced that Drinfeld modules should not be elements and inherit from `RingHomomorphism`. For example, many methods of the class `Morphism` (e.g. `is_injective`) are not really relevant for Drinfeld modules, similarly the composing a \"Drinfeld module\" `phi` with another ring homomorphism is usually not meaningful.\n\n\nStrong agreement.\n\n> However, following basically David's suggestion (see[comment:133](#comment%3A133)), I have a new proposal which, I think, could be a good compromise for everyone (including Travis `:-)`):\n\n\nThank you very much Xavier for your proposal. I hope that I understand it\ncorrectly, please correct me if I am mistaken.\n\nMy understanding is that you propose to have Ore polynomials as elements\nbecause the morphism that characterize the Drinfeld module has codomain\n`\\Ltau`. It seems to me however that this vision, which is not canonical,\nfirmly depends on the construction we choose for Drinfeld modules. I am also\nafraid that this would convey the misconception that a Drinfeld module is a set\nof Ore polynomials. Although this implementation constructs Drinfeld modules as\nring morphisms `\\phi: \\Fq[X] \\to \\Ltau` (*algebraic* construction), let us\nrecall that Drinfeld modules can be constructed in an *analytic* fashion, in\nwhich Drinfeld modules and their isogenies, are respectively lattices and\nelements in the algebraic closure of a completion of the base field with\nrespect to the place at infinity [Gos98, Section 4.6]. There is an equivalence\nof categories between the *category* of \"algebraic\" of Drinfeld modules and\nthat of \"analytic\" Drinfeld modules [Gos98, Theorem 4.6.9]. (Another reason why\n`DrinfeldModules` should, in my opinion, stay as a `Category` and\n`DrinfeldModule` as a `Parent`.)\n\nDespite being vastly different in its very own nature, the analytic\nconstruction proves the same theorems (e.g. the rank can be analytically\ndefined and it turns out to be the same integer in both cases). It is essential\nto me that the implementation is as agnostic of the construction as it can be,\nas can be that of elliptic curves.\n\nConsequently, I would disagree with `DrinfeldModule` having those elements.\nEven though I appreciate that your proposition aims at satisfying everybody, I\nwould like to argue once more that Drinfeld modules should not have elements,\nand that until now, all propositions in that direction seemed, in my view,\ndetrimental to what the mathematical image that the implementation should\nreflect.\n\n> This also makes sense with morphisms: a morphism between Drinfeld modules `f : phi -> psi` induces a mapping `L{tau} -> L{tau}` which is the right multiplication by `F` where `F` is the skew polynomial defining `f`. So we can then just implement morphisms as actual maps.\n\n\nI am not convinced however on implementing Drinfeld module morphisms as actual\nmaps. It is true that Drinfeld module morphisms induce an action from `\\Fq[X]`\nor `L[X]` on `\\Ltau`,  but the *principle of least astonishment* strongly\nadvocates for Drinfeld module morphisms to be defined with Ore polynomials,\nlike in the literature, and not maps. However, the action on `\\Ltau` can be\ncomputed and retrieved using new, different methods.",
    "created_at": "2022-09-20T16:51:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672234",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:237'></a>
Replying to [Xavier Caruso](#comment%3A230):

> Yes! Personally, it is my main concern: I'm fine with having parents without elements or using `CategoryObject` but I'm more and more convinced that Drinfeld modules should not be elements and inherit from `RingHomomorphism`. For example, many methods of the class `Morphism` (e.g. `is_injective`) are not really relevant for Drinfeld modules, similarly the composing a "Drinfeld module" `phi` with another ring homomorphism is usually not meaningful.


Strong agreement.

> However, following basically David's suggestion (see[comment:133](#comment%3A133)), I have a new proposal which, I think, could be a good compromise for everyone (including Travis `:-)`):


Thank you very much Xavier for your proposal. I hope that I understand it
correctly, please correct me if I am mistaken.

My understanding is that you propose to have Ore polynomials as elements
because the morphism that characterize the Drinfeld module has codomain
`\Ltau`. It seems to me however that this vision, which is not canonical,
firmly depends on the construction we choose for Drinfeld modules. I am also
afraid that this would convey the misconception that a Drinfeld module is a set
of Ore polynomials. Although this implementation constructs Drinfeld modules as
ring morphisms `\phi: \Fq[X] \to \Ltau` (*algebraic* construction), let us
recall that Drinfeld modules can be constructed in an *analytic* fashion, in
which Drinfeld modules and their isogenies, are respectively lattices and
elements in the algebraic closure of a completion of the base field with
respect to the place at infinity [Gos98, Section 4.6]. There is an equivalence
of categories between the *category* of "algebraic" of Drinfeld modules and
that of "analytic" Drinfeld modules [Gos98, Theorem 4.6.9]. (Another reason why
`DrinfeldModules` should, in my opinion, stay as a `Category` and
`DrinfeldModule` as a `Parent`.)

Despite being vastly different in its very own nature, the analytic
construction proves the same theorems (e.g. the rank can be analytically
defined and it turns out to be the same integer in both cases). It is essential
to me that the implementation is as agnostic of the construction as it can be,
as can be that of elliptic curves.

Consequently, I would disagree with `DrinfeldModule` having those elements.
Even though I appreciate that your proposition aims at satisfying everybody, I
would like to argue once more that Drinfeld modules should not have elements,
and that until now, all propositions in that direction seemed, in my view,
detrimental to what the mathematical image that the implementation should
reflect.

> This also makes sense with morphisms: a morphism between Drinfeld modules `f : phi -> psi` induces a mapping `L{tau} -> L{tau}` which is the right multiplication by `F` where `F` is the skew polynomial defining `f`. So we can then just implement morphisms as actual maps.


I am not convinced however on implementing Drinfeld module morphisms as actual
maps. It is true that Drinfeld module morphisms induce an action from `\Fq[X]`
or `L[X]` on `\Ltau`,  but the *principle of least astonishment* strongly
advocates for Drinfeld module morphisms to be defined with Ore polynomials,
like in the literature, and not maps. However, the action on `\Ltau` can be
computed and retrieved using new, different methods.



---

archive/issue_comments_672235.json:
```json
{
    "body": "<a id='comment:8'></a>\nHello Antoine, I think that my[comment:125](#comment%3A125) got lost in the conversation, but you deleted a line by inadvertence:\n\n```diff\ndiff --git a/src/sage/rings/function_field/all.py b/src/sage/rings/function_field/all.py\nindex b6bba33..6904f3e 100644\n--- a/src/sage/rings/function_field/all.py\n+++ b/src/sage/rings/function_field/all.py\n@@ -1 +1 @@\n-from .constructor import FunctionField\n+from .drinfeld_modules.all import *\n```\n\nYou should add back the line\n\n```\nfrom .constructor import FunctionField\n```\notherwise you are removing `FunctionField` from the global namespace and that's why you have so many failed doctests (this has been bugging me for some times now! `:-)`). Also, you should not import directly from `.all`, but instead import the desired class directly from the right module.\n\nConsidering having Ore polynomials as an element class, I'm not sure I understand the link between your disagreement and the analytic uniformization of a Drinfeld module as a `A`-lattice in `\\CC_{\\infty}`. *If ever* Drinfeld modules are implemented analytically as `A`-lattices, the new implementation will very likely be different from this one. From a programming point of view, I think that having a Ore polynomials as \"elements\" could be beneficial in the sense that you would not have to override the double underscore `__call__` method (which don't seems to be advised to do: [ref](https://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#outline), is this outdated?) and this would allow the implementation of coercion and conversion as Xavier mentioned.\n\nFrom a mathematical point of view, I agree with you, Drinfeld does not have elements, but I think that this is something that you could mention in the reference manual. In order words, mention to the user that even thought the class `DrinfeldModule` uses Ore polynomials as an element class, it was implemented purely for programming purposes and that it is important to know that, mathematically, Drinfeld modules **does not** have elements.",
    "created_at": "2022-09-20T18:05:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672235",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:8'></a>
Hello Antoine, I think that my[comment:125](#comment%3A125) got lost in the conversation, but you deleted a line by inadvertence:

```diff
diff --git a/src/sage/rings/function_field/all.py b/src/sage/rings/function_field/all.py
index b6bba33..6904f3e 100644
--- a/src/sage/rings/function_field/all.py
+++ b/src/sage/rings/function_field/all.py
@@ -1 +1 @@
-from .constructor import FunctionField
+from .drinfeld_modules.all import *
```

You should add back the line

```
from .constructor import FunctionField
```
otherwise you are removing `FunctionField` from the global namespace and that's why you have so many failed doctests (this has been bugging me for some times now! `:-)`). Also, you should not import directly from `.all`, but instead import the desired class directly from the right module.

Considering having Ore polynomials as an element class, I'm not sure I understand the link between your disagreement and the analytic uniformization of a Drinfeld module as a `A`-lattice in `\CC_{\infty}`. *If ever* Drinfeld modules are implemented analytically as `A`-lattices, the new implementation will very likely be different from this one. From a programming point of view, I think that having a Ore polynomials as "elements" could be beneficial in the sense that you would not have to override the double underscore `__call__` method (which don't seems to be advised to do: [ref](https://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#outline), is this outdated?) and this would allow the implementation of coercion and conversion as Xavier mentioned.

From a mathematical point of view, I agree with you, Drinfeld does not have elements, but I think that this is something that you could mention in the reference manual. In order words, mention to the user that even thought the class `DrinfeldModule` uses Ore polynomials as an element class, it was implemented purely for programming purposes and that it is important to know that, mathematically, Drinfeld modules **does not** have elements.



---

archive/issue_comments_672236.json:
```json
{
    "body": "<a id='comment:239'></a>\nReplying to [Antoine Leudi\u00e8re](#comment%3A237):\n> My understanding is that you propose to have Ore polynomials as elements\n> because the morphism that characterize the Drinfeld module has codomain\n> `\\Ltau`.\n\n\nThat's correct that I'm proposing to have Ore polynomials as elements but the reason is not only the the defining morphism has codomain `Ltau`.\n\nThis proposal is actually supported by the \"T-motive viewpoint\" on Drinfeld modules (which was already quickly mentioned in[comment:59](#comment%3A59) by David). Recall that, in our setting, a T-motive is a module `M` over `L[X]{tau}` which is finitely generated over `L{tau}` and satisfies an extra condition (Definition 5.4.5 in Gos' book). It turns out that one can attach a T-motive to each Drinfeld module `phi : Fq[X] -> L{tau}`: it is actually just `M = L{tau}` on which `X` acts by multiplication by `phi(X)`.\n\nHence, my proposal roughly consists in deciding to adopt this point of view and use a bivalent representation of Drinfeld module: morphism on the one hand, T-motive on the other hand. In this perspective, having elements is not just a hack for pleasing Travis (`:-)`) but it also has a strong mathematical meaning.",
    "created_at": "2022-09-20T19:57:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672236",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:239'></a>
Replying to [Antoine Leudière](#comment%3A237):
> My understanding is that you propose to have Ore polynomials as elements
> because the morphism that characterize the Drinfeld module has codomain
> `\Ltau`.


That's correct that I'm proposing to have Ore polynomials as elements but the reason is not only the the defining morphism has codomain `Ltau`.

This proposal is actually supported by the "T-motive viewpoint" on Drinfeld modules (which was already quickly mentioned in[comment:59](#comment%3A59) by David). Recall that, in our setting, a T-motive is a module `M` over `L[X]{tau}` which is finitely generated over `L{tau}` and satisfies an extra condition (Definition 5.4.5 in Gos' book). It turns out that one can attach a T-motive to each Drinfeld module `phi : Fq[X] -> L{tau}`: it is actually just `M = L{tau}` on which `X` acts by multiplication by `phi(X)`.

Hence, my proposal roughly consists in deciding to adopt this point of view and use a bivalent representation of Drinfeld module: morphism on the one hand, T-motive on the other hand. In this perspective, having elements is not just a hack for pleasing Travis (`:-)`) but it also has a strong mathematical meaning.



---

archive/issue_comments_672237.json:
```json
{
    "body": "<a id='comment:240'></a>\nReplying to [Xavier Caruso](#comment%3A239):\n> This proposal is actually supported by the \"T-motive viewpoint\" on Drinfeld modules (which was already quickly mentioned in[comment:59](#comment%3A59) by David). Recall that, in our setting, a T-motive is a module `M` over `L[X]{tau}` which is finitely generated over `L{tau}` and satisfies an extra condition (Definition 5.4.5 is Gos' book). It turns out that one can attach a T-motive to each Drinfeld module `phi : Fq[X] -> L{tau}`: it is actually just `M = L{tau}` on which `X` acts by multiplication by `phi(X)`.\n\n\nThat is a really nice point of view (that I hadn't thought) and it would fit well in a potential future implementation of t-motives.",
    "created_at": "2022-09-20T20:46:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672237",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:240'></a>
Replying to [Xavier Caruso](#comment%3A239):
> This proposal is actually supported by the "T-motive viewpoint" on Drinfeld modules (which was already quickly mentioned in[comment:59](#comment%3A59) by David). Recall that, in our setting, a T-motive is a module `M` over `L[X]{tau}` which is finitely generated over `L{tau}` and satisfies an extra condition (Definition 5.4.5 is Gos' book). It turns out that one can attach a T-motive to each Drinfeld module `phi : Fq[X] -> L{tau}`: it is actually just `M = L{tau}` on which `X` acts by multiplication by `phi(X)`.


That is a really nice point of view (that I hadn't thought) and it would fit well in a potential future implementation of t-motives.



---

archive/issue_comments_672238.json:
```json
{
    "body": "<a id='comment:1'></a>\nIt is a really nice viewpoint, but I am a bit confused because I thought that the category of T-motives is actually dual to that of T-modules (which generalize Drinfeld modules) by Thm. 5.4.11 in Goss.\n\nBy adopting this viewpoint and by saying that elements in `L{tau}` are elements of Drinfeld modules, aren't we creating confusion between geometric objects (T-modules, Drinfeld modules) and their duals (T-motives, which I think of as functions on T-modules)?\n\nTo me, this feels like saying that an elliptic curve and its coordinate ring are the same (a T-module would be the analog of an elliptic curve/abelian variety, and a T-motive would be the analog of its coordinate ring).\nOr similarly, it would be like identifying linear forms with vector spaces, or affine schemes with commutative rings. To me, these are distinct categories (but dual/anti-equivalent to each other), so this is why I feel a bit uncomfortable.\n\nAm I misunderstanding something?",
    "created_at": "2022-09-20T21:41:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672238",
    "user": "https://github.com/spaenlehauer"
}
```


<a id='comment:1'></a>
It is a really nice viewpoint, but I am a bit confused because I thought that the category of T-motives is actually dual to that of T-modules (which generalize Drinfeld modules) by Thm. 5.4.11 in Goss.

By adopting this viewpoint and by saying that elements in `L{tau}` are elements of Drinfeld modules, aren't we creating confusion between geometric objects (T-modules, Drinfeld modules) and their duals (T-motives, which I think of as functions on T-modules)?

To me, this feels like saying that an elliptic curve and its coordinate ring are the same (a T-module would be the analog of an elliptic curve/abelian variety, and a T-motive would be the analog of its coordinate ring).
Or similarly, it would be like identifying linear forms with vector spaces, or affine schemes with commutative rings. To me, these are distinct categories (but dual/anti-equivalent to each other), so this is why I feel a bit uncomfortable.

Am I misunderstanding something?



---

archive/issue_comments_672239.json:
```json
{
    "body": "<a id='comment:242'></a>\nReplying to [gh-spaenlehauer](#comment%3A241):\n> It is a really nice viewpoint, but I am a bit confused because I thought that the category of T-motives is actually dual to that of T-modules (which generalize Drinfeld modules) by Thm. 5.4.11 in Goss.\n\n\nOh god, you're right, that's annoying!\n\nVery concretely, the issue is that a morphism of Drinfeld modules `f : phi -> psi` defines a map from the `L{tau}` associated to `psi` to the `L{tau}` associated to `phi` (and not in the other direction as I've been thinking).\n\nAn easy fix to this would be to let `a` in `Fq[X]` act on `L{tau}` by **left** multiplication by `phi(a)` (and not right multiplication as we do for T-motives). Doing this, we are moving a little bit from the standards but maybe it could be acceptable, I don't know.",
    "created_at": "2022-09-21T05:55:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672239",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:242'></a>
Replying to [gh-spaenlehauer](#comment%3A241):
> It is a really nice viewpoint, but I am a bit confused because I thought that the category of T-motives is actually dual to that of T-modules (which generalize Drinfeld modules) by Thm. 5.4.11 in Goss.


Oh god, you're right, that's annoying!

Very concretely, the issue is that a morphism of Drinfeld modules `f : phi -> psi` defines a map from the `L{tau}` associated to `psi` to the `L{tau}` associated to `phi` (and not in the other direction as I've been thinking).

An easy fix to this would be to let `a` in `Fq[X]` act on `L{tau}` by **left** multiplication by `phi(a)` (and not right multiplication as we do for T-motives). Doing this, we are moving a little bit from the standards but maybe it could be acceptable, I don't know.



---

archive/issue_comments_672240.json:
```json
{
    "body": "<a id='comment:3'></a>\nMy view on this is that I think that I would prefer to have distinct classes for Drinfeld modules and for T-motives, similarly to the fact that in Sage affine schemes and commutative rings are distinct classes that represent dual objects.\n\nSo an easy solution might be to leave the code for Drinfeld modules as it is currently. Actually, I believe that it captures well the mathematical properties that we want for Drinfeld modules, and I actually do not understand what is the problem with its current structure. Then, following Xavier's suggestion, we could create another class for T-motives (whose elements are Ore polynomials (edit: more precisely, elements in a finitely-generated free module over a ring of Ore polynomials)), which could interact with the class of Drinfeld modules in the following way: once this class for T-motives is implemented, we could add a method to the Drinfeld module class which constructs the associated T-motive.\n\nA long term objective might be to implement also the category of T-modules, and why not, a (sub)-category of shtukas (as I understand it, it adds a \"sheaf of functions\" layer to T-modules and this sheaf is constructed from the dual T-motive, in the same way that affine/projective schemes construct sheaves from a (graded) ring). However, this would probably require a large amount of work, which is probably out of the scope of this trac ticket.\n\nThe first step of this would be to integrate Antoine's code for Drinfeld modules in Sage; honestly, at this point I still cannot see the reason why the current code cannot be integrated (of course modulo correcting some small bugs that may be found during the review).",
    "created_at": "2022-09-21T07:56:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672240",
    "user": "https://github.com/spaenlehauer"
}
```


<a id='comment:3'></a>
My view on this is that I think that I would prefer to have distinct classes for Drinfeld modules and for T-motives, similarly to the fact that in Sage affine schemes and commutative rings are distinct classes that represent dual objects.

So an easy solution might be to leave the code for Drinfeld modules as it is currently. Actually, I believe that it captures well the mathematical properties that we want for Drinfeld modules, and I actually do not understand what is the problem with its current structure. Then, following Xavier's suggestion, we could create another class for T-motives (whose elements are Ore polynomials (edit: more precisely, elements in a finitely-generated free module over a ring of Ore polynomials)), which could interact with the class of Drinfeld modules in the following way: once this class for T-motives is implemented, we could add a method to the Drinfeld module class which constructs the associated T-motive.

A long term objective might be to implement also the category of T-modules, and why not, a (sub)-category of shtukas (as I understand it, it adds a "sheaf of functions" layer to T-modules and this sheaf is constructed from the dual T-motive, in the same way that affine/projective schemes construct sheaves from a (graded) ring). However, this would probably require a large amount of work, which is probably out of the scope of this trac ticket.

The first step of this would be to integrate Antoine's code for Drinfeld modules in Sage; honestly, at this point I still cannot see the reason why the current code cannot be integrated (of course modulo correcting some small bugs that may be found during the review).



---

archive/issue_comments_672241.json:
```json
{
    "body": "**Changing commit** from \"[b1ce35539c8ed0b00fb0fe302b696538b9bd65a4](https://github.com/sagemath/sagetrac-mirror/commit/b1ce35539c8ed0b00fb0fe302b696538b9bd65a4)\" to \"[0cdd80f5c8b694e67151b97b9eeef36e5340e086](https://github.com/sagemath/sagetrac-mirror/commit/0cdd80f5c8b694e67151b97b9eeef36e5340e086)\".",
    "created_at": "2022-09-21T17:40:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672241",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[b1ce35539c8ed0b00fb0fe302b696538b9bd65a4](https://github.com/sagemath/sagetrac-mirror/commit/b1ce35539c8ed0b00fb0fe302b696538b9bd65a4)" to "[0cdd80f5c8b694e67151b97b9eeef36e5340e086](https://github.com/sagemath/sagetrac-mirror/commit/0cdd80f5c8b694e67151b97b9eeef36e5340e086)".



---

archive/issue_comments_672242.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0cdd80f5c8b694e67151b97b9eeef36e5340e086\">0cdd80f</a></td><td><code>(fix) Fix function_field/all.py</code></td></tr></table>\n",
    "created_at": "2022-09-21T17:40:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672242",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0cdd80f5c8b694e67151b97b9eeef36e5340e086">0cdd80f</a></td><td><code>(fix) Fix function_field/all.py</code></td></tr></table>




---

archive/issue_comments_672243.json:
```json
{
    "body": "<a id='comment:5'></a>\nReplying to [David Ayotte](#comment%3A238):\n\nMany thanks for the reminder.\n\n> You should add back the line\n> \n> ```\n> from .constructor import FunctionField\n> ```\n\n\nDone.\n\n> Also, you should not import directly from `.all`, but instead import the\n> desired class directly from the right module.\n\n\nWhy is that? This looks like a standard practice. See `src/sage/all.py` and\n`src/sage/rings/all.py`.",
    "created_at": "2022-09-21T17:41:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672243",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:5'></a>
Replying to [David Ayotte](#comment%3A238):

Many thanks for the reminder.

> You should add back the line
> 
> ```
> from .constructor import FunctionField
> ```


Done.

> Also, you should not import directly from `.all`, but instead import the
> desired class directly from the right module.


Why is that? This looks like a standard practice. See `src/sage/all.py` and
`src/sage/rings/all.py`.



---

archive/issue_comments_672244.json:
```json
{
    "body": "<a id='comment:6'></a>\nThank you all for the explanations. As a matter of fact I had began looking\ninto the T-motive viewpoint by reading\n[van der Heiden, Weil Pairing for Drinfeld Modules](https://link.springer.com/article/10.1007/s00605-004-0261-4), and it is true that the categories of\nT-motives and T-modules are anti-equivalent to one another [Theorem 2.9] (see\nalso [Proposition 2.11]). I am slightly uncomfortable with mixing the two\nrepresentations in this implementation\n\nReplying to [David Ayotte](#comment%3A238):\n> From a programming point of view, I think that having a Ore polynomials as\n> \"elements\" could be beneficial in the sense that you would not have to\n> override the double underscore __call__ method (which don't seems to be\n> advised to do: \u200bref, is this outdated?) and this would allow the\n> implementation of coercion and conversion as Xavier mentioned. \n\n\nOverriding the `__call__` method seems fine to me. There are multiple instances\nof this, and the code is quite lightweight:\n\n```python\n    def __call__(self, a):\n        return self._morphism(a)\n```\n\nFurther, could you please ellaborate on the benefits of\nhaving those conversion and coercion maps? I do not recall ever needing them.\n\nReplying to [David Ayotte](#comment%3A238):\n> In order words, mention to the user that even thought the class\n> `DrinfeldModule` uses Ore polynomials as an element class, it was implemented\n> purely for programming purposes and that it is important to know that,\n> mathematically, Drinfeld modules **does not** have elements.\n\n\nI believe the implementation and the documentation would step out their\nprerogatives. [SageMath](SageMath) is a high level computing toolbox for the working\nmathematician. Design and documentation should reflect the common mathematical\nmodeling of Drinfeld modules, in the most \"textbook\" fashion possible. I also\nbelieve that it is not ours to introduce new notions, such as elements of\nDrinfeld modules. I stand by the current implementation, which, in my opinion,\nbest modelizes Drinfeld modules.",
    "created_at": "2022-09-21T17:44:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672244",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:6'></a>
Thank you all for the explanations. As a matter of fact I had began looking
into the T-motive viewpoint by reading
[van der Heiden, Weil Pairing for Drinfeld Modules](https://link.springer.com/article/10.1007/s00605-004-0261-4), and it is true that the categories of
T-motives and T-modules are anti-equivalent to one another [Theorem 2.9] (see
also [Proposition 2.11]). I am slightly uncomfortable with mixing the two
representations in this implementation

Replying to [David Ayotte](#comment%3A238):
> From a programming point of view, I think that having a Ore polynomials as
> "elements" could be beneficial in the sense that you would not have to
> override the double underscore __call__ method (which don't seems to be
> advised to do: ​ref, is this outdated?) and this would allow the
> implementation of coercion and conversion as Xavier mentioned. 


Overriding the `__call__` method seems fine to me. There are multiple instances
of this, and the code is quite lightweight:

```python
    def __call__(self, a):
        return self._morphism(a)
```

Further, could you please ellaborate on the benefits of
having those conversion and coercion maps? I do not recall ever needing them.

Replying to [David Ayotte](#comment%3A238):
> In order words, mention to the user that even thought the class
> `DrinfeldModule` uses Ore polynomials as an element class, it was implemented
> purely for programming purposes and that it is important to know that,
> mathematically, Drinfeld modules **does not** have elements.


I believe the implementation and the documentation would step out their
prerogatives. [SageMath](SageMath) is a high level computing toolbox for the working
mathematician. Design and documentation should reflect the common mathematical
modeling of Drinfeld modules, in the most "textbook" fashion possible. I also
believe that it is not ours to introduce new notions, such as elements of
Drinfeld modules. I stand by the current implementation, which, in my opinion,
best modelizes Drinfeld modules.



---

archive/issue_comments_672245.json:
```json
{
    "body": "<a id='comment:247'></a>\nReplying to [Antoine Leudi\u00e8re](#comment%3A245):\n> > Also, you should not import directly from `.all`, but instead import the\n> > desired class directly from the right module.\n\n> \n> Why is that? This looks like a standard practice. See `src/sage/all.py` and\n> `src/sage/rings/all.py`.\n\n\nSee: [https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies](https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies)\n\nand: #34201",
    "created_at": "2022-09-21T18:58:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672245",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:247'></a>
Replying to [Antoine Leudière](#comment%3A245):
> > Also, you should not import directly from `.all`, but instead import the
> > desired class directly from the right module.

> 
> Why is that? This looks like a standard practice. See `src/sage/all.py` and
> `src/sage/rings/all.py`.


See: [https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies](https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies)

and: #34201



---

archive/issue_comments_672246.json:
```json
{
    "body": "<a id='comment:248'></a>\nReplying to [Antoine Leudi\u00e8re](#comment%3A246):\n> I believe the implementation and the documentation would step out their\n> prerogatives. [SageMath](SageMath) is a high level computing toolbox for the working\n> mathematician. Design and documentation should reflect the common mathematical\n> modeling of Drinfeld modules, in the most \"textbook\" fashion possible. I also\n> believe that it is not ours to introduce new notions, such as elements of\n> Drinfeld modules. I stand by the current implementation, which, in my opinion,\n> best modelizes Drinfeld modules.\n\n\nI'm trying to distinguish mathematics from programming here. To me, using a Sage element class for Drinfeld modules **does not means** that we are introducing a new mathematical notion, it means that we are making use of a programming framework (hence my comment about adding info on this in the documentation).\n\nAlthough, I think you are right about the usage of conversion and coercion, I could not find if it could add something. Personally, at this point I don't know what's wrong or right. Your current implementation indeed seems fine.\n\np.s. thank you for fixing that `FunctionField` import!! `:-)`",
    "created_at": "2022-09-21T19:44:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672246",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:248'></a>
Replying to [Antoine Leudière](#comment%3A246):
> I believe the implementation and the documentation would step out their
> prerogatives. [SageMath](SageMath) is a high level computing toolbox for the working
> mathematician. Design and documentation should reflect the common mathematical
> modeling of Drinfeld modules, in the most "textbook" fashion possible. I also
> believe that it is not ours to introduce new notions, such as elements of
> Drinfeld modules. I stand by the current implementation, which, in my opinion,
> best modelizes Drinfeld modules.


I'm trying to distinguish mathematics from programming here. To me, using a Sage element class for Drinfeld modules **does not means** that we are introducing a new mathematical notion, it means that we are making use of a programming framework (hence my comment about adding info on this in the documentation).

Although, I think you are right about the usage of conversion and coercion, I could not find if it could add something. Personally, at this point I don't know what's wrong or right. Your current implementation indeed seems fine.

p.s. thank you for fixing that `FunctionField` import!! `:-)`



---

archive/issue_comments_672247.json:
```json
{
    "body": "**Changing commit** from \"[0cdd80f5c8b694e67151b97b9eeef36e5340e086](https://github.com/sagemath/sagetrac-mirror/commit/0cdd80f5c8b694e67151b97b9eeef36e5340e086)\" to \"[8052550f00cd9ae9e8ba0e83a5c84022d462b361](https://github.com/sagemath/sagetrac-mirror/commit/8052550f00cd9ae9e8ba0e83a5c84022d462b361)\".",
    "created_at": "2022-09-22T12:48:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672247",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[0cdd80f5c8b694e67151b97b9eeef36e5340e086](https://github.com/sagemath/sagetrac-mirror/commit/0cdd80f5c8b694e67151b97b9eeef36e5340e086)" to "[8052550f00cd9ae9e8ba0e83a5c84022d462b361](https://github.com/sagemath/sagetrac-mirror/commit/8052550f00cd9ae9e8ba0e83a5c84022d462b361)".



---

archive/issue_comments_672248.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8052550f00cd9ae9e8ba0e83a5c84022d462b361\">8052550</a></td><td><code>Remove .all import</code></td></tr></table>\n",
    "created_at": "2022-09-22T12:48:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672248",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8052550f00cd9ae9e8ba0e83a5c84022d462b361">8052550</a></td><td><code>Remove .all import</code></td></tr></table>




---

archive/issue_comments_672249.json:
```json
{
    "body": "<a id='comment:250'></a>\nReplying to [David Ayotte](#comment%3A247):\n> Replying to [Antoine Leudi\u00e8re](#comment%3A245):\n> > > Also, you should not import directly from `.all`, but instead import the\n> > > desired class directly from the right module.\n\n> > \n> > Why is that? This looks like a standard practice. See `src/sage/all.py` and\n> > `src/sage/rings/all.py`.\n\n> \n> See: [https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies](https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies)\n> \n> and: #34201\n\n\nBetter?",
    "created_at": "2022-09-22T12:49:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672249",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:250'></a>
Replying to [David Ayotte](#comment%3A247):
> Replying to [Antoine Leudière](#comment%3A245):
> > > Also, you should not import directly from `.all`, but instead import the
> > > desired class directly from the right module.

> > 
> > Why is that? This looks like a standard practice. See `src/sage/all.py` and
> > `src/sage/rings/all.py`.

> 
> See: [https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies](https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies)
> 
> and: #34201


Better?



---

archive/issue_comments_672250.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a0285e14eb03ce40fe98fd0bfa166e4c395e10f9\">a0285e1</a></td><td><code>Merge branch 'develop' into public/drinfeld_module</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1e158033ab0ad13a6694dac9118e9d108d258e9e\">1e15803</a></td><td><code>(minor) Fix typo in docstring</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5fe2745a4edb559dab0fb6ba1dd72ac7a62a9806\">5fe2745</a></td><td><code>Fix lint error E265</code></td></tr></table>\n",
    "created_at": "2022-09-29T08:39:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672250",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a0285e14eb03ce40fe98fd0bfa166e4c395e10f9">a0285e1</a></td><td><code>Merge branch 'develop' into public/drinfeld_module</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1e158033ab0ad13a6694dac9118e9d108d258e9e">1e15803</a></td><td><code>(minor) Fix typo in docstring</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5fe2745a4edb559dab0fb6ba1dd72ac7a62a9806">5fe2745</a></td><td><code>Fix lint error E265</code></td></tr></table>




---

archive/issue_comments_672251.json:
```json
{
    "body": "**Changing commit** from \"[8052550f00cd9ae9e8ba0e83a5c84022d462b361](https://github.com/sagemath/sagetrac-mirror/commit/8052550f00cd9ae9e8ba0e83a5c84022d462b361)\" to \"[5fe2745a4edb559dab0fb6ba1dd72ac7a62a9806](https://github.com/sagemath/sagetrac-mirror/commit/5fe2745a4edb559dab0fb6ba1dd72ac7a62a9806)\".",
    "created_at": "2022-09-29T08:39:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672251",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[8052550f00cd9ae9e8ba0e83a5c84022d462b361](https://github.com/sagemath/sagetrac-mirror/commit/8052550f00cd9ae9e8ba0e83a5c84022d462b361)" to "[5fe2745a4edb559dab0fb6ba1dd72ac7a62a9806](https://github.com/sagemath/sagetrac-mirror/commit/5fe2745a4edb559dab0fb6ba1dd72ac7a62a9806)".



---

archive/issue_comments_672252.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,6 +1,63 @@\n-**EDIT (2022-09-09). *A lot has changed since this first comment; interface and implementation details are vastly different.***\n+**Edit (2022-09-27). A lot has changed since the original post. Here is a quick update.**\n+\n+## What is a Drinfeld module?\n+\n+Let `L` be a finite field extension of `\\Fq` and fix a ring morphism `\\gamma: \\Fq[X] \\to L`. Let `\\Ltau` be the ring of Ore polynomials with coefficients in `L` and whose generator is the Frobenius endomorphism `\\tau: x \\mapsto x^q`. A *Drinfeld module over the morphism `\\gamma`* `\\phi` is uniquely defined by an `\\Fq`-algebra morphism `\\Fq[X] \\to \\Ltau, P \\mapsto \\phi_P`, verifying `\\phi_X = \\gamma(X) + a_1\\tau + \\dots + a_r\\tau^r` and `r > 0`.\n+\n+A *morphism of Drinfeld modules `u: \\phi \\to \\psi`* is defined by an Ore polynomial `u \\in \\Ltau` verifying `u \\phi_X = \\psi_X u`.\n+\n+Drinfeld modules and their morphisms are the object and morphisms of the *category of Drinfeld modules defined over the morphism `\\gamma`*.\n+\n+A Drinfeld module induces an `\\Fq[X]`-module law on `L`, defined by `a \\star z = \\phi_a(z)`, where `a \\in \\Fq[X]` and `z \\in L`. This is referred to as the *Drinfeld module action induced by `\\phi`*.\n+\n+## Overview\n+\n+We created:\n+- `DrinfeldModule(Parent, UniqueRepresentation)`;\n+- `FiniteDrinfeldModule(DrinfeldModule)`;\n+- `DrinfeldModuleAction(Action)`;\n+- `DrinfeldModules(Category_over_base)`;\n+- `DrinfeldModuleHomset(Homset)`;\n+- `DrinfeldModuleMorphism(Morphism, UniqueRepresentation)`.\n+\n+Here is a short demo:\n+\n+```\n+sage: Fq = GF(2)\n+sage: FqX.<X> = Fq[]\n+sage: K.<i> = Fq.extension(2)\n+sage: phi = DrinfeldModule(FqX, [i, i, 1])\n+sage: phi\n+Drinfeld module defined by X |--> t^2 + i*t + i over base Ring morphism:\n+  From: Univariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)\n+  To:   Finite Field in i of size 2^2\n+  Defn: X |--> i\n+sage: phi(X)\n+t^2 + i*t + i\n+sage: psi = DrinfeldModule(FqX, [i, i+1, 1])\n+sage: t = phi.ore_polring().gen()\n+sage: i + t in Hom(phi, psi)\n+True\n+sage: phi.velu(i + t)\n+Drinfeld module defined by X |--> t^2 + (i + 1)*t + i over base Ring morphism:\n+  From: Univariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)\n+  To:   Finite Field in i of size 2^2\n+  Defn: X |--> i\n+```\n+\n+## Lint and build fails\n+\n+Lint errors are `E501`, which is due to Sage console outputs in `EXAMPLES::` or `TESTS::` fields. Likewise, documentation build errors are also due to Sage console outputs. Finally, it seems that the responsible for build errors is `sage/schemes/toric/sheaf/klyachko.py`.\n+\n+Any help with those issues is welcome!\n \n ---\n+\n+---\n+\n+---\n+\n+\n \n I would like to propose an implementation for *finite Drinfeld modules*. I\n opened this ticket to discuss this idea and have feedback on implementation\n``````\n",
    "created_at": "2022-09-29T08:45:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672252",
    "user": "https://github.com/antoine-leudiere"
}
```


**Description changed:**
``````diff
--- 
+++ 
@@ -1,6 +1,63 @@
-**EDIT (2022-09-09). *A lot has changed since this first comment; interface and implementation details are vastly different.***
+**Edit (2022-09-27). A lot has changed since the original post. Here is a quick update.**
+
+## What is a Drinfeld module?
+
+Let `L` be a finite field extension of `\Fq` and fix a ring morphism `\gamma: \Fq[X] \to L`. Let `\Ltau` be the ring of Ore polynomials with coefficients in `L` and whose generator is the Frobenius endomorphism `\tau: x \mapsto x^q`. A *Drinfeld module over the morphism `\gamma`* `\phi` is uniquely defined by an `\Fq`-algebra morphism `\Fq[X] \to \Ltau, P \mapsto \phi_P`, verifying `\phi_X = \gamma(X) + a_1\tau + \dots + a_r\tau^r` and `r > 0`.
+
+A *morphism of Drinfeld modules `u: \phi \to \psi`* is defined by an Ore polynomial `u \in \Ltau` verifying `u \phi_X = \psi_X u`.
+
+Drinfeld modules and their morphisms are the object and morphisms of the *category of Drinfeld modules defined over the morphism `\gamma`*.
+
+A Drinfeld module induces an `\Fq[X]`-module law on `L`, defined by `a \star z = \phi_a(z)`, where `a \in \Fq[X]` and `z \in L`. This is referred to as the *Drinfeld module action induced by `\phi`*.
+
+## Overview
+
+We created:
+- `DrinfeldModule(Parent, UniqueRepresentation)`;
+- `FiniteDrinfeldModule(DrinfeldModule)`;
+- `DrinfeldModuleAction(Action)`;
+- `DrinfeldModules(Category_over_base)`;
+- `DrinfeldModuleHomset(Homset)`;
+- `DrinfeldModuleMorphism(Morphism, UniqueRepresentation)`.
+
+Here is a short demo:
+
+```
+sage: Fq = GF(2)
+sage: FqX.<X> = Fq[]
+sage: K.<i> = Fq.extension(2)
+sage: phi = DrinfeldModule(FqX, [i, i, 1])
+sage: phi
+Drinfeld module defined by X |--> t^2 + i*t + i over base Ring morphism:
+  From: Univariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)
+  To:   Finite Field in i of size 2^2
+  Defn: X |--> i
+sage: phi(X)
+t^2 + i*t + i
+sage: psi = DrinfeldModule(FqX, [i, i+1, 1])
+sage: t = phi.ore_polring().gen()
+sage: i + t in Hom(phi, psi)
+True
+sage: phi.velu(i + t)
+Drinfeld module defined by X |--> t^2 + (i + 1)*t + i over base Ring morphism:
+  From: Univariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)
+  To:   Finite Field in i of size 2^2
+  Defn: X |--> i
+```
+
+## Lint and build fails
+
+Lint errors are `E501`, which is due to Sage console outputs in `EXAMPLES::` or `TESTS::` fields. Likewise, documentation build errors are also due to Sage console outputs. Finally, it seems that the responsible for build errors is `sage/schemes/toric/sheaf/klyachko.py`.
+
+Any help with those issues is welcome!
 
 ---
+
+---
+
+---
+
+
 
 I would like to propose an implementation for *finite Drinfeld modules*. I
 opened this ticket to discuss this idea and have feedback on implementation
``````




---

archive/issue_comments_672253.json:
```json
{
    "body": "<a id='comment:253'></a>\nReplying to [David Ayotte](#comment%3A247):\n> Replying to [Antoine Leudi\u00e8re](#comment%3A245):\n> > > Also, you should not import directly from `.all`, but instead import the\n> > > desired class directly from the right module.\n\n> > \n> > Why is that? This looks like a standard practice. See `src/sage/all.py` and\n> > `src/sage/rings/all.py`.\n\n> \n> See: [https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies](https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies)\n> \n> and: #34201\n\n\nAdditionally, this can introduce very subtle and hard to find/debug circular imports.",
    "created_at": "2022-09-29T09:07:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672253",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:253'></a>
Replying to [David Ayotte](#comment%3A247):
> Replying to [Antoine Leudière](#comment%3A245):
> > > Also, you should not import directly from `.all`, but instead import the
> > > desired class directly from the right module.

> > 
> > Why is that? This looks like a standard practice. See `src/sage/all.py` and
> > `src/sage/rings/all.py`.

> 
> See: [https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies](https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies)
> 
> and: #34201


Additionally, this can introduce very subtle and hard to find/debug circular imports.



---

archive/issue_comments_672254.json:
```json
{
    "body": "<a id='comment:254'></a>\nReplying to [David Ayotte](#comment%3A248):\n> Replying to [Antoine Leudi\u00e8re](#comment%3A246):\n> > I believe the implementation and the documentation would step out their\n> > prerogatives. [SageMath](SageMath) is a high level computing toolbox for the working\n> > mathematician. Design and documentation should reflect the common mathematical\n> > modeling of Drinfeld modules, in the most \"textbook\" fashion possible. I also\n> > believe that it is not ours to introduce new notions, such as elements of\n> > Drinfeld modules. I stand by the current implementation, which, in my opinion,\n> > best modelizes Drinfeld modules.\n\n> \n> I'm trying to distinguish mathematics from programming here. To me, using a Sage element class for Drinfeld modules **does not means** that we are introducing a new mathematical notion, it means that we are making use of a programming framework (hence my comment about adding info on this in the documentation).\n\n\n+1 to what David is saying. Design can diverge from what is in the textbooks (e.g., how did you learn to multiply polynomials?), and subsequently, you should not force things into certain programming frameworks because of the name (not every implementation of something you want to think of as a category should inherit from `Category`). For example, ask yourself what is a representation? Is it a function to some general linear group or a module with an action? In many ways, the latter is also a morphism, but a lot of what I do is really about doing linear algebra on a vector space. So that is more natural for me to just have a vector space plus action, not the morphism even though that is the mathematically correct definition.",
    "created_at": "2022-09-29T09:25:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672254",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:254'></a>
Replying to [David Ayotte](#comment%3A248):
> Replying to [Antoine Leudière](#comment%3A246):
> > I believe the implementation and the documentation would step out their
> > prerogatives. [SageMath](SageMath) is a high level computing toolbox for the working
> > mathematician. Design and documentation should reflect the common mathematical
> > modeling of Drinfeld modules, in the most "textbook" fashion possible. I also
> > believe that it is not ours to introduce new notions, such as elements of
> > Drinfeld modules. I stand by the current implementation, which, in my opinion,
> > best modelizes Drinfeld modules.

> 
> I'm trying to distinguish mathematics from programming here. To me, using a Sage element class for Drinfeld modules **does not means** that we are introducing a new mathematical notion, it means that we are making use of a programming framework (hence my comment about adding info on this in the documentation).


+1 to what David is saying. Design can diverge from what is in the textbooks (e.g., how did you learn to multiply polynomials?), and subsequently, you should not force things into certain programming frameworks because of the name (not every implementation of something you want to think of as a category should inherit from `Category`). For example, ask yourself what is a representation? Is it a function to some general linear group or a module with an action? In many ways, the latter is also a morphism, but a lot of what I do is really about doing linear algebra on a vector space. So that is more natural for me to just have a vector space plus action, not the morphism even though that is the mathematically correct definition.



---

archive/issue_comments_672255.json:
```json
{
    "body": "<a id='comment:255'></a>\n> +1 to what David is saying. Design can diverge from what is in the textbooks (e.g., how did you learn to multiply polynomials?), and subsequently, you should not force things into certain programming frameworks because of the name (not every implementation of something you want to think of as a category should inherit from `Category`). For example, ask yourself what is a representation? Is it a function to some general linear group or a module with an action? In many ways, the latter is also a morphism, but a lot of what I do is really about doing linear algebra on a vector space. So that is more natural for me to just have a vector space plus action, not the morphism even though that is the mathematically correct definition.\n\n\nI agree that many algorithms in computational mathematics ultimately reduce to linear algebra (or other fundamental computational building blocks such as the FFT). I think that at this point, the code both fits correctly the mathematical definition of Drinfeld modules, and it also fits well in the programming framework offered by the class `Category` in Sagemath. Also, I think that the code is quite user-friendly, especially for mathematicians working with Drinfeld modules and their isogenies. I suggest that we go back to the \"needs review\" status. Doing so might attract other people who might give their opinion, and this would also give some forward momentum to this ticket.",
    "created_at": "2022-09-30T19:31:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672255",
    "user": "https://github.com/spaenlehauer"
}
```


<a id='comment:255'></a>
> +1 to what David is saying. Design can diverge from what is in the textbooks (e.g., how did you learn to multiply polynomials?), and subsequently, you should not force things into certain programming frameworks because of the name (not every implementation of something you want to think of as a category should inherit from `Category`). For example, ask yourself what is a representation? Is it a function to some general linear group or a module with an action? In many ways, the latter is also a morphism, but a lot of what I do is really about doing linear algebra on a vector space. So that is more natural for me to just have a vector space plus action, not the morphism even though that is the mathematically correct definition.


I agree that many algorithms in computational mathematics ultimately reduce to linear algebra (or other fundamental computational building blocks such as the FFT). I think that at this point, the code both fits correctly the mathematical definition of Drinfeld modules, and it also fits well in the programming framework offered by the class `Category` in Sagemath. Also, I think that the code is quite user-friendly, especially for mathematicians working with Drinfeld modules and their isogenies. I suggest that we go back to the "needs review" status. Doing so might attract other people who might give their opinion, and this would also give some forward momentum to this ticket.



---

archive/issue_comments_672256.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2022-09-30T19:32:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672256",
    "user": "https://github.com/spaenlehauer"
}
```


**Changing status** from needs_work to needs_review.



---

archive/issue_comments_672257.json:
```json
{
    "body": "<a id='comment:7'></a>\n> Doing so might attract other people who might give their opinion, and this would also give some forward momentum to this ticket.\n\n\nUsually the need review status of a ticket is simply a way of saying \"ok, I think that this is ready and I'd like it to be peer reviewed\".\n\nI think that it is not quite ready for a positive review yet, for example I'd like to recall that I reviewed part of the code in my[comment:125](#comment%3A125) which has been lost in the discussion. I'll continue to review it later.\n\nEDIT: I meant[comment:123](#comment%3A123). The issue of[comment:125](#comment%3A125) is already fixed.",
    "created_at": "2022-09-30T21:40:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672257",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:7'></a>
> Doing so might attract other people who might give their opinion, and this would also give some forward momentum to this ticket.


Usually the need review status of a ticket is simply a way of saying "ok, I think that this is ready and I'd like it to be peer reviewed".

I think that it is not quite ready for a positive review yet, for example I'd like to recall that I reviewed part of the code in my[comment:125](#comment%3A125) which has been lost in the discussion. I'll continue to review it later.

EDIT: I meant[comment:123](#comment%3A123). The issue of[comment:125](#comment%3A125) is already fixed.



---

archive/issue_comments_672258.json:
```json
{
    "body": "<a id='comment:258'></a>\nReplying to [David Ayotte](#comment%3A257):\n> Usually the need review status of a ticket is simply a way of saying \"ok, I think that this is ready and I'd like it to be peer reviewed\".\n\n>\n> I think that it is not quite ready for a positive review yet, for example I'd like to recall that I reviewed part of the code in my[comment:125](#comment%3A125) which has been lost in the discussion. I'll continue to review it later.\n\n\nMany thanks David for reviewing the code! I agree that your[comment:123](#comment%3A123) and[comment:125](#comment%3A125) (EDIT: in fact only[comment:123](#comment%3A123), cf.[comment:257](#comment%3A257)) have been lost in the discussion, and they should be addressed.",
    "created_at": "2022-10-01T07:49:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672258",
    "user": "https://github.com/spaenlehauer"
}
```


<a id='comment:258'></a>
Replying to [David Ayotte](#comment%3A257):
> Usually the need review status of a ticket is simply a way of saying "ok, I think that this is ready and I'd like it to be peer reviewed".

>
> I think that it is not quite ready for a positive review yet, for example I'd like to recall that I reviewed part of the code in my[comment:125](#comment%3A125) which has been lost in the discussion. I'll continue to review it later.


Many thanks David for reviewing the code! I agree that your[comment:123](#comment%3A123) and[comment:125](#comment%3A125) (EDIT: in fact only[comment:123](#comment%3A123), cf.[comment:257](#comment%3A257)) have been lost in the discussion, and they should be addressed.



---

archive/issue_comments_672259.json:
```json
{
    "body": "<a id='comment:9'></a>\nAdditionally, 100% doctest coverage. I also highly recommend within your `__init__` you run `TestSuite(foo).run()`.",
    "created_at": "2022-10-01T13:58:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672259",
    "user": "https://github.com/tscrim"
}
```


<a id='comment:9'></a>
Additionally, 100% doctest coverage. I also highly recommend within your `__init__` you run `TestSuite(foo).run()`.



---

archive/issue_comments_672260.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2022-10-01T13:58:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672260",
    "user": "https://github.com/tscrim"
}
```


**Changing status** from needs_review to needs_work.



---

archive/issue_comments_672261.json:
```json
{
    "body": "**Changing commit** from \"[5fe2745a4edb559dab0fb6ba1dd72ac7a62a9806](https://github.com/sagemath/sagetrac-mirror/commit/5fe2745a4edb559dab0fb6ba1dd72ac7a62a9806)\" to \"[3e4d007c92971bc056e80497b2862ad2bfe5e7b8](https://github.com/sagemath/sagetrac-mirror/commit/3e4d007c92971bc056e80497b2862ad2bfe5e7b8)\".",
    "created_at": "2022-10-05T13:27:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672261",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[5fe2745a4edb559dab0fb6ba1dd72ac7a62a9806](https://github.com/sagemath/sagetrac-mirror/commit/5fe2745a4edb559dab0fb6ba1dd72ac7a62a9806)" to "[3e4d007c92971bc056e80497b2862ad2bfe5e7b8](https://github.com/sagemath/sagetrac-mirror/commit/3e4d007c92971bc056e80497b2862ad2bfe5e7b8)".



---

archive/issue_comments_672262.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** Last 10 new commits:\n|                                                                                                                                           |                                                                               |\n|-------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------|\n|[e042ae2](https://github.com/sagemath/sagetrac-mirror/commit/e042ae219c56574cef4ac7a9deb663fc8ba270b5)|`State that the code is for Drinfeld Fq[X]-modules in DrinfeldModule docstring`|\n|[89fa351](https://github.com/sagemath/sagetrac-mirror/commit/89fa35188ec3a89ac332ac7f7a27f8bb774c6f2b)|`(fix) Change a NotImplementedError to ValueError in DrinfeldModuleHomset`|\n|[e0846a3](https://github.com/sagemath/sagetrac-mirror/commit/e0846a39cfddc8abe13912c692d5a3b674c04132)|<code>(fix) In INPUT docstring fields, change `default` to `optional: ...`</code>|\n|[f71aff4](https://github.com/sagemath/sagetrac-mirror/commit/f71aff4637d5e3546bfe529c72d76d25c6ea88ec)|`(fix) Move base_ring from DrinfeldModules.ParentMethods to DrinfeldModule`|\n|[bf5a4a4](https://github.com/sagemath/sagetrac-mirror/commit/bf5a4a44e64ffb48a7d24fe487a7bd36dcf9b82d)|`(fix) Replace TESTS: by TESTS:: and EXAMPLES: by EXAMPLES::`|\n|[c821b20](https://github.com/sagemath/sagetrac-mirror/commit/c821b208b0840b3d83407e8b2332fe4ff63daee3)|<code>(fix) Fix various small issues in doc and `make doc` (see description)</code>|\n|[c269135](https://github.com/sagemath/sagetrac-mirror/commit/c2691352c3322851cccefc089119cb69d0a60534)|`(fix) Fix DrinfeldModule.base_ring docstring`|\n|[b59d836](https://github.com/sagemath/sagetrac-mirror/commit/b59d83624afeda23ed07c16115dd37f889b569b7)|`(fix) Fix DrinfeldModules.Endsets`|\n|[b763827](https://github.com/sagemath/sagetrac-mirror/commit/b7638276a45bbefb066b5da8ee3d58eb37303c9f)|`Split some code blocks using ::`|\n|[3e4d007](https://github.com/sagemath/sagetrac-mirror/commit/3e4d007c92971bc056e80497b2862ad2bfe5e7b8)|`Merge branch 'develop' into public/drinfeld_module`|",
    "created_at": "2022-10-05T13:27:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672262",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** Last 10 new commits:
|                                                                                                                                           |                                                                               |
|-------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
|[e042ae2](https://github.com/sagemath/sagetrac-mirror/commit/e042ae219c56574cef4ac7a9deb663fc8ba270b5)|`State that the code is for Drinfeld Fq[X]-modules in DrinfeldModule docstring`|
|[89fa351](https://github.com/sagemath/sagetrac-mirror/commit/89fa35188ec3a89ac332ac7f7a27f8bb774c6f2b)|`(fix) Change a NotImplementedError to ValueError in DrinfeldModuleHomset`|
|[e0846a3](https://github.com/sagemath/sagetrac-mirror/commit/e0846a39cfddc8abe13912c692d5a3b674c04132)|<code>(fix) In INPUT docstring fields, change `default` to `optional: ...`</code>|
|[f71aff4](https://github.com/sagemath/sagetrac-mirror/commit/f71aff4637d5e3546bfe529c72d76d25c6ea88ec)|`(fix) Move base_ring from DrinfeldModules.ParentMethods to DrinfeldModule`|
|[bf5a4a4](https://github.com/sagemath/sagetrac-mirror/commit/bf5a4a44e64ffb48a7d24fe487a7bd36dcf9b82d)|`(fix) Replace TESTS: by TESTS:: and EXAMPLES: by EXAMPLES::`|
|[c821b20](https://github.com/sagemath/sagetrac-mirror/commit/c821b208b0840b3d83407e8b2332fe4ff63daee3)|<code>(fix) Fix various small issues in doc and `make doc` (see description)</code>|
|[c269135](https://github.com/sagemath/sagetrac-mirror/commit/c2691352c3322851cccefc089119cb69d0a60534)|`(fix) Fix DrinfeldModule.base_ring docstring`|
|[b59d836](https://github.com/sagemath/sagetrac-mirror/commit/b59d83624afeda23ed07c16115dd37f889b569b7)|`(fix) Fix DrinfeldModules.Endsets`|
|[b763827](https://github.com/sagemath/sagetrac-mirror/commit/b7638276a45bbefb066b5da8ee3d58eb37303c9f)|`Split some code blocks using ::`|
|[3e4d007](https://github.com/sagemath/sagetrac-mirror/commit/3e4d007c92971bc056e80497b2862ad2bfe5e7b8)|`Merge branch 'develop' into public/drinfeld_module`|



---

archive/issue_comments_672263.json:
```json
{
    "body": "<a id='comment:1'></a>\nI apologize, David, for missing comment [comment:123]. I addressed every point.\nSome comments:\n- I removed the `if` statement. I think you were right in pointing out that it\n  was useless, as the Ore polynomial ring has unique representation.\n- The code was really made with finite Drinfeld modules in mind. However, I\n  agree that the documentation should emphasize that non finite Drinfeld\n  modules can be created. What I did is insisting on that as early and clearly\n  as possible in the `DrinfeldModule` docstring. Please tell me if you find\n  this sufficient, or if you want me to add examples in some methods (which\n  ones?) \u2014 I'm glad to do it.\n\nFurther, a warm and sincere thank you for reviewing the code.\n\nI also thank Travis for insisting on having full doctest coverage;\nachieving this made me fix some issues. All tests pass, and I believe I\nfixed `make doc` errors, as well as many small cosmetic problems in the\ndocumentation.\n\nIt comes as no surprise that `TestSuite(drinfeld_module).run()` fails. One of\nthe reasons is that those tests require the category `DrinfeldModules` of\nDrinfeld modules to be a subcategory of the category `Sets()` of sets. This is\nnot the case, as objects are not sets and morphisms are not maps. Another\nreason is that the tests require the parent class `DrinfeldModule` to have\nelements. Even though this generally is not a good practice, I suggest not to\nrun `TestSuite(drinfeld_module).run()`.",
    "created_at": "2022-10-05T13:28:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672263",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:1'></a>
I apologize, David, for missing comment [comment:123]. I addressed every point.
Some comments:
- I removed the `if` statement. I think you were right in pointing out that it
  was useless, as the Ore polynomial ring has unique representation.
- The code was really made with finite Drinfeld modules in mind. However, I
  agree that the documentation should emphasize that non finite Drinfeld
  modules can be created. What I did is insisting on that as early and clearly
  as possible in the `DrinfeldModule` docstring. Please tell me if you find
  this sufficient, or if you want me to add examples in some methods (which
  ones?) — I'm glad to do it.

Further, a warm and sincere thank you for reviewing the code.

I also thank Travis for insisting on having full doctest coverage;
achieving this made me fix some issues. All tests pass, and I believe I
fixed `make doc` errors, as well as many small cosmetic problems in the
documentation.

It comes as no surprise that `TestSuite(drinfeld_module).run()` fails. One of
the reasons is that those tests require the category `DrinfeldModules` of
Drinfeld modules to be a subcategory of the category `Sets()` of sets. This is
not the case, as objects are not sets and morphisms are not maps. Another
reason is that the tests require the parent class `DrinfeldModule` to have
elements. Even though this generally is not a good practice, I suggest not to
run `TestSuite(drinfeld_module).run()`.



---

archive/issue_comments_672264.json:
```json
{
    "body": "**Changing commit** from \"[3e4d007c92971bc056e80497b2862ad2bfe5e7b8](https://github.com/sagemath/sagetrac-mirror/commit/3e4d007c92971bc056e80497b2862ad2bfe5e7b8)\" to \"[7d8e358cde69671bee9978ea4793fc32cfae7965](https://github.com/sagemath/sagetrac-mirror/commit/7d8e358cde69671bee9978ea4793fc32cfae7965)\".",
    "created_at": "2022-10-05T15:26:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672264",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[3e4d007c92971bc056e80497b2862ad2bfe5e7b8](https://github.com/sagemath/sagetrac-mirror/commit/3e4d007c92971bc056e80497b2862ad2bfe5e7b8)" to "[7d8e358cde69671bee9978ea4793fc32cfae7965](https://github.com/sagemath/sagetrac-mirror/commit/7d8e358cde69671bee9978ea4793fc32cfae7965)".



---

archive/issue_comments_672265.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7d8e358cde69671bee9978ea4793fc32cfae7965\">7d8e358</a></td><td><code>(fix) Fix lint check Github job</code></td></tr></table>\n",
    "created_at": "2022-10-05T15:26:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672265",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7d8e358cde69671bee9978ea4793fc32cfae7965">7d8e358</a></td><td><code>(fix) Fix lint check Github job</code></td></tr></table>




---

archive/issue_comments_672266.json:
```json
{
    "body": "<a id='comment:263'></a>\nReplying to [Antoine Leudi\u00e8re](#comment%3A261):\n> It comes as no surprise that `TestSuite(drinfeld_module).run()` fails.\n\n\nYou can skip specific tests by passing `skip=['...', '...']` to `run`",
    "created_at": "2022-10-05T19:25:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672266",
    "user": "https://github.com/mkoeppe"
}
```


<a id='comment:263'></a>
Replying to [Antoine Leudière](#comment%3A261):
> It comes as no surprise that `TestSuite(drinfeld_module).run()` fails.


You can skip specific tests by passing `skip=['...', '...']` to `run`



---

archive/issue_comments_672267.json:
```json
{
    "body": "<a id='comment:4'></a>\n>The code was really made with finite Drinfeld modules in mind. However, I agree that the documentation should emphasize that non finite Drinfeld modules can be created. What I did is insisting on that as early and clearly as possible in the `DrinfeldModule` docstring. Please tell me if you find this sufficient, or if you want me to add examples in some methods (which ones?) \u2014 I'm glad to do it.\n\n\nI understand! most of the Drinfeld modules I work with are of generic characteristic, hence my comment. What you did looks good!\n\nSome comments: \n\n* Small typo in the documentation of `DrinfeldModules`:\n\n```diff\n     We say that `\\mathbb{F}_q[X]` is the function ring of the category;\n+    `K\\{\\tau\\}` is the polynomial ring of the category.\n-    `K\\{\\tau\\}` is the re polynomial ring of the category.\n```\n\n* At various places you write \"non XYZ\" or \"non-XYZ\" (ex.: \"non zero\", \"non-zero\" and \"non-constant\"), but I think that correct wording is \"nonXYZ\", for example: \"nonzero\" (no space and no hyphen).\n\n* About this comment:\n\n```\n        # FIXME\n        # The parent method `base_ring` is defined not here, as it\n        # should be, but in `DrinfeldModule`.\n        #\n        # This is because calling `phi.base_ring()` calls the\n        # `base_ring` method of `CategoryObject` and not the one defined\n        # here.\n        #\n        # This works, but any better solution would be welcome.\n```\n    Here, you are not using `CategoryObject` anymore, so I think that you can remove this comment. Also, you have an other mention of `CategoryObject` in the `base_ring` method of `DrinfeldModule`:\n\n```\n    def base_ring(self):\n        r\"\"\"\n        Raise exception ``AttributeError``.\n\n        The base of a Drinfeld module is a ring morphism, not a ring.\n\n        This method is implemented in ``CategoryObject``, of which Parent\n        inherits. It returns the base of the category. I overloaded it\n        to avoid confusion.\n```\n    In fact, I think you don't need this method anymore, since you now use `Category_over_base`.\n\n* On the same topic of base ring, I think that this is a bug:\n\n```\nsage: A = GF(5)['T']; K = Frac(A)\nsage: phi = DrinfeldModule(A, [K(2), K.one()]); phi\nDrinfeld module defined by T |--> t + 2 over base Ring morphism:\n  From: Univariate Polynomial Ring in T over Finite Field of size 5\n  To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5\n  Defn: T |--> 2\nsage: phi.is_finite()\nFalse\n```\n    Also, this should not be possible:\n\n```\nsage: A = GF(5)['T']; K = Frac(A)\nsage: DrinfeldModule(A, [K(2), K.gen()])\nDrinfeld module defined by T |--> T*t + 2 over base Ring morphism:\n  From: Univariate Polynomial Ring in T over Finite Field of size 5\n  To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5\n  Defn: T |--> 2\n```\n    Indeed, the coefficients of a Drinfeld module should be elements of the image of the base (and `T` is not in the image in the example above). One fix for this would be to try to convert the constant coefficient of the Drinfeld module into an element of a finite field. For example, this works:\n\n```\nsage: phi.function_ring().base_ring()(phi.constant_coefficient())\n2\n```\n    even though `phi.constant_coefficient()` is an element of `Frac(A)`. However, there might be a better way of doing this.",
    "created_at": "2022-10-06T04:13:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672267",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:4'></a>
>The code was really made with finite Drinfeld modules in mind. However, I agree that the documentation should emphasize that non finite Drinfeld modules can be created. What I did is insisting on that as early and clearly as possible in the `DrinfeldModule` docstring. Please tell me if you find this sufficient, or if you want me to add examples in some methods (which ones?) — I'm glad to do it.


I understand! most of the Drinfeld modules I work with are of generic characteristic, hence my comment. What you did looks good!

Some comments: 

* Small typo in the documentation of `DrinfeldModules`:

```diff
     We say that `\mathbb{F}_q[X]` is the function ring of the category;
+    `K\{\tau\}` is the polynomial ring of the category.
-    `K\{\tau\}` is the re polynomial ring of the category.
```

* At various places you write "non XYZ" or "non-XYZ" (ex.: "non zero", "non-zero" and "non-constant"), but I think that correct wording is "nonXYZ", for example: "nonzero" (no space and no hyphen).

* About this comment:

```
        # FIXME
        # The parent method `base_ring` is defined not here, as it
        # should be, but in `DrinfeldModule`.
        #
        # This is because calling `phi.base_ring()` calls the
        # `base_ring` method of `CategoryObject` and not the one defined
        # here.
        #
        # This works, but any better solution would be welcome.
```
    Here, you are not using `CategoryObject` anymore, so I think that you can remove this comment. Also, you have an other mention of `CategoryObject` in the `base_ring` method of `DrinfeldModule`:

```
    def base_ring(self):
        r"""
        Raise exception ``AttributeError``.

        The base of a Drinfeld module is a ring morphism, not a ring.

        This method is implemented in ``CategoryObject``, of which Parent
        inherits. It returns the base of the category. I overloaded it
        to avoid confusion.
```
    In fact, I think you don't need this method anymore, since you now use `Category_over_base`.

* On the same topic of base ring, I think that this is a bug:

```
sage: A = GF(5)['T']; K = Frac(A)
sage: phi = DrinfeldModule(A, [K(2), K.one()]); phi
Drinfeld module defined by T |--> t + 2 over base Ring morphism:
  From: Univariate Polynomial Ring in T over Finite Field of size 5
  To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5
  Defn: T |--> 2
sage: phi.is_finite()
False
```
    Also, this should not be possible:

```
sage: A = GF(5)['T']; K = Frac(A)
sage: DrinfeldModule(A, [K(2), K.gen()])
Drinfeld module defined by T |--> T*t + 2 over base Ring morphism:
  From: Univariate Polynomial Ring in T over Finite Field of size 5
  To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5
  Defn: T |--> 2
```
    Indeed, the coefficients of a Drinfeld module should be elements of the image of the base (and `T` is not in the image in the example above). One fix for this would be to try to convert the constant coefficient of the Drinfeld module into an element of a finite field. For example, this works:

```
sage: phi.function_ring().base_ring()(phi.constant_coefficient())
2
```
    even though `phi.constant_coefficient()` is an element of `Frac(A)`. However, there might be a better way of doing this.



---

archive/issue_comments_672268.json:
```json
{
    "body": "<a id='comment:5'></a>\nHi, after a good night of sleep, I was thinking about the last example I brought up in my last comment and I think that I was a bit confused. In fact, it should be possible to consider such Drinfeld module even if the characteristic of the chosen `A`-field is finite. The conditions to be a Drinfeld module are imposed only on the constant coefficient. Sorry for this confusion!\n\nAlso, if a Drinfeld module defined over `Fq(X)` have its coefficients in `Fq`, should we call it finite?",
    "created_at": "2022-10-06T12:49:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672268",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:5'></a>
Hi, after a good night of sleep, I was thinking about the last example I brought up in my last comment and I think that I was a bit confused. In fact, it should be possible to consider such Drinfeld module even if the characteristic of the chosen `A`-field is finite. The conditions to be a Drinfeld module are imposed only on the constant coefficient. Sorry for this confusion!

Also, if a Drinfeld module defined over `Fq(X)` have its coefficients in `Fq`, should we call it finite?



---

archive/issue_comments_672269.json:
```json
{
    "body": "**Changing commit** from \"[7d8e358cde69671bee9978ea4793fc32cfae7965](https://github.com/sagemath/sagetrac-mirror/commit/7d8e358cde69671bee9978ea4793fc32cfae7965)\" to \"[78c99e05e5b12568dcb2def70da21cfc0d8fa870](https://github.com/sagemath/sagetrac-mirror/commit/78c99e05e5b12568dcb2def70da21cfc0d8fa870)\".",
    "created_at": "2022-10-11T17:01:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672269",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[7d8e358cde69671bee9978ea4793fc32cfae7965](https://github.com/sagemath/sagetrac-mirror/commit/7d8e358cde69671bee9978ea4793fc32cfae7965)" to "[78c99e05e5b12568dcb2def70da21cfc0d8fa870](https://github.com/sagemath/sagetrac-mirror/commit/78c99e05e5b12568dcb2def70da21cfc0d8fa870)".



---

archive/issue_comments_672270.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/26fe42659d8bed43835721f8a9d40303f4dca6da\">26fe426</a></td><td><code>(fix) Adress typos from comment 264</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bee20a07453c5b18ac51a36835e6d20c1e33a1c6\">bee20a0</a></td><td><code>Add details on the base definition in DrinfeldModule doc</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/78c99e05e5b12568dcb2def70da21cfc0d8fa870\">78c99e0</a></td><td><code>Enhance \"base ring comment\"</code></td></tr></table>\n",
    "created_at": "2022-10-11T17:01:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672270",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/26fe42659d8bed43835721f8a9d40303f4dca6da">26fe426</a></td><td><code>(fix) Adress typos from comment 264</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bee20a07453c5b18ac51a36835e6d20c1e33a1c6">bee20a0</a></td><td><code>Add details on the base definition in DrinfeldModule doc</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/78c99e05e5b12568dcb2def70da21cfc0d8fa870">78c99e0</a></td><td><code>Enhance "base ring comment"</code></td></tr></table>




---

archive/issue_comments_672271.json:
```json
{
    "body": "<a id='comment:267'></a>\nReplying to [Matthias K\u00f6ppe](#comment%3A263):\n> Replying to [Antoine Leudi\u00e8re](#comment%3A261):\n> > It comes as no surprise that `TestSuite(drinfeld_module).run()` fails.\n\n> \n> You can skip specific tests by passing `skip=['...', '...']` to `run`\n\n\nThanks for the tip; this looks like the way to go.\n\nReplying to [David Ayotte](#comment%3A264):\n> \n> * About this comment:\n> \n> ```\n>         # FIXME\n>         # The parent method `base_ring` is defined not here, as it\n>         # should be, but in `DrinfeldModule`.\n>         #\n>         # This is because calling `phi.base_ring()` calls the\n>         # `base_ring` method of `CategoryObject` and not the one defined\n>         # here.\n>         #\n>         # This works, but any better solution would be welcome.\n> ```\n>     Here, you are not using `CategoryObject` anymore, so I think that you can remove this comment. Also, you have an other mention of `CategoryObject` in the `base_ring` method of `DrinfeldModule`:\n> \n> ```\n>     def base_ring(self):\n>         r\"\"\"\n>         Raise exception ``AttributeError``.\n> \n>         The base of a Drinfeld module is a ring morphism, not a ring.\n> \n>         This method is implemented in ``CategoryObject``, of which Parent\n>         inherits. It returns the base of the category. I overloaded it\n>         to avoid confusion.\n> ```\n>     In fact, I think you don't need this method anymore, since you now use `Category_over_base`.\n\n\nApologies for not making things clearer.\n\nThe problem is the following. In this implementation, the base of a Drinfeld\nmodule category is a *morphism* `\\gamma: A \\to K` rather than just the field\n`K`. Therefore, the method `base_ring` is misleading (to me at least), and I\ndon't want it implemented (this is debatable, as a `change_ring` method would\nbe nice).\n\nHowever, the class `DrinfeldModule` inherits `Parent`, which inherits\n`CategoryObject`. The class `CategoryObject` implements the method `base_ring`,\nonly to return `self._base` (see\n`$SAGE_ROOT/src/sage/structure/category_object.pyx`, line 610). Consequently,\nit is always possible to call `phi.base_ring()`. My goal is then to have this\nmethod raise an exception when called, to emphasize that here, Drinfeld modules\ndo not have base rings. The first thing I tried was to implement `base_ring` in\nthe `class ParentMethods:` part of `DrinfeldModules`. However, this does not\nwork, and the solution I found was to define the method in `DrinfeldModule`.\n\nThe definition of `base_ring` should in the *parent methods* of\n`DrinfeldModules`, as it is a method that depends on the sole category.\n\nI tried to make the comment clearer, hope that's better.\n\n \nReplying to [David Ayotte](#comment%3A264):\n> * On the same topic of base ring, I think that this is a bug:\n> \n> ```\n> sage: A = GF(5)['T']; K = Frac(A)\n> sage: phi = DrinfeldModule(A, [K(2), K.one()]); phi\n> Drinfeld module defined by T |--> t + 2 over base Ring morphism:\n>   From: Univariate Polynomial Ring in T over Finite Field of size 5\n>   To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5\n>   Defn: T |--> 2\n> sage: phi.is_finite()\n> False\n> ```\n>     Also, this should not be possible:\n> \n> ```\n> sage: A = GF(5)['T']; K = Frac(A)\n> sage: DrinfeldModule(A, [K(2), K.gen()])\n> Drinfeld module defined by T |--> T*t + 2 over base Ring morphism:\n>   From: Univariate Polynomial Ring in T over Finite Field of size 5\n>   To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5\n>   Defn: T |--> 2\n> ```\n>     Indeed, the coefficients of a Drinfeld module should be elements of the image of the base (and `T` is not in the image in the example above). One fix for this would be to try to convert the constant coefficient of the Drinfeld module into an element of a finite field. For example, this works:\n> \n> ```\n> sage: phi.function_ring().base_ring()(phi.constant_coefficient())\n> 2\n> ```\n>     even though `phi.constant_coefficient()` is an element of `Frac(A)`. However, there might be a better way of doing this.\n\n\nReplying to [David Ayotte](#comment%3A265):\n> Hi, after a good night of sleep, I was thinking about the last example I brought up in my last comment and I think that I was a bit confused. In fact, it should be possible to consider such Drinfeld module even if the characteristic of the chosen `A`-field is finite. The conditions to be a Drinfeld module are imposed only on the constant coefficient. Sorry for this confusion!\n> \n> Also, if a Drinfeld module defined over `Fq(X)` have its coefficients in `Fq`, should we call it finite? \n\n\nI think you are raising a crucial question. It shows that there is ambiguity in\nthe documentation that must be addressed.\n\nIn my view, the ideal solution would be to instantiate a Drinfeld module `phi`\nby giving a **morphism** `A \\to K\\{\\tau\\}` as the input. We can deduce the\nbase ring morphism from here as the morphism `\\Fq[X] \\to K` defined by\n`D \\circ \\phi`, where `D` is the \"constant-coefficient function\".\n\nAs we saw in the early days of this ticket, this requires numerous lines of\ncode, and we chose a lighter solution: `DrinfeldModule` is defined with the\nsole generator; the base morphism is implicitly defined as the ring morphism\n`A \\to K` that maps `a` to the constant coefficient of `\\phi_a`, and where `K`\nis the compositum of all the parents of the coefficients.\n\nThis means that a Drinfeld module whose coefficients lie in a finite field\n(e.g. `\\Fq`) but whose parent is a function field (e.g. `\\Fq(X)`) would not be\nconsidered finite.\n\nI amended the documentation to make it clearer. What do you think?",
    "created_at": "2022-10-11T17:08:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672271",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:267'></a>
Replying to [Matthias Köppe](#comment%3A263):
> Replying to [Antoine Leudière](#comment%3A261):
> > It comes as no surprise that `TestSuite(drinfeld_module).run()` fails.

> 
> You can skip specific tests by passing `skip=['...', '...']` to `run`


Thanks for the tip; this looks like the way to go.

Replying to [David Ayotte](#comment%3A264):
> 
> * About this comment:
> 
> ```
>         # FIXME
>         # The parent method `base_ring` is defined not here, as it
>         # should be, but in `DrinfeldModule`.
>         #
>         # This is because calling `phi.base_ring()` calls the
>         # `base_ring` method of `CategoryObject` and not the one defined
>         # here.
>         #
>         # This works, but any better solution would be welcome.
> ```
>     Here, you are not using `CategoryObject` anymore, so I think that you can remove this comment. Also, you have an other mention of `CategoryObject` in the `base_ring` method of `DrinfeldModule`:
> 
> ```
>     def base_ring(self):
>         r"""
>         Raise exception ``AttributeError``.
> 
>         The base of a Drinfeld module is a ring morphism, not a ring.
> 
>         This method is implemented in ``CategoryObject``, of which Parent
>         inherits. It returns the base of the category. I overloaded it
>         to avoid confusion.
> ```
>     In fact, I think you don't need this method anymore, since you now use `Category_over_base`.


Apologies for not making things clearer.

The problem is the following. In this implementation, the base of a Drinfeld
module category is a *morphism* `\gamma: A \to K` rather than just the field
`K`. Therefore, the method `base_ring` is misleading (to me at least), and I
don't want it implemented (this is debatable, as a `change_ring` method would
be nice).

However, the class `DrinfeldModule` inherits `Parent`, which inherits
`CategoryObject`. The class `CategoryObject` implements the method `base_ring`,
only to return `self._base` (see
`$SAGE_ROOT/src/sage/structure/category_object.pyx`, line 610). Consequently,
it is always possible to call `phi.base_ring()`. My goal is then to have this
method raise an exception when called, to emphasize that here, Drinfeld modules
do not have base rings. The first thing I tried was to implement `base_ring` in
the `class ParentMethods:` part of `DrinfeldModules`. However, this does not
work, and the solution I found was to define the method in `DrinfeldModule`.

The definition of `base_ring` should in the *parent methods* of
`DrinfeldModules`, as it is a method that depends on the sole category.

I tried to make the comment clearer, hope that's better.

 
Replying to [David Ayotte](#comment%3A264):
> * On the same topic of base ring, I think that this is a bug:
> 
> ```
> sage: A = GF(5)['T']; K = Frac(A)
> sage: phi = DrinfeldModule(A, [K(2), K.one()]); phi
> Drinfeld module defined by T |--> t + 2 over base Ring morphism:
>   From: Univariate Polynomial Ring in T over Finite Field of size 5
>   To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5
>   Defn: T |--> 2
> sage: phi.is_finite()
> False
> ```
>     Also, this should not be possible:
> 
> ```
> sage: A = GF(5)['T']; K = Frac(A)
> sage: DrinfeldModule(A, [K(2), K.gen()])
> Drinfeld module defined by T |--> T*t + 2 over base Ring morphism:
>   From: Univariate Polynomial Ring in T over Finite Field of size 5
>   To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5
>   Defn: T |--> 2
> ```
>     Indeed, the coefficients of a Drinfeld module should be elements of the image of the base (and `T` is not in the image in the example above). One fix for this would be to try to convert the constant coefficient of the Drinfeld module into an element of a finite field. For example, this works:
> 
> ```
> sage: phi.function_ring().base_ring()(phi.constant_coefficient())
> 2
> ```
>     even though `phi.constant_coefficient()` is an element of `Frac(A)`. However, there might be a better way of doing this.


Replying to [David Ayotte](#comment%3A265):
> Hi, after a good night of sleep, I was thinking about the last example I brought up in my last comment and I think that I was a bit confused. In fact, it should be possible to consider such Drinfeld module even if the characteristic of the chosen `A`-field is finite. The conditions to be a Drinfeld module are imposed only on the constant coefficient. Sorry for this confusion!
> 
> Also, if a Drinfeld module defined over `Fq(X)` have its coefficients in `Fq`, should we call it finite? 


I think you are raising a crucial question. It shows that there is ambiguity in
the documentation that must be addressed.

In my view, the ideal solution would be to instantiate a Drinfeld module `phi`
by giving a **morphism** `A \to K\{\tau\}` as the input. We can deduce the
base ring morphism from here as the morphism `\Fq[X] \to K` defined by
`D \circ \phi`, where `D` is the "constant-coefficient function".

As we saw in the early days of this ticket, this requires numerous lines of
code, and we chose a lighter solution: `DrinfeldModule` is defined with the
sole generator; the base morphism is implicitly defined as the ring morphism
`A \to K` that maps `a` to the constant coefficient of `\phi_a`, and where `K`
is the compositum of all the parents of the coefficients.

This means that a Drinfeld module whose coefficients lie in a finite field
(e.g. `\Fq`) but whose parent is a function field (e.g. `\Fq(X)`) would not be
considered finite.

I amended the documentation to make it clearer. What do you think?



---

archive/issue_comments_672272.json:
```json
{
    "body": "<a id='comment:268'></a>\nReplying to [Antoine Leudi\u00e8re](#comment%3A267):\n> The problem is the following. In this implementation, the base of a Drinfeld module category is a morphism `\\gamma: A \\to K` rather than just the field `K`. Therefore, the method `base_ring` is misleading (to me at least), and I don't want it implemented (this is debatable, as a `change_ring` method would be nice).\n\n\nMay I ask what are the advantages of considering a `A`-field (`A = Fq[X]`) as a morphism? Mathematically, a `A`-field is just a field `F` which is a `A`-algebra `F` via a morphism `Fq[X] ---> F`. Thus, I think that there are two valid points of view for a `A`-field (as a field or as a morphism) in a similar way that there are two valid points of view for a representation (as a module or a group morphism). So, to rephrase my question, what made you choose to consider the morphism point of view?\n\n> In my view, the ideal solution would be to instantiate a Drinfeld module `phi`\n> by giving a **morphism** `A \\to K\\{\\tau\\}` as the input. We can deduce the\n> base ring morphism from here as the morphism `\\Fq[X] \\to K` defined by\n> `D \\circ \\phi`, where `D` is the \"constant-coefficient function\".\n> \n> As we saw in the early days of this ticket, this requires numerous lines of\n> code, and we chose a lighter solution: `DrinfeldModule` is defined with the\n> sole generator; the base morphism is implicitly defined as the ring morphism\n> `A \\to K` that maps `a` to the constant coefficient of `\\phi_a`, and where `K`\n> is the compositum of all the parents of the coefficients.\n> \n> This means that a Drinfeld module whose coefficients lie in a finite field\n> (e.g. `\\Fq`) but whose parent is a function field (e.g. `\\Fq(X)`) would not be\n> considered finite.\n\n\nUnless that I'm confused again, I think that by giving a morphism `A --> K{\\tau}` as the input, the same problem could be possible to recreate: we could consider a morphism `A --> \\Fq(X){\\tau}` sending `X` to a `\\tau`-polynomial with coefficient in `\\Fq` which are coerced in `\\Fq(X)`.\n\nDo you think that the Drinfeld module constructor could parse the coefficients a little bit further by checking if they can be converted into an element of a finite field? For example:\n\n```\nsage: A.<X> = GF(5)[]\nsage: K.<X> = Frac(A)\nsage: a = K(2)\nsage: a.parent()\nFraction Field of Univariate Polynomial Ring in X over Finite Field of size 5\nsage: b = K.base_ring()(a); b\n2\nsage: b.parent()\nFinite Field of size 5\nsage: K.base_ring()(X)\nTraceback (most recent call last):\n...\nValueError: not constant\n```",
    "created_at": "2022-10-11T19:14:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672272",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:268'></a>
Replying to [Antoine Leudière](#comment%3A267):
> The problem is the following. In this implementation, the base of a Drinfeld module category is a morphism `\gamma: A \to K` rather than just the field `K`. Therefore, the method `base_ring` is misleading (to me at least), and I don't want it implemented (this is debatable, as a `change_ring` method would be nice).


May I ask what are the advantages of considering a `A`-field (`A = Fq[X]`) as a morphism? Mathematically, a `A`-field is just a field `F` which is a `A`-algebra `F` via a morphism `Fq[X] ---> F`. Thus, I think that there are two valid points of view for a `A`-field (as a field or as a morphism) in a similar way that there are two valid points of view for a representation (as a module or a group morphism). So, to rephrase my question, what made you choose to consider the morphism point of view?

> In my view, the ideal solution would be to instantiate a Drinfeld module `phi`
> by giving a **morphism** `A \to K\{\tau\}` as the input. We can deduce the
> base ring morphism from here as the morphism `\Fq[X] \to K` defined by
> `D \circ \phi`, where `D` is the "constant-coefficient function".
> 
> As we saw in the early days of this ticket, this requires numerous lines of
> code, and we chose a lighter solution: `DrinfeldModule` is defined with the
> sole generator; the base morphism is implicitly defined as the ring morphism
> `A \to K` that maps `a` to the constant coefficient of `\phi_a`, and where `K`
> is the compositum of all the parents of the coefficients.
> 
> This means that a Drinfeld module whose coefficients lie in a finite field
> (e.g. `\Fq`) but whose parent is a function field (e.g. `\Fq(X)`) would not be
> considered finite.


Unless that I'm confused again, I think that by giving a morphism `A --> K{\tau}` as the input, the same problem could be possible to recreate: we could consider a morphism `A --> \Fq(X){\tau}` sending `X` to a `\tau`-polynomial with coefficient in `\Fq` which are coerced in `\Fq(X)`.

Do you think that the Drinfeld module constructor could parse the coefficients a little bit further by checking if they can be converted into an element of a finite field? For example:

```
sage: A.<X> = GF(5)[]
sage: K.<X> = Frac(A)
sage: a = K(2)
sage: a.parent()
Fraction Field of Univariate Polynomial Ring in X over Finite Field of size 5
sage: b = K.base_ring()(a); b
2
sage: b.parent()
Finite Field of size 5
sage: K.base_ring()(X)
Traceback (most recent call last):
...
ValueError: not constant
```



---

archive/issue_comments_672273.json:
```json
{
    "body": "<a id='comment:269'></a>\nReplying to [David Ayotte](#comment%3A268):\n> May I ask what are the advantages of considering a `A`-field (`A = Fq[X]`) as a morphism? Mathematically, a `A`-field is just a field `F` which is a `A`-algebra `F` via a morphism `Fq[X] ---> F`. Thus, I think that there are two valid points of view for a `A`-field (as a field or as a morphism) in a similar way that there are two valid points of view for a representation (as a module or a group morphism). So, to rephrase my question, what made you choose to consider the morphism point of view?\n\n\nI propose to return `F.over(phi.category().base())` which exactly returns what you wants, i.e. `A` considered as an algebra over `Fq[X]` through defining morphism.\n\nOr, maybe even better, let `phi.category().base()` return also the ring extension.",
    "created_at": "2022-10-13T09:03:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672273",
    "user": "https://github.com/xcaruso"
}
```


<a id='comment:269'></a>
Replying to [David Ayotte](#comment%3A268):
> May I ask what are the advantages of considering a `A`-field (`A = Fq[X]`) as a morphism? Mathematically, a `A`-field is just a field `F` which is a `A`-algebra `F` via a morphism `Fq[X] ---> F`. Thus, I think that there are two valid points of view for a `A`-field (as a field or as a morphism) in a similar way that there are two valid points of view for a representation (as a module or a group morphism). So, to rephrase my question, what made you choose to consider the morphism point of view?


I propose to return `F.over(phi.category().base())` which exactly returns what you wants, i.e. `A` considered as an algebra over `Fq[X]` through defining morphism.

Or, maybe even better, let `phi.category().base()` return also the ring extension.



---

archive/issue_comments_672274.json:
```json
{
    "body": "<a id='comment:270'></a>\nReplying to [David Ayotte](#comment%3A268):\n> Replying to [Antoine Leudi\u00e8re](#comment%3A267):\n> > The problem is the following. In this implementation, the base of a Drinfeld module category is a morphism `\\gamma: A \\to K` rather than just the field `K`. Therefore, the method `base_ring` is misleading (to me at least), and I don't want it implemented (this is debatable, as a `change_ring` method would be nice).\n\n> \n> May I ask what are the advantages of considering a `A`-field (`A = Fq[X]`) as a morphism? Mathematically, a `A`-field is just a field `F` which is a `A`-algebra `F` via a morphism `Fq[X] ---> F`. Thus, I think that there are two valid points of view for a `A`-field (as a field or as a morphism) in a similar way that there are two valid points of view for a representation (as a module or a group morphism). So, to rephrase my question, what made you choose to consider the morphism point of view?\n> \n\n\nI think both points of view are very good, and I did not know about\n`K.over(gamma)`, which is why I went for the morphism! Thanks Xavier for the\ntip. Despite the morphism point of view working and being quite natural, I am\nhappy to change for the `A`-field point of view! I will refactor the code.\n\n\n> > In my view, the ideal solution would be to instantiate a Drinfeld module `phi`\n> > by giving a **morphism** `A \\to K\\{\\tau\\}` as the input. We can deduce the\n> > base ring morphism from here as the morphism `\\Fq[X] \\to K` defined by\n> > `D \\circ \\phi`, where `D` is the \"constant-coefficient function\".\n> > \n> > As we saw in the early days of this ticket, this requires numerous lines of\n> > code, and we chose a lighter solution: `DrinfeldModule` is defined with the\n> > sole generator; the base morphism is implicitly defined as the ring morphism\n> > `A \\to K` that maps `a` to the constant coefficient of `\\phi_a`, and where `K`\n> > is the compositum of all the parents of the coefficients.\n> > \n> > This means that a Drinfeld module whose coefficients lie in a finite field\n> > (e.g. `\\Fq`) but whose parent is a function field (e.g. `\\Fq(X)`) would not be\n> > considered finite.\n\n> \n> Unless that I'm confused again, I think that by giving a morphism `A --> K{\\tau}` as the input, the same problem could be possible to recreate: we could consider a morphism `A --> \\Fq(X){\\tau}` sending `X` to a `\\tau`-polynomial with coefficient in `\\Fq` which are coerced in `\\Fq(X)`.\n> \n> Do you think that the Drinfeld module constructor could parse the coefficients a little bit further by checking if they can be converted into an element of a finite field? For example:\n> \n> ```\n> sage: A.<X> = GF(5)[]\n> sage: K.<X> = Frac(A)\n> sage: a = K(2)\n> sage: a.parent()\n> Fraction Field of Univariate Polynomial Ring in X over Finite Field of size 5\n> sage: b = K.base_ring()(a); b\n> 2\n> sage: b.parent()\n> Finite Field of size 5\n> sage: K.base_ring()(X)\n> Traceback (most recent call last):\n> ...\n> ValueError: not constant\n> ```\n\n\nPlease let me know if I misunderstood something.\n\nI think coefficients of the Drinfeld module generator should always be seen as\nelement of the codomain of the morphism `gamma: A \\to K` that defines the\ncategory. Even if the coefficients could be seen in a smaller, finite field.\nThis makes a clear convention; users can themselves specify the field they\nwant.\n\nFor example, if the Drinfeld module is defined using `[Frac(FqX)(1), Frac(FqX)(1)]`,\nI don't consider it finite, because `K` is `Frac(FqX)` and it\nis infinite. However, this Drinfeld module canonically corresponds to a finite\nDrinfeld module defined over `\\Fq`. I suggest that the constructor stays the\nsame and doesn't try any conversion. We may however create a method that casts\nthe Drinfeld module to a new one with a smaller field, whenever possible.",
    "created_at": "2022-10-17T11:16:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672274",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:270'></a>
Replying to [David Ayotte](#comment%3A268):
> Replying to [Antoine Leudière](#comment%3A267):
> > The problem is the following. In this implementation, the base of a Drinfeld module category is a morphism `\gamma: A \to K` rather than just the field `K`. Therefore, the method `base_ring` is misleading (to me at least), and I don't want it implemented (this is debatable, as a `change_ring` method would be nice).

> 
> May I ask what are the advantages of considering a `A`-field (`A = Fq[X]`) as a morphism? Mathematically, a `A`-field is just a field `F` which is a `A`-algebra `F` via a morphism `Fq[X] ---> F`. Thus, I think that there are two valid points of view for a `A`-field (as a field or as a morphism) in a similar way that there are two valid points of view for a representation (as a module or a group morphism). So, to rephrase my question, what made you choose to consider the morphism point of view?
> 


I think both points of view are very good, and I did not know about
`K.over(gamma)`, which is why I went for the morphism! Thanks Xavier for the
tip. Despite the morphism point of view working and being quite natural, I am
happy to change for the `A`-field point of view! I will refactor the code.


> > In my view, the ideal solution would be to instantiate a Drinfeld module `phi`
> > by giving a **morphism** `A \to K\{\tau\}` as the input. We can deduce the
> > base ring morphism from here as the morphism `\Fq[X] \to K` defined by
> > `D \circ \phi`, where `D` is the "constant-coefficient function".
> > 
> > As we saw in the early days of this ticket, this requires numerous lines of
> > code, and we chose a lighter solution: `DrinfeldModule` is defined with the
> > sole generator; the base morphism is implicitly defined as the ring morphism
> > `A \to K` that maps `a` to the constant coefficient of `\phi_a`, and where `K`
> > is the compositum of all the parents of the coefficients.
> > 
> > This means that a Drinfeld module whose coefficients lie in a finite field
> > (e.g. `\Fq`) but whose parent is a function field (e.g. `\Fq(X)`) would not be
> > considered finite.

> 
> Unless that I'm confused again, I think that by giving a morphism `A --> K{\tau}` as the input, the same problem could be possible to recreate: we could consider a morphism `A --> \Fq(X){\tau}` sending `X` to a `\tau`-polynomial with coefficient in `\Fq` which are coerced in `\Fq(X)`.
> 
> Do you think that the Drinfeld module constructor could parse the coefficients a little bit further by checking if they can be converted into an element of a finite field? For example:
> 
> ```
> sage: A.<X> = GF(5)[]
> sage: K.<X> = Frac(A)
> sage: a = K(2)
> sage: a.parent()
> Fraction Field of Univariate Polynomial Ring in X over Finite Field of size 5
> sage: b = K.base_ring()(a); b
> 2
> sage: b.parent()
> Finite Field of size 5
> sage: K.base_ring()(X)
> Traceback (most recent call last):
> ...
> ValueError: not constant
> ```


Please let me know if I misunderstood something.

I think coefficients of the Drinfeld module generator should always be seen as
element of the codomain of the morphism `gamma: A \to K` that defines the
category. Even if the coefficients could be seen in a smaller, finite field.
This makes a clear convention; users can themselves specify the field they
want.

For example, if the Drinfeld module is defined using `[Frac(FqX)(1), Frac(FqX)(1)]`,
I don't consider it finite, because `K` is `Frac(FqX)` and it
is infinite. However, this Drinfeld module canonically corresponds to a finite
Drinfeld module defined over `\Fq`. I suggest that the constructor stays the
same and doesn't try any conversion. We may however create a method that casts
the Drinfeld module to a new one with a smaller field, whenever possible.



---

archive/issue_comments_672275.json:
```json
{
    "body": "<a id='comment:1'></a>\n> Please let me know if I misunderstood something.\n\n\nNo I don't think that you misunderstood something. In fact, I think you've made some good points. I was seeing this as a problem, but, looking back, I find that it is really just a matter of definition/convention. Therefore, I'm totally fine to leave it as it is.",
    "created_at": "2022-10-17T13:17:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672275",
    "user": "https://github.com/DavidAyotte"
}
```


<a id='comment:1'></a>
> Please let me know if I misunderstood something.


No I don't think that you misunderstood something. In fact, I think you've made some good points. I was seeing this as a problem, but, looking back, I find that it is really just a matter of definition/convention. Therefore, I'm totally fine to leave it as it is.



---

archive/issue_comments_672276.json:
```json
{
    "body": "<a id='comment:272'></a>\nReplying to [David Ayotte](#comment%3A271):\n> > Please let me know if I misunderstood something.\n\n> \n> No I don't think that you misunderstood something. In fact, I think you've made some good points. I was seeing this as a problem, but, looking back, I find that it is really just a matter of definition/convention. Therefore, I'm totally fine to leave it as it is.\n\n\nUnderstood. Thank you for this discussion!",
    "created_at": "2022-10-17T14:09:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672276",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:272'></a>
Replying to [David Ayotte](#comment%3A271):
> > Please let me know if I misunderstood something.

> 
> No I don't think that you misunderstood something. In fact, I think you've made some good points. I was seeing this as a problem, but, looking back, I find that it is really just a matter of definition/convention. Therefore, I'm totally fine to leave it as it is.


Understood. Thank you for this discussion!



---

archive/issue_comments_672277.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** New commits:\n|                                                                                                                                           |                                                    |\n|-------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|\n|[31e8cf5](https://github.com/sagemath/sagetrac-mirror/commit/31e8cf57cab36d3b8452fc1c7261da8ccb5c4aec)|`Merge branch 'develop' into public/drinfeld_module`|\n|[501a254](https://github.com/sagemath/sagetrac-mirror/commit/501a25411904ead8d9b097f465cd40b984eaa701)|<code>Implement `characteristic` method for rings extensions</code>|\n|[bcffa0c](https://github.com/sagemath/sagetrac-mirror/commit/bcffa0cf0842ebef2403d5c8b6aa88514beb86e1)|`Fix imprecision in documentation`|\n|[675e249](https://github.com/sagemath/sagetrac-mirror/commit/675e24988a07f58d092a7ddb976c9e6ee04f3ba6)|`Add tests for characteristic method`|\n|[ab2c211](https://github.com/sagemath/sagetrac-mirror/commit/ab2c211033e15fa5237b20690a715d50577d06f1)|`Fix doctest`|\n|[6982ae0](https://github.com/sagemath/sagetrac-mirror/commit/6982ae08d9ce6dbb622ba570299e2130b2397026)|`Merge branch 'public/ring-extension-characteristic' into public/drinfeld_module`|",
    "created_at": "2022-11-15T15:24:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672277",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** New commits:
|                                                                                                                                           |                                                    |
|-------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
|[31e8cf5](https://github.com/sagemath/sagetrac-mirror/commit/31e8cf57cab36d3b8452fc1c7261da8ccb5c4aec)|`Merge branch 'develop' into public/drinfeld_module`|
|[501a254](https://github.com/sagemath/sagetrac-mirror/commit/501a25411904ead8d9b097f465cd40b984eaa701)|<code>Implement `characteristic` method for rings extensions</code>|
|[bcffa0c](https://github.com/sagemath/sagetrac-mirror/commit/bcffa0cf0842ebef2403d5c8b6aa88514beb86e1)|`Fix imprecision in documentation`|
|[675e249](https://github.com/sagemath/sagetrac-mirror/commit/675e24988a07f58d092a7ddb976c9e6ee04f3ba6)|`Add tests for characteristic method`|
|[ab2c211](https://github.com/sagemath/sagetrac-mirror/commit/ab2c211033e15fa5237b20690a715d50577d06f1)|`Fix doctest`|
|[6982ae0](https://github.com/sagemath/sagetrac-mirror/commit/6982ae08d9ce6dbb622ba570299e2130b2397026)|`Merge branch 'public/ring-extension-characteristic' into public/drinfeld_module`|



---

archive/issue_comments_672278.json:
```json
{
    "body": "**Changing commit** from \"[78c99e05e5b12568dcb2def70da21cfc0d8fa870](https://github.com/sagemath/sagetrac-mirror/commit/78c99e05e5b12568dcb2def70da21cfc0d8fa870)\" to \"[6982ae08d9ce6dbb622ba570299e2130b2397026](https://github.com/sagemath/sagetrac-mirror/commit/6982ae08d9ce6dbb622ba570299e2130b2397026)\".",
    "created_at": "2022-11-15T15:24:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672278",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```


**Changing commit** from "[78c99e05e5b12568dcb2def70da21cfc0d8fa870](https://github.com/sagemath/sagetrac-mirror/commit/78c99e05e5b12568dcb2def70da21cfc0d8fa870)" to "[6982ae08d9ce6dbb622ba570299e2130b2397026](https://github.com/sagemath/sagetrac-mirror/commit/6982ae08d9ce6dbb622ba570299e2130b2397026)".



---

archive/issue_comments_672279.json:
```json
{
    "body": "**Dependencies:** #34692",
    "created_at": "2022-11-15T15:50:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672279",
    "user": "https://github.com/antoine-leudiere"
}
```


**Dependencies:** #34692



---

archive/issue_comments_672280.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -44,12 +44,6 @@\n   To:   Finite Field in i of size 2^2\n   Defn: X |--> i\n ```\n-\n-## Lint and build fails\n-\n-Lint errors are `E501`, which is due to Sage console outputs in `EXAMPLES::` or `TESTS::` fields. Likewise, documentation build errors are also due to Sage console outputs. Finally, it seems that the responsible for build errors is `sage/schemes/toric/sheaf/klyachko.py`.\n-\n-Any help with those issues is welcome!\n \n ---\n \n``````\n",
    "created_at": "2022-11-15T15:51:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672280",
    "user": "https://github.com/antoine-leudiere"
}
```


**Description changed:**
``````diff
--- 
+++ 
@@ -44,12 +44,6 @@
   To:   Finite Field in i of size 2^2
   Defn: X |--> i
 ```
-
-## Lint and build fails
-
-Lint errors are `E501`, which is due to Sage console outputs in `EXAMPLES::` or `TESTS::` fields. Likewise, documentation build errors are also due to Sage console outputs. Finally, it seems that the responsible for build errors is `sage/schemes/toric/sheaf/klyachko.py`.
-
-Any help with those issues is welcome!
 
 ---
 
``````




---

archive/issue_comments_672281.json:
```json
{
    "body": "<a id='comment:6'></a>\nAfter discussing this with Xavier Caruso, we suggest to remove the class `DrinfeldModuleAction` in order to replace it by a new class, representing the *module* associated to a Drinfeld module. See ticket #34833, which will be worked on later.\n\nBest,\n\nAntoine",
    "created_at": "2022-12-09T14:08:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33713",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33713#issuecomment-672281",
    "user": "https://github.com/antoine-leudiere"
}
```


<a id='comment:6'></a>
After discussing this with Xavier Caruso, we suggest to remove the class `DrinfeldModuleAction` in order to replace it by a new class, representing the *module* associated to a Drinfeld module. See ticket #34833, which will be worked on later.

Best,

Antoine
