# Issue 33018: Equal hashes for non-isomorphic bipartite graphs with edge labels

archive/issues_033018.json:
```json
{
    "body": "The following code illustrates the problem that two bipartite graph `B1` and `B2` (both canonically labeled) are claimed to be equal and have equal hashes, while they are NOT isomorphic, let alone equal, as labeled graphs. \n\nWhen labels are ignored, these graphs are isomorphic, and so the problem may be caused by equality testing / `hash()` function somehow ignoring edge labels.\n\n\n```\nB1 = BipartiteGraph( [(0, 11, 2), (0, 12, 1), (0, 14, 1), (0, 16, 1), (1, 10, 1), (1, 13, 1), (1, 14, 2), (1, 16, 1), (2, 10, 2), (2, 11, 1), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True )\n\nB2 = BipartiteGraph( [(0, 11, 1), (0, 12, 1), (0, 14, 2), (0, 16, 1), (1, 10, 2), (1, 13, 1), (1, 14, 1), (1, 16, 1), (2, 10, 1), (2, 11, 2), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True )\n\nprint('Same hashes:', hash(B1) == hash(B2) )\nprint('Isomorphic:', B1.is_isomorphic( B2, edge_labels=True ) )\nprint('Equal:', B1 == B2)\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/33255\n\n",
    "created_at": "2022-01-31T05:18:48Z",
    "labels": [
        "component: graph theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Equal hashes for non-isomorphic bipartite graphs with edge labels",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/33018",
    "user": "https://github.com/maxale"
}
```
The following code illustrates the problem that two bipartite graph `B1` and `B2` (both canonically labeled) are claimed to be equal and have equal hashes, while they are NOT isomorphic, let alone equal, as labeled graphs. 

When labels are ignored, these graphs are isomorphic, and so the problem may be caused by equality testing / `hash()` function somehow ignoring edge labels.


```
B1 = BipartiteGraph( [(0, 11, 2), (0, 12, 1), (0, 14, 1), (0, 16, 1), (1, 10, 1), (1, 13, 1), (1, 14, 2), (1, 16, 1), (2, 10, 2), (2, 11, 1), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True )

B2 = BipartiteGraph( [(0, 11, 1), (0, 12, 1), (0, 14, 2), (0, 16, 1), (1, 10, 2), (1, 13, 1), (1, 14, 1), (1, 16, 1), (2, 10, 1), (2, 11, 2), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True )

print('Same hashes:', hash(B1) == hash(B2) )
print('Isomorphic:', B1.is_isomorphic( B2, edge_labels=True ) )
print('Equal:', B1 == B2)
```


Issue created by migration from https://trac.sagemath.org/ticket/33255





---

archive/issue_comments_470224.json:
```json
{
    "body": "Changing component from group theory to graph theory.",
    "created_at": "2022-01-31T05:19:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470224",
    "user": "https://github.com/maxale"
}
```

Changing component from group theory to graph theory.



---

archive/issue_comments_470225.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to defect.",
    "created_at": "2022-01-31T05:26:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470225",
    "user": "https://github.com/maxale"
}
```

Changing type from PLEASE CHANGE to defect.



---

archive/issue_comments_470226.json:
```json
{
    "body": "The docstring for `Graph.__eq__` says: \"... labels of arrows/edges are taken into account if **and only if** the graphs are considered weighted ...\".  This means that if you want equality testing to consider the edge labels (i.e., if you want the graphs to be considered as labelled graphs), then you need to make the graphs weighted.\n\n```\nsage: B1 = BipartiteGraph( [(0, 11, 2), (0, 12, 1), (0, 14, 1), (0, 16, 1), (1, 10, 1), (1, 13, 1), (1, 14, 2), (1, 16, 1), (2, 10, 2), (2, 11, 1), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True, weighted=True )\n\nsage: B2 = BipartiteGraph( [(0, 11, 1), (0, 12, 1), (0, 14, 2), (0, 16, 1), (1, 10, 2), (1, 13, 1), (1, 14, 1), (1, 16, 1), (2, 10, 1), (2, 11, 2), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True, weighted=True )\n\nsage: print('Same hashes:', hash(B1) == hash(B2) )\nsage: print('Isomorphic:', B1.is_isomorphic( B2, edge_labels=True ) )\nsage: print('Equal:', B1 == B2)\n\nSame hashes: False\nIsomorphic: False\nEqual: False\n```\nSo this is not a bug in the method, but I can see that this could be unexpected behavior.  \n\nPerhaps a warning should be given when edge labels are put on an unweighted graph, or perhaps the documentation should be clarified.",
    "created_at": "2022-01-31T06:03:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470226",
    "user": "https://github.com/DaveWitteMorris"
}
```

The docstring for `Graph.__eq__` says: "... labels of arrows/edges are taken into account if **and only if** the graphs are considered weighted ...".  This means that if you want equality testing to consider the edge labels (i.e., if you want the graphs to be considered as labelled graphs), then you need to make the graphs weighted.

```
sage: B1 = BipartiteGraph( [(0, 11, 2), (0, 12, 1), (0, 14, 1), (0, 16, 1), (1, 10, 1), (1, 13, 1), (1, 14, 2), (1, 16, 1), (2, 10, 2), (2, 11, 1), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True, weighted=True )

sage: B2 = BipartiteGraph( [(0, 11, 1), (0, 12, 1), (0, 14, 2), (0, 16, 1), (1, 10, 2), (1, 13, 1), (1, 14, 1), (1, 16, 1), (2, 10, 1), (2, 11, 2), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True, weighted=True )

sage: print('Same hashes:', hash(B1) == hash(B2) )
sage: print('Isomorphic:', B1.is_isomorphic( B2, edge_labels=True ) )
sage: print('Equal:', B1 == B2)

Same hashes: False
Isomorphic: False
Equal: False
```
So this is not a bug in the method, but I can see that this could be unexpected behavior.  

Perhaps a warning should be given when edge labels are put on an unweighted graph, or perhaps the documentation should be clarified.



---

archive/issue_comments_470227.json:
```json
{
    "body": "Changing type from defect to enhancement.",
    "created_at": "2022-01-31T06:03:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470227",
    "user": "https://github.com/DaveWitteMorris"
}
```

Changing type from defect to enhancement.



---

archive/issue_comments_470228.json:
```json
{
    "body": "Simpler examples:\n\n```\nsage: a = [(0, 2, 1), (0, 3, 2), (1, 3, 1)]\nsage: b = [(0, 2, 2), (0, 3, 1), (1, 3, 2)]\n\nsage: A = BipartiteGraph(a, immutable=True)\nsage: B = BipartiteGraph(b, immutable=True)\n\nsage: print(f'Same hashes: {hash(A) == hash(B)}\\n'\n....:       f'Isomorphic: {A.is_isomorphic(B, edge_labels=True)}\\n'\n....:       f'Equal: {A == B}')\nSame hashes: True\nIsomorphic: False\nEqual: True\n\nsage: C = BipartiteGraph(a, immutable=True, weighted=True)\nsage: D = BipartiteGraph(b, immutable=True, weighted=True)\n\nsage: print(f'Same hashes: {hash(C) == hash(D)}\\n'\n....:       f'Isomorphic: {C.is_isomorphic(D, edge_labels=True)}\\n'\n....:       f'Equal: {C == D}')\nSame hashes: False\nIsomorphic: False\nEqual: False\n```",
    "created_at": "2022-01-31T10:27:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470228",
    "user": "https://github.com/slel"
}
```

Simpler examples:

```
sage: a = [(0, 2, 1), (0, 3, 2), (1, 3, 1)]
sage: b = [(0, 2, 2), (0, 3, 1), (1, 3, 2)]

sage: A = BipartiteGraph(a, immutable=True)
sage: B = BipartiteGraph(b, immutable=True)

sage: print(f'Same hashes: {hash(A) == hash(B)}\n'
....:       f'Isomorphic: {A.is_isomorphic(B, edge_labels=True)}\n'
....:       f'Equal: {A == B}')
Same hashes: True
Isomorphic: False
Equal: True

sage: C = BipartiteGraph(a, immutable=True, weighted=True)
sage: D = BipartiteGraph(b, immutable=True, weighted=True)

sage: print(f'Same hashes: {hash(C) == hash(D)}\n'
....:       f'Isomorphic: {C.is_isomorphic(D, edge_labels=True)}\n'
....:       f'Equal: {C == D}')
Same hashes: False
Isomorphic: False
Equal: False
```



---

archive/issue_comments_470229.json:
```json
{
    "body": "The manipulation of edge labels is not simple since labels might not be hashable. For instance, a label can be a `Graph` or a dictionary.\nIn general, I prefer when the decision to consider labels is explicit (an argument set to `True` or `False`). \nDo you have any proposal to improve the documentation ?",
    "created_at": "2022-01-31T10:46:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470229",
    "user": "https://github.com/dcoudert"
}
```

The manipulation of edge labels is not simple since labels might not be hashable. For instance, a label can be a `Graph` or a dictionary.
In general, I prefer when the decision to consider labels is explicit (an argument set to `True` or `False`). 
Do you have any proposal to improve the documentation ?



---

archive/issue_comments_470230.json:
```json
{
    "body": "A related issue is the name of this option. What is called `weighted=` in `BipartiteGraph()` in many other methods (like `.is_isomorphic()`, `.canonical_label()`, `.automorphism_group()` etc.) is called `edge_labels=`. \n\nShould there be consistency in the naming of this option?",
    "created_at": "2022-01-31T14:09:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470230",
    "user": "https://github.com/maxale"
}
```

A related issue is the name of this option. What is called `weighted=` in `BipartiteGraph()` in many other methods (like `.is_isomorphic()`, `.canonical_label()`, `.automorphism_group()` etc.) is called `edge_labels=`. 

Should there be consistency in the naming of this option?



---

archive/issue_comments_470231.json:
```json
{
    "body": "Documentation says:\n\n    weighted \u2013 boolean (default: None); whether graph thinks of itself as weighted or not. See self.weighted()\n\nSo, the default value is not `True` or `False`, but `None`. I'd suggest that when `weighted=None` (ie., not specified), it should guessed from the input data. That is, if labels are present in the given data, `BipartiteGraph()` should assume `weighted=True`, otherwise it's `weighted=False`.",
    "created_at": "2022-01-31T19:50:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470231",
    "user": "https://github.com/maxale"
}
```

Documentation says:

    weighted â€“ boolean (default: None); whether graph thinks of itself as weighted or not. See self.weighted()

So, the default value is not `True` or `False`, but `None`. I'd suggest that when `weighted=None` (ie., not specified), it should guessed from the input data. That is, if labels are present in the given data, `BipartiteGraph()` should assume `weighted=True`, otherwise it's `weighted=False`.



---

archive/issue_comments_470232.json:
```json
{
    "body": "I want to clarify what fix is expected for this ticket:\n- Either replace `edge_labels` with `weighted` or vice versa for consistency\n- When `weighted=None`, assign `True` or `False` to `weighted` after checking the input data for labels. For example, if the input is an edge list, just check if at least one edge is a triple (and the third item is not `None`). \nIs this right?",
    "created_at": "2022-04-12T17:26:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470232",
    "user": "https://github.com/enjeck"
}
```

I want to clarify what fix is expected for this ticket:
- Either replace `edge_labels` with `weighted` or vice versa for consistency
- When `weighted=None`, assign `True` or `False` to `weighted` after checking the input data for labels. For example, if the input is an edge list, just check if at least one edge is a triple (and the third item is not `None`). 
Is this right?



---

archive/issue_comments_470233.json:
```json
{
    "body": "Replying to [comment:9 gh-enjeck]:\n> I want to clarify what fix is expected for this ticket:\n> - Either replace `edge_labels` with `weighted` or vice versa for consistency\n> - When `weighted=None`, assign `True` or `False` to `weighted` after checking the input data for labels. For example, if the input is an edge list, just check if at least one edge is a triple (and the third item is not `None`). \n> Is this right? \n\n\nYes, this would be great!",
    "created_at": "2022-04-12T23:00:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470233",
    "user": "https://github.com/maxale"
}
```

Replying to [comment:9 gh-enjeck]:
> I want to clarify what fix is expected for this ticket:
> - Either replace `edge_labels` with `weighted` or vice versa for consistency
> - When `weighted=None`, assign `True` or `False` to `weighted` after checking the input data for labels. For example, if the input is an edge list, just check if at least one edge is a triple (and the third item is not `None`). 
> Is this right? 


Yes, this would be great!



---

archive/issue_comments_470234.json:
```json
{
    "body": "I disagree with the proposed change of behavior of parameter `weighted`, and observe that it may affect the entire graph library and other modules using graphs.\n\nParameter `weighted` is an old parameter that is used in some algorithm to specify the default behavior. That is, do computations in a weighted graph instead of unweighted graph. This is for instance the case for `min_spanning_tree`.\nWe have a long term objective of unifying the use of weights #13112. I'm not sure that parameter `weighted` is well taken into account by all methods that can use edge weights. So, I usually prefer to explicitly set `by_weight=True` to avoid confusion.\n\nMay be others have a different opinion ?",
    "created_at": "2022-04-13T09:14:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470234",
    "user": "https://github.com/dcoudert"
}
```

I disagree with the proposed change of behavior of parameter `weighted`, and observe that it may affect the entire graph library and other modules using graphs.

Parameter `weighted` is an old parameter that is used in some algorithm to specify the default behavior. That is, do computations in a weighted graph instead of unweighted graph. This is for instance the case for `min_spanning_tree`.
We have a long term objective of unifying the use of weights #13112. I'm not sure that parameter `weighted` is well taken into account by all methods that can use edge weights. So, I usually prefer to explicitly set `by_weight=True` to avoid confusion.

May be others have a different opinion ?



---

archive/issue_events_087817.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:17:06Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33018#event-87817"
}
```



---

archive/issue_events_087818.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33018#event-87818"
}
```



---

archive/issue_events_087819.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33018#event-87819"
}
```



---

archive/issue_comments_470235.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2022-10-31T17:56:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470235",
    "user": "https://github.com/Bruno-TT"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_470236.json:
```json
{
    "body": "There was never a unanimous consensus on how to handle the weight/labelling logic, so I've implemented a suggestion.\n\nMy implementation adds an optional boolean parameter hash_labels to the class constructor, which if left empty will default to None and warn the user upon hash() invocation, and then include labels in the hash.\n\nLet me know what you guys think.\n\n(I'm new to the project so please feel free to give criticism, I'm assuming I've somehow misused trac).",
    "created_at": "2022-10-31T17:56:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470236",
    "user": "https://github.com/Bruno-TT"
}
```

There was never a unanimous consensus on how to handle the weight/labelling logic, so I've implemented a suggestion.

My implementation adds an optional boolean parameter hash_labels to the class constructor, which if left empty will default to None and warn the user upon hash() invocation, and then include labels in the hash.

Let me know what you guys think.

(I'm new to the project so please feel free to give criticism, I'm assuming I've somehow misused trac).



---

archive/issue_comments_470237.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-10-31T17:58:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470237",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_470238.json:
```json
{
    "body": "Welcome to Sagemath.\n\nTo be consistent, you should add parameter `hash_labels` to all (bipartite) (di)graph classes and make sure the parameter is copied when making a copy of the graph.\n\nI disagree with the default `None` value. We usually don't print warnings.\nI think it should default to `False` (current behavior) and be set to `True` if either it's the input value or if the graph is weighted.\n\nFor the `__hash__` method, please check `Graph.__hash__??`. It's better to use frozenset to avoid sorting. So simply use `left = frozenset(self.left)`.\n\nFinally, please try to use the same coding style as other methods.",
    "created_at": "2022-11-01T08:45:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470238",
    "user": "https://github.com/dcoudert"
}
```

Welcome to Sagemath.

To be consistent, you should add parameter `hash_labels` to all (bipartite) (di)graph classes and make sure the parameter is copied when making a copy of the graph.

I disagree with the default `None` value. We usually don't print warnings.
I think it should default to `False` (current behavior) and be set to `True` if either it's the input value or if the graph is weighted.

For the `__hash__` method, please check `Graph.__hash__??`. It's better to use frozenset to avoid sorting. So simply use `left = frozenset(self.left)`.

Finally, please try to use the same coding style as other methods.



---

archive/issue_comments_470239.json:
```json
{
    "body": "and try to stick to informative commit messages. If this ticket is merged, the commit messages become a permanent part of the sagemath repository and people who need to investigate the code for later maintenance will bump into them. The way these messages are formulated reflects on you (the author) and on the project as a whole.",
    "created_at": "2022-11-01T15:56:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470239",
    "user": "https://github.com/nbruin"
}
```

and try to stick to informative commit messages. If this ticket is merged, the commit messages become a permanent part of the sagemath repository and people who need to investigate the code for later maintenance will bump into them. The way these messages are formulated reflects on you (the author) and on the project as a whole.



---

archive/issue_comments_470240.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-11-01T16:03:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470240",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_470241.json:
```json
{
    "body": "Replying to [comment:16 David Coudert]:\n> To be consistent, you should add parameter `hash_labels` to all (bipartite) (di)graph classes and make sure the parameter is copied when making a copy of the graph.\n\n\nPlease could you clarify what you mean by this?\n\n> I disagree with the default `None` value. We usually don't print warnings.\n> I think it should default to `False` (current behavior) and be set to `True` if either it's the input value or if the graph is weighted.\n\n{{{\ndef _use_hash_labels(self):\n    return self.weighted() or self.hash_labels\n}}}\nJust changed the logic - is this what you mean?\n\n> For the `__hash__` method, please check `Graph.__hash__??`. It's better to use frozenset to avoid sorting. So simply use `left = frozenset(self.left)`.\n\n\nCool, thanks for the tip - changed it.\n\n> Finally, please try to use the same coding style as other methods.\n\n\nI've run autopep8\n\n---\nNew commits:",
    "created_at": "2022-11-01T16:03:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470241",
    "user": "https://github.com/Bruno-TT"
}
```

Replying to [comment:16 David Coudert]:
> To be consistent, you should add parameter `hash_labels` to all (bipartite) (di)graph classes and make sure the parameter is copied when making a copy of the graph.


Please could you clarify what you mean by this?

> I disagree with the default `None` value. We usually don't print warnings.
> I think it should default to `False` (current behavior) and be set to `True` if either it's the input value or if the graph is weighted.

{{{
def _use_hash_labels(self):
    return self.weighted() or self.hash_labels
}}}
Just changed the logic - is this what you mean?

> For the `__hash__` method, please check `Graph.__hash__??`. It's better to use frozenset to avoid sorting. So simply use `left = frozenset(self.left)`.


Cool, thanks for the tip - changed it.

> Finally, please try to use the same coding style as other methods.


I've run autopep8

---
New commits:



---

archive/issue_comments_470242.json:
```json
{
    "body": "Please avoid modifying parts of the code that have nothing to do with the objective of this ticket. It makes the reviewing process very difficult. To improve the coding style of a file, we prefer to open dedicated tickets and to not do it blindly.\n\n\nSimilarly to the `Graph__hash__` method, the `__hash__` method should be something like this (examples and tests are missing).\n\n```\ndef __hash__(self):\n    r\"\"\"\n    Compute a hash for ``self``, if ``self`` is immutable.\n\n    \"\"\"\n    if self.is_immutable():\n        edge_items = self.edge_iterator(labels=self._weighted or self.hash_labels)\n        if self.allows_multiple_edges():\n            from collections import Counter\n            edge_items = Counter(edge_items).items()\n        return hash((frozenset(self.left),\n                     frozenset(self.right),\n                     frozenset(edge_items))\n    raise TypeError(\"This graph is mutable, and thus not hashable. \"\n                    \"Create an immutable copy by `g.copy(immutable=True)`\")\n```\n\nNow, if we add this parameter to `BipartiteGraph`, it might be better to add it to `Graph`, `DiGraph`, etc. as well. Also, you must ensure that the parameter is copied if you do a copy.",
    "created_at": "2022-11-01T16:23:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470242",
    "user": "https://github.com/dcoudert"
}
```

Please avoid modifying parts of the code that have nothing to do with the objective of this ticket. It makes the reviewing process very difficult. To improve the coding style of a file, we prefer to open dedicated tickets and to not do it blindly.


Similarly to the `Graph__hash__` method, the `__hash__` method should be something like this (examples and tests are missing).

```
def __hash__(self):
    r"""
    Compute a hash for ``self``, if ``self`` is immutable.

    """
    if self.is_immutable():
        edge_items = self.edge_iterator(labels=self._weighted or self.hash_labels)
        if self.allows_multiple_edges():
            from collections import Counter
            edge_items = Counter(edge_items).items()
        return hash((frozenset(self.left),
                     frozenset(self.right),
                     frozenset(edge_items))
    raise TypeError("This graph is mutable, and thus not hashable. "
                    "Create an immutable copy by `g.copy(immutable=True)`")
```

Now, if we add this parameter to `BipartiteGraph`, it might be better to add it to `Graph`, `DiGraph`, etc. as well. Also, you must ensure that the parameter is copied if you do a copy.



---

archive/issue_comments_470243.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-11-01T17:19:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470243",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_470244.json:
```json
{
    "body": "Replying to [comment:20 David Coudert]:\n> Please avoid modifying parts of the code that have nothing to do with the objective of this ticket. It makes the reviewing process very difficult. To improve the coding style of a file, we prefer to open dedicated tickets and to not do it blindly.\n\n\nApologies for being too eager with the pep8 formatting - I've reverted the commit.\n\n\n> Similarly to the `Graph__hash__` method, the `__hash__` method should be something like this (examples and tests are missing).\n> \n> ```\n> def __hash__(self):\n>     r\"\"\"\n>     Compute a hash for ``self``, if ``self`` is immutable.\n> \n>     \"\"\"\n>     if self.is_immutable():\n>         edge_items = self.edge_iterator(labels=self._weighted or self.hash_labels)\n>         if self.allows_multiple_edges():\n>             from collections import Counter\n>             edge_items = Counter(edge_items).items()\n>         return hash((frozenset(self.left),\n>                      frozenset(self.right),\n>                      frozenset(edge_items))\n>     raise TypeError(\"This graph is mutable, and thus not hashable. \"\n>                     \"Create an immutable copy by `g.copy(immutable=True)`\")\n> ```\n\n\nI've had a play around with your suggestion, but there is some slightly weird behaviour.\n\nI'm not exactly sure what's going on, but for some reason, hashing a tuple containing an edge_iterator() object gives unreliable results:\n\n\n```\nsage: B1 = BipartiteGraph([(1,2,3)], immutable=True)\nsage: hash((B1.edge_iterator(labels=False),))\n-4081111260156298028\nsage: hash((B1.edge_iterator(labels=False),)) # same line as above\n6054870339558346632\n```\n\nFor now, I'm going to keep using my initial list/tuple_depth implementation since it seems to produce more reliable results\n\n> Now, if we add this parameter to `BipartiteGraph`, it might be better to add it to `Graph`, `DiGraph`, etc. as well. \n\n\nApologies for repeatedly asking for clarification, but are you saying I should add a hash_labels argument to the constructors of every graph class, [and/or _use_hash_labels() logic]?\n\n> Also, you must ensure that the parameter is copied if you do a copy.\n\n\nHow should I go about making sure the parameter is copied?",
    "created_at": "2022-11-08T16:54:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470244",
    "user": "https://github.com/Bruno-TT"
}
```

Replying to [comment:20 David Coudert]:
> Please avoid modifying parts of the code that have nothing to do with the objective of this ticket. It makes the reviewing process very difficult. To improve the coding style of a file, we prefer to open dedicated tickets and to not do it blindly.


Apologies for being too eager with the pep8 formatting - I've reverted the commit.


> Similarly to the `Graph__hash__` method, the `__hash__` method should be something like this (examples and tests are missing).
> 
> ```
> def __hash__(self):
>     r"""
>     Compute a hash for ``self``, if ``self`` is immutable.
> 
>     """
>     if self.is_immutable():
>         edge_items = self.edge_iterator(labels=self._weighted or self.hash_labels)
>         if self.allows_multiple_edges():
>             from collections import Counter
>             edge_items = Counter(edge_items).items()
>         return hash((frozenset(self.left),
>                      frozenset(self.right),
>                      frozenset(edge_items))
>     raise TypeError("This graph is mutable, and thus not hashable. "
>                     "Create an immutable copy by `g.copy(immutable=True)`")
> ```


I've had a play around with your suggestion, but there is some slightly weird behaviour.

I'm not exactly sure what's going on, but for some reason, hashing a tuple containing an edge_iterator() object gives unreliable results:


```
sage: B1 = BipartiteGraph([(1,2,3)], immutable=True)
sage: hash((B1.edge_iterator(labels=False),))
-4081111260156298028
sage: hash((B1.edge_iterator(labels=False),)) # same line as above
6054870339558346632
```

For now, I'm going to keep using my initial list/tuple_depth implementation since it seems to produce more reliable results

> Now, if we add this parameter to `BipartiteGraph`, it might be better to add it to `Graph`, `DiGraph`, etc. as well. 


Apologies for repeatedly asking for clarification, but are you saying I should add a hash_labels argument to the constructors of every graph class, [and/or _use_hash_labels() logic]?

> Also, you must ensure that the parameter is copied if you do a copy.


How should I go about making sure the parameter is copied?



---

archive/issue_comments_470245.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-11-08T16:55:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470245",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_470246.json:
```json
{
    "body": "Have your tried the method I proposed to hash a `BipartiteGraph` ? it is very similar to the hash function for `Graph`. It makes a frozenset of the list of edges which prevents ordering issues.\n\nConcerning copy, you must ensure in method copy of `src/sage/graphs/generic_graph.py` that attribute `hash_labels` is copied (if it exists).\n\nIf you want to generalize the idea to `Graph`, `DiGraph`, `GenericGraph`, the parameter should be set in the constructor of each of these classes and that the hash method of  `src/sage/graphs/generic_graph.py` should be updated accordingly.",
    "created_at": "2022-11-08T17:34:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470246",
    "user": "https://github.com/dcoudert"
}
```

Have your tried the method I proposed to hash a `BipartiteGraph` ? it is very similar to the hash function for `Graph`. It makes a frozenset of the list of edges which prevents ordering issues.

Concerning copy, you must ensure in method copy of `src/sage/graphs/generic_graph.py` that attribute `hash_labels` is copied (if it exists).

If you want to generalize the idea to `Graph`, `DiGraph`, `GenericGraph`, the parameter should be set in the constructor of each of these classes and that the hash method of  `src/sage/graphs/generic_graph.py` should be updated accordingly.



---

archive/issue_comments_470247.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-11-24T14:46:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470247",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_470248.json:
```json
{
    "body": "Replying to [comment:24 David Coudert]:\n> Have your tried the method I proposed to hash a `BipartiteGraph` ? it is very similar to the hash function for `Graph`. It makes a frozenset of the list of edges which prevents ordering issues.\n\nDone!\n\n> Concerning copy, you must ensure in method copy of `src/sage/graphs/generic_graph.py` that attribute `hash_labels` is copied (if it exists).\nDone. Also added a hash_labels parameter to the copy method, although my solution is quite hacky - see my code comment for more info. The feature is fully functional, and I've written some quite comprehensive tests for it, but I also won't take it personally if someone wants to change it or remove it.\n\n\n> If you want to generalize the idea to `Graph`, `DiGraph`, `GenericGraph`, the parameter should be set in the constructor of each of these classes and that the hash method of  `src/sage/graphs/generic_graph.py` should be updated accordingly.\n\nDone, passing all tests.",
    "created_at": "2022-11-24T14:50:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470248",
    "user": "https://github.com/Bruno-TT"
}
```

Replying to [comment:24 David Coudert]:
> Have your tried the method I proposed to hash a `BipartiteGraph` ? it is very similar to the hash function for `Graph`. It makes a frozenset of the list of edges which prevents ordering issues.

Done!

> Concerning copy, you must ensure in method copy of `src/sage/graphs/generic_graph.py` that attribute `hash_labels` is copied (if it exists).
Done. Also added a hash_labels parameter to the copy method, although my solution is quite hacky - see my code comment for more info. The feature is fully functional, and I've written some quite comprehensive tests for it, but I also won't take it personally if someone wants to change it or remove it.


> If you want to generalize the idea to `Graph`, `DiGraph`, `GenericGraph`, the parameter should be set in the constructor of each of these classes and that the hash method of  `src/sage/graphs/generic_graph.py` should be updated accordingly.

Done, passing all tests.



---

archive/issue_comments_470249.json:
```json
{
    "body": "There is a merge conflict with the last beta version.",
    "created_at": "2022-11-24T15:47:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470249",
    "user": "https://github.com/dcoudert"
}
```

There is a merge conflict with the last beta version.



---

archive/issue_comments_470250.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-11-24T18:17:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470250",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_470251.json:
```json
{
    "body": "Replying to [comment:27 David Coudert]:\n> There is a merge conflict with the last beta version.\n\nthink I've resolved it",
    "created_at": "2022-11-24T18:18:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470251",
    "user": "https://github.com/Bruno-TT"
}
```

Replying to [comment:27 David Coudert]:
> There is a merge conflict with the last beta version.

think I've resolved it



---

archive/issue_comments_470252.json:
```json
{
    "body": "Some of the text in the commits should be in the ticket to ease the discussion. For instance I agree that returning `self` is not a good idea as one may for instance want to manipulate copies with different embedding.\n\nAlso, can you push the branch in public (e.g., `public/graphs/33255`) so that I can push review commits. It's faster for me that listing all the details that must be improved.\n\nThanks.",
    "created_at": "2022-11-26T16:11:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470252",
    "user": "https://github.com/dcoudert"
}
```

Some of the text in the commits should be in the ticket to ease the discussion. For instance I agree that returning `self` is not a good idea as one may for instance want to manipulate copies with different embedding.

Also, can you push the branch in public (e.g., `public/graphs/33255`) so that I can push review commits. It's faster for me that listing all the details that must be improved.

Thanks.



---

archive/issue_comments_470253.json:
```json
{
    "body": "Replying to [comment:30 David Coudert]:\n> Some of the text in the commits should be in the ticket to ease the discussion. For instance I agree that returning `self` is not a good idea as one may for instance want to manipulate copies with different embedding.\n\n\nfor anyone interested, here is the text he's referring to:\n\n''This is an ugly hack but it works.\nThis function contains some fairly complex logic, and there is a comment further down that says \"Immutable copy of an immutable graph ? return self !\", the issue being that if we want to change the hash_labels behaviour, then\nreturning self is no longer a good option. I'd argue that a copy function\nreturning self is always bad behaviour, but that's out of the scope for this ticket.\nTrying to weaken the if statement to include something like\n        \n\n```\nand (hash_labels is None or (hash_labels==self._use_labels_for_hash()))\n```\n\n\n*doesn't work, since there is no fallback logic for making an immutable copy of an immutable graph, and my attempts at implementing one caused other tests to break in different bits of the code*\n\n*the hack I've used creates a mutable copy of the graph and then makes an immutable copy of that one. I think this is a fairly unobtrusive implementation, since the function still runs as normally, assuming that they pass nothing into hash_labels, and seems to behave correctly otherwise.*\n\n*However, this is obviously not optimal, and could definitely be improved upon by someone who understands the logic better.* \n\n\n> Also, can you push the branch in public (e.g., `public/graphs/33255`) so that I can push review commits. It's faster for me that listing all the details that must be improved.\n> \n> Thanks.\n\n\npushed to `public/graphs/33255`",
    "created_at": "2022-12-10T14:03:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33018#issuecomment-470253",
    "user": "https://github.com/Bruno-TT"
}
```

Replying to [comment:30 David Coudert]:
> Some of the text in the commits should be in the ticket to ease the discussion. For instance I agree that returning `self` is not a good idea as one may for instance want to manipulate copies with different embedding.


for anyone interested, here is the text he's referring to:

''This is an ugly hack but it works.
This function contains some fairly complex logic, and there is a comment further down that says "Immutable copy of an immutable graph ? return self !", the issue being that if we want to change the hash_labels behaviour, then
returning self is no longer a good option. I'd argue that a copy function
returning self is always bad behaviour, but that's out of the scope for this ticket.
Trying to weaken the if statement to include something like
        

```
and (hash_labels is None or (hash_labels==self._use_labels_for_hash()))
```


*doesn't work, since there is no fallback logic for making an immutable copy of an immutable graph, and my attempts at implementing one caused other tests to break in different bits of the code*

*the hack I've used creates a mutable copy of the graph and then makes an immutable copy of that one. I think this is a fairly unobtrusive implementation, since the function still runs as normally, assuming that they pass nothing into hash_labels, and seems to behave correctly otherwise.*

*However, this is obviously not optimal, and could definitely be improved upon by someone who understands the logic better.* 


> Also, can you push the branch in public (e.g., `public/graphs/33255`) so that I can push review commits. It's faster for me that listing all the details that must be improved.
> 
> Thanks.


pushed to `public/graphs/33255`
