# Issue 33611: Improve edges/ridges for simple/simplicial polytopes

archive/issues_033374.json:
```json
{
    "body": "In #30040 we have improved the face iterator for simple/simplicial polytopes, but have not applied this to our heuristic, whether we should find edges/ridges in dual/non-dual mode.\n\nThis is noticeable for edges of the permutahedron (and theoretically also for other edges of simple polytopes) and does not make a difference otherwise.\n\nBefore:\n\n```\nsage: C = polytopes.hypercube(12).combinatorial_polyhedron()\nsage: %time _ = C.edges()\nCPU times: user 86.1 ms, sys: 9 \u00b5s, total: 86.1 ms\nWall time: 86 ms\nsage: %time _ = C.ridges()\nCPU times: user 617 \u00b5s, sys: 3 \u00b5s, total: 620 \u00b5s\nWall time: 622 \u00b5s\nsage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()\nsage: %time _ = C.edges()\nCPU times: user 114 \u00b5s, sys: 0 ns, total: 114 \u00b5s\nWall time: 117 \u00b5s\nsage: %time _ = C.ridges()\nCPU times: user 1.09 ms, sys: 5 \u00b5s, total: 1.09 ms\nWall time: 1.1 ms\nsage: C = polytopes.permutahedron(7).combinatorial_polyhedron()\nsage: %time _ = C.edges()\nCPU times: user 16.1 s, sys: 0 ns, total: 16.1 s\nWall time: 16.1 s\nsage: %time _ = C.ridges()\nCPU times: user 2.35 ms, sys: 0 ns, total: 2.35 ms\nWall time: 2.36 ms\n```\n\nAfter:\n\n```\nsage: C = polytopes.hypercube(12).combinatorial_polyhedron()\nsage: %time _ = C.edges()\nCPU times: user 39.5 ms, sys: 0 ns, total: 39.5 ms\nWall time: 39.4 ms\nsage:  %time _ = C.ridges()\nCPU times: user 725 \u00b5s, sys: 60 \u00b5s, total: 785 \u00b5s\nWall time: 791 \u00b5s\nsage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()\nsage: %time _ = C.edges()\nCPU times: user 154 \u00b5s, sys: 12 \u00b5s, total: 166 \u00b5s\nWall time: 168 \u00b5s\nsage: %time _ = C.ridges()\nCPU times: user 1.16 ms, sys: 95 \u00b5s, total: 1.25 ms\nWall time: 1.26 ms\nsage: C = polytopes.permutahedron(7).combinatorial_polyhedron()\nsage: %time _ = C.edges()\nCPU times: user 63.2 ms, sys: 0 ns, total: 63.2 ms\nWall time: 63.2 ms\nsage: %time _ = C.ridges()\nCPU times: user 4.56 ms, sys: 0 ns, total: 4.56 ms\nWall time: 4.57 ms\n```\n\nThe heuristic isn't perfect, but if it fails, you can now select a better algorithm:\n\n```\nsage: P = polytopes.permutahedron(7) \nsage: P1 = P.stack(next(P.face_generator(1)))\nsage: %time P1.vertex_adjacency_matrix()\nCPU times: user 20.6 s, sys: 7.96 ms, total: 20.6 s\nWall time: 20.6 s\n5041 x 5041 dense matrix over Integer Ring (use the '.str()' method to see the entries)\nsage: P1 = P.stack(next(P.face_generator(1)))\nsage: %time P1.vertex_adjacency_matrix(algorithm='primal')\nCPU times: user 206 ms, sys: 16 ms, total: 222 ms\nWall time: 222 ms\n5041 x 5041 dense matrix over Integer Ring (use the '.str()' method to see the entries)\n```\n\nCC:  @tscrim @yuan-zhou\n\nBranch/Commit: 3bccc276294a25ef8106156cabfb9e1df0bdd864\n\nReviewer: Travis Scrimshaw, Yuan Zhou\n\nAuthor: Jonathan Kliem\n\nDependencies: #33644, #33646\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/33611\n\n",
    "closed_at": "2022-05-20T22:27:06Z",
    "created_at": "2022-03-31T11:01:00Z",
    "labels": [
        "component: geometry"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.7",
    "title": "Improve edges/ridges for simple/simplicial polytopes",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/33611",
    "user": "https://github.com/kliem"
}
```
In #30040 we have improved the face iterator for simple/simplicial polytopes, but have not applied this to our heuristic, whether we should find edges/ridges in dual/non-dual mode.

This is noticeable for edges of the permutahedron (and theoretically also for other edges of simple polytopes) and does not make a difference otherwise.

Before:

```
sage: C = polytopes.hypercube(12).combinatorial_polyhedron()
sage: %time _ = C.edges()
CPU times: user 86.1 ms, sys: 9 µs, total: 86.1 ms
Wall time: 86 ms
sage: %time _ = C.ridges()
CPU times: user 617 µs, sys: 3 µs, total: 620 µs
Wall time: 622 µs
sage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()
sage: %time _ = C.edges()
CPU times: user 114 µs, sys: 0 ns, total: 114 µs
Wall time: 117 µs
sage: %time _ = C.ridges()
CPU times: user 1.09 ms, sys: 5 µs, total: 1.09 ms
Wall time: 1.1 ms
sage: C = polytopes.permutahedron(7).combinatorial_polyhedron()
sage: %time _ = C.edges()
CPU times: user 16.1 s, sys: 0 ns, total: 16.1 s
Wall time: 16.1 s
sage: %time _ = C.ridges()
CPU times: user 2.35 ms, sys: 0 ns, total: 2.35 ms
Wall time: 2.36 ms
```

After:

```
sage: C = polytopes.hypercube(12).combinatorial_polyhedron()
sage: %time _ = C.edges()
CPU times: user 39.5 ms, sys: 0 ns, total: 39.5 ms
Wall time: 39.4 ms
sage:  %time _ = C.ridges()
CPU times: user 725 µs, sys: 60 µs, total: 785 µs
Wall time: 791 µs
sage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()
sage: %time _ = C.edges()
CPU times: user 154 µs, sys: 12 µs, total: 166 µs
Wall time: 168 µs
sage: %time _ = C.ridges()
CPU times: user 1.16 ms, sys: 95 µs, total: 1.25 ms
Wall time: 1.26 ms
sage: C = polytopes.permutahedron(7).combinatorial_polyhedron()
sage: %time _ = C.edges()
CPU times: user 63.2 ms, sys: 0 ns, total: 63.2 ms
Wall time: 63.2 ms
sage: %time _ = C.ridges()
CPU times: user 4.56 ms, sys: 0 ns, total: 4.56 ms
Wall time: 4.57 ms
```

The heuristic isn't perfect, but if it fails, you can now select a better algorithm:

```
sage: P = polytopes.permutahedron(7) 
sage: P1 = P.stack(next(P.face_generator(1)))
sage: %time P1.vertex_adjacency_matrix()
CPU times: user 20.6 s, sys: 7.96 ms, total: 20.6 s
Wall time: 20.6 s
5041 x 5041 dense matrix over Integer Ring (use the '.str()' method to see the entries)
sage: P1 = P.stack(next(P.face_generator(1)))
sage: %time P1.vertex_adjacency_matrix(algorithm='primal')
CPU times: user 206 ms, sys: 16 ms, total: 222 ms
Wall time: 222 ms
5041 x 5041 dense matrix over Integer Ring (use the '.str()' method to see the entries)
```

CC:  @tscrim @yuan-zhou

Branch/Commit: 3bccc276294a25ef8106156cabfb9e1df0bdd864

Reviewer: Travis Scrimshaw, Yuan Zhou

Author: Jonathan Kliem

Dependencies: #33644, #33646

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/33611





---

archive/issue_comments_507548.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2022-03-31T11:26:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507548",
    "user": "https://github.com/kliem"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_507549.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,51 @@\n In #30040 we have improved the face iterator for simple/simplicial polytopes, but have not applied this to our heuristic, whether we should find edges/ridges in dual/non-dual mode.\n+\n+This is noticeable for edges of the permutahedron (and theoretically also for other edges of simple polytopes) and does not make a difference otherwise.\n+\n+Before:\n+\n+```\n+sage: C = polytopes.hypercube(12).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 86.1 ms, sys: 9 \u00b5s, total: 86.1 ms\n+Wall time: 86 ms\n+sage: %time _ = C.ridges()\n+CPU times: user 617 \u00b5s, sys: 3 \u00b5s, total: 620 \u00b5s\n+Wall time: 622 \u00b5s\n+sage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 114 \u00b5s, sys: 0 ns, total: 114 \u00b5s\n+Wall time: 117 \u00b5s\n+sage: %time _ = C.ridges()\n+CPU times: user 1.09 ms, sys: 5 \u00b5s, total: 1.09 ms\n+Wall time: 1.1 ms\n+sage: C = polytopes.permutahedron(7).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 16.1 s, sys: 0 ns, total: 16.1 s\n+Wall time: 16.1 s\n+sage: %time _ = C.ridges()\n+CPU times: user 2.35 ms, sys: 0 ns, total: 2.35 ms\n+Wall time: 2.36 ms\n+```\n+\n+After:\n+\n+```\n+sage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 120 \u00b5s, sys: 1 \u00b5s, total: 121 \u00b5s\n+Wall time: 124 \u00b5s\n+sage: %time _ = C.ridges()\n+CPU times: user 1.12 ms, sys: 13 \u00b5s, total: 1.13 ms\n+Wall time: 1.13 ms\n+sage: C = polytopes.permutahedron(7).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 14.9 ms, sys: 32 \u00b5s, total: 14.9 ms\n+Wall time: 15 ms\n+sage: %time _ = C.ridges()\n+CPU times: user 2.41 ms, sys: 0 ns, total: 2.41 ms\n+Wall time: 2.41 ms\n+```\n \n Author: Jonathan Kliem\n \n``````\n",
    "created_at": "2022-03-31T11:26:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507549",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,51 @@
 In #30040 we have improved the face iterator for simple/simplicial polytopes, but have not applied this to our heuristic, whether we should find edges/ridges in dual/non-dual mode.
+
+This is noticeable for edges of the permutahedron (and theoretically also for other edges of simple polytopes) and does not make a difference otherwise.
+
+Before:
+
+```
+sage: C = polytopes.hypercube(12).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 86.1 ms, sys: 9 µs, total: 86.1 ms
+Wall time: 86 ms
+sage: %time _ = C.ridges()
+CPU times: user 617 µs, sys: 3 µs, total: 620 µs
+Wall time: 622 µs
+sage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 114 µs, sys: 0 ns, total: 114 µs
+Wall time: 117 µs
+sage: %time _ = C.ridges()
+CPU times: user 1.09 ms, sys: 5 µs, total: 1.09 ms
+Wall time: 1.1 ms
+sage: C = polytopes.permutahedron(7).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 16.1 s, sys: 0 ns, total: 16.1 s
+Wall time: 16.1 s
+sage: %time _ = C.ridges()
+CPU times: user 2.35 ms, sys: 0 ns, total: 2.35 ms
+Wall time: 2.36 ms
+```
+
+After:
+
+```
+sage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 120 µs, sys: 1 µs, total: 121 µs
+Wall time: 124 µs
+sage: %time _ = C.ridges()
+CPU times: user 1.12 ms, sys: 13 µs, total: 1.13 ms
+Wall time: 1.13 ms
+sage: C = polytopes.permutahedron(7).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 14.9 ms, sys: 32 µs, total: 14.9 ms
+Wall time: 15 ms
+sage: %time _ = C.ridges()
+CPU times: user 2.41 ms, sys: 0 ns, total: 2.41 ms
+Wall time: 2.41 ms
+```
 
 Author: Jonathan Kliem
 
``````




---

archive/issue_comments_507550.json:
```json
{
    "body": "<a id='comment:2'></a>New commits:",
    "created_at": "2022-03-31T11:32:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507550",
    "user": "https://github.com/kliem"
}
```

<a id='comment:2'></a>New commits:



---

archive/issue_comments_507551.json:
```json
{
    "body": "<a id='comment:5'></a>Maybe irrelevant to this ticket, but are there better criteria than n_Vrepresentation > (n_facets)<sup>2</sup>  (or n_Vrepresentation<sup>2</sup> < n_facets) in which cases one knows that the primal (or the dual) algorithm is faster?\n\n\"Wild estimates\" plus special treatment for simple/simplicial polytopes does not seem optimal to me. \n\nIf we don't know a better criterion, does it make sense to leave the choice to the user, as an optional input?",
    "created_at": "2022-03-31T18:32:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507551",
    "user": "https://github.com/yuan-zhou"
}
```

<a id='comment:5'></a>Maybe irrelevant to this ticket, but are there better criteria than n_Vrepresentation > (n_facets)<sup>2</sup>  (or n_Vrepresentation<sup>2</sup> < n_facets) in which cases one knows that the primal (or the dual) algorithm is faster?

"Wild estimates" plus special treatment for simple/simplicial polytopes does not seem optimal to me. 

If we don't know a better criterion, does it make sense to leave the choice to the user, as an optional input?



---

archive/issue_comments_507552.json:
```json
{
    "body": "<a id='comment:6'></a>I also think it would be good to answer that question and +1 for adding an option for the user to select. However, that can be left to another ticket.\n\nFor the change in this ticket. LGTM modulo the order of the checks. How expensive is the `is_simple()` compared to the other and how frequently do you expect it to get to that test? This is quite a micro-optimization, so if you don't want to be bothered with it, you can set a positive review.",
    "created_at": "2022-04-01T06:25:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507552",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>I also think it would be good to answer that question and +1 for adding an option for the user to select. However, that can be left to another ticket.

For the change in this ticket. LGTM modulo the order of the checks. How expensive is the `is_simple()` compared to the other and how frequently do you expect it to get to that test? This is quite a micro-optimization, so if you don't want to be bothered with it, you can set a positive review.



---

archive/issue_comments_507553.json:
```json
{
    "body": "<a id='comment:7'></a>I think it is a good idea to expose the primal/dual or automatic options. I really don't know, when the algorithm is faster which way. Like I know for fixed polyhedra, but I have no clue in general. It is surprising how the primal algorithm even to generate edges is much better than the dual algorithm in many cases.\n\nWhat do you think is better:\n- a keyword `algorithm`, with options `'primal'`, `'dual'` or `None` or\n- a kewword `dual` with options `True`, `False` and `None`?\n\nAt the moment the `Polyhedron_base` method `face_generator` already exposes the keyword dual. But if this is not intuitive we should maybe switch to `algorithm=` instead.",
    "created_at": "2022-04-01T11:09:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507553",
    "user": "https://github.com/kliem"
}
```

<a id='comment:7'></a>I think it is a good idea to expose the primal/dual or automatic options. I really don't know, when the algorithm is faster which way. Like I know for fixed polyhedra, but I have no clue in general. It is surprising how the primal algorithm even to generate edges is much better than the dual algorithm in many cases.

What do you think is better:
- a keyword `algorithm`, with options `'primal'`, `'dual'` or `None` or
- a kewword `dual` with options `True`, `False` and `None`?

At the moment the `Polyhedron_base` method `face_generator` already exposes the keyword dual. But if this is not intuitive we should maybe switch to `algorithm=` instead.



---

archive/issue_comments_507554.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2022-04-01T11:09:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507554",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_507555.json:
```json
{
    "body": "<a id='comment:9'></a>`is_simple()` is not cached (but could be). It has complexity of the incidence matrix, which is worse than the other checks, which are pretty much constant at this stuff needs to be computed anyway.\n\nMaybe it makes sense to cache `is_simple`:\n\n```\nsage: C = polytopes.hypercube(12).combinatorial_polyhedron()\nsage: %timeit C.is_simple()\n24.5 \u00b5s \u00b1 1.72 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\nsage: %time C.f_vector()\nCPU times: user 253 ms, sys: 11.7 ms, total: 265 ms\nWall time: 187 ms\n(1, 4096, 24576, 67584, 112640, 126720, 101376, 59136, 25344, 7920, 1760, 264, 24, 1)\n```\n\nAs for the complexity of the primal and dual algorithm (for edges):\n\n- The dual algorithm takes about `n_Vrepresentation ** 3 * n_facets`.\n- The primal algorithm in in the non-simple case takes `sum(f_vector) * n_facets ** 2 * n_Vrepresentation`.\n- The primal algorithm in in the simple case takes `sum(f_vector) * n_facets * n_Vrepresentation`.\n\nTo estimate `sum(f_vector)` one can use the upper bound theorem. I came up with something in the complexity of `dimension * binomial(min(n_facets, n_Vrepresentation), dimension // 2)`.\n\nOne could use those things to get a better estimate, but I don't know if this would be any good. Exposing the algorithm might be the better choice here.",
    "created_at": "2022-04-01T11:44:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507555",
    "user": "https://github.com/kliem"
}
```

<a id='comment:9'></a>`is_simple()` is not cached (but could be). It has complexity of the incidence matrix, which is worse than the other checks, which are pretty much constant at this stuff needs to be computed anyway.

Maybe it makes sense to cache `is_simple`:

```
sage: C = polytopes.hypercube(12).combinatorial_polyhedron()
sage: %timeit C.is_simple()
24.5 µs ± 1.72 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
sage: %time C.f_vector()
CPU times: user 253 ms, sys: 11.7 ms, total: 265 ms
Wall time: 187 ms
(1, 4096, 24576, 67584, 112640, 126720, 101376, 59136, 25344, 7920, 1760, 264, 24, 1)
```

As for the complexity of the primal and dual algorithm (for edges):

- The dual algorithm takes about `n_Vrepresentation ** 3 * n_facets`.
- The primal algorithm in in the non-simple case takes `sum(f_vector) * n_facets ** 2 * n_Vrepresentation`.
- The primal algorithm in in the simple case takes `sum(f_vector) * n_facets * n_Vrepresentation`.

To estimate `sum(f_vector)` one can use the upper bound theorem. I came up with something in the complexity of `dimension * binomial(min(n_facets, n_Vrepresentation), dimension // 2)`.

One could use those things to get a better estimate, but I don't know if this would be any good. Exposing the algorithm might be the better choice here.



---

archive/issue_comments_507556.json:
```json
{
    "body": "<a id='comment:10'></a>Thank you for providing the complexity details! The formulas look very neat. I think it would be nice to use them in the code, especially when `_f_vector` was cached, because otherwise the users are unlikely to know such things.\n\nI like the keyword `dual` with options `True`, `False` and `None`.  \n\n+1 for caching `is_simple` and `is_simplicial`.\n\n+1 for \"This is quite a micro-optimization, so if you don't want to be bothered with it, you can set a positive review.\"",
    "created_at": "2022-04-01T14:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507556",
    "user": "https://github.com/yuan-zhou"
}
```

<a id='comment:10'></a>Thank you for providing the complexity details! The formulas look very neat. I think it would be nice to use them in the code, especially when `_f_vector` was cached, because otherwise the users are unlikely to know such things.

I like the keyword `dual` with options `True`, `False` and `None`.  

+1 for caching `is_simple` and `is_simplicial`.

+1 for "This is quite a micro-optimization, so if you don't want to be bothered with it, you can set a positive review."



---

archive/issue_comments_507557.json:
```json
{
    "body": "<a id='comment:11'></a>comment:7: I would use `algorithm` as it is more flexible for the future.\n\ncomment:9: Thank you. I agree with Yuan that they should be cached. From what you're saying, I agree that they should be last in the checking order. Could there be a typo in your formulas? I don't understand what `***` is. Perhaps this is my na\u00efvity, but aren't facets in bijection with a minimal number of hyperplanes defining the polytope? Then I would expect the dual algorithm to almost always be the faster algorithm since squares grow much slow than binomials (after dividing by common factors). Unless the `sum(f_vector)` grows much slower than the upper bound theorem implies. (Sorry if these are more basic facts you need to explain to me; it's been a little while since I have done anything nontrivial in this area).",
    "created_at": "2022-04-04T00:28:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507557",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:11'></a>comment:7: I would use `algorithm` as it is more flexible for the future.

comment:9: Thank you. I agree with Yuan that they should be cached. From what you're saying, I agree that they should be last in the checking order. Could there be a typo in your formulas? I don't understand what `***` is. Perhaps this is my naïvity, but aren't facets in bijection with a minimal number of hyperplanes defining the polytope? Then I would expect the dual algorithm to almost always be the faster algorithm since squares grow much slow than binomials (after dividing by common factors). Unless the `sum(f_vector)` grows much slower than the upper bound theorem implies. (Sorry if these are more basic facts you need to explain to me; it's been a little while since I have done anything nontrivial in this area).



---

archive/issue_comments_507558.json:
```json
{
    "body": "<a id='comment:13'></a>Replying to [comment:11 tscrim]:\n> comment:7: I would use `algorithm` as it is more flexible for the future.\n\n\nI also think this is a better name, but it involves deprecation. But well, that's life I guess.\n> \n> comment:9: Thank you. I agree with Yuan that they should be cached. From what you're saying, I agree that they should be last in the checking order. Could there be a typo in your formulas?\n\n\n> I don't understand what `***` is.\n\n\nA typo, fixed now. Also the simple/simplical complexity had a typo.\n\n> Perhaps this is my na\u00efvity, but aren't facets in bijection with a minimal number of hyperplanes defining the polytope? Then I would expect the dual algorithm to almost always be the faster algorithm since squares grow much slow than binomials (after dividing by common factors). Unless the `sum(f_vector)` grows much slower than the upper bound theorem implies. (Sorry if these are more basic facts you need to explain to me; it's been a little while since I have done anything nontrivial in this area).\n\n\nA couple of simple/simplicial examples:\n\n```\nsage: C = polytopes.hypercube(10).combinatorial_polyhedron()\nsage: C.f_vector()\n(1, 1024, 5120, 11520, 15360, 13440, 8064, 3360, 960, 180, 20, 1)\nsage: %time sum(1 for _ in C.face_iter(1, dual=True))\nCPU times: user 175 ms, sys: 0 ns, total: 175 ms\nWall time: 175 ms\n5120\nsage: %time sum(1 for _ in C.face_iter(1, dual=False))\nCPU times: user 3.71 ms, sys: 0 ns, total: 3.71 ms\nWall time: 3.71 ms\n5120\nsage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual\n21474836480\nsage: sum(C.f_vector()) * C.n_facets() * C.n_vertices()  # complexity primal\n1209344000\n```\n\n```\nsage: C = polytopes.hypercube(12).combinatorial_polyhedron()\nsage: C.f_vector()\n(1, 4096, 24576, 67584, 112640, 126720, 101376, 59136, 25344, 7920, 1760, 264, 24, 1)\nsage: %time sum(1 for _ in C.face_iter(1, dual=True))\nCPU times: user 9.89 s, sys: 154 \u00b5s, total: 9.89 s\nWall time: 9.89 s\n24576\nsage: %time sum(1 for _ in C.face_iter(1, dual=False))\nCPU times: user 36.7 ms, sys: 0 ns, total: 36.7 ms\nWall time: 36.3 ms\n24576\nsage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual\n1649267441664\nsage: sum(C.f_vector()) * C.n_facets() * C.n_vertices()  # complexity primal\n52242874368\n```\n\n```\nsage: C = polytopes.cyclic_polytope(10, 20).combinatorial_polyhedron()\nsage: C = C.polar()\nsage: C.f_vector()\n(1, 4004, 20020, 42315, 49140, 34470, 15504, 4845, 1140, 190, 20, 1)\nsage: %time sum(1 for _ in C.face_iter(1, dual=True))\nCPU times: user 9.55 s, sys: 18 \u00b5s, total: 9.55 s\nWall time: 9.55 s\n20020\nsage: %time sum(1 for _ in C.face_iter(1, dual=False))\nCPU times: user 19.9 ms, sys: 0 ns, total: 19.9 ms\nWall time: 19.8 ms\n20020\nsage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual\n1283843841280\nsage: sum(C.f_vector()) * C.n_facets() * C.n_vertices()  # complexity primal\n13745732000\n```\n\nA non-simple and non-simplicial case:\n\n```\nsage: P = polytopes.permutahedron(7) \nsage: P1 = P.stack(next(P.face_generator(1)))\nsage: C = CombinatorialPolyhedron(P1)\nsage: %time C.f_vector()\nCPU times: user 184 ms, sys: 0 ns, total: 184 ms\nWall time: 28.9 ms\n(1, 5041, 16251, 19761, 11144, 2860, 267, 1)\nsage: %time sum(1 for _ in C.face_iter(1, dual=True))\nCPU times: user 20.1 s, sys: 0 ns, total: 20.1 s\nWall time: 20.1 s\n16251\nsage: %time sum(1 for _ in C.face_iter(1, dual=False))\nCPU times: user 28.1 ms, sys: 0 ns, total: 28.1 ms\nWall time: 27.9 ms\n16251\nsage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual\n34202775806907\nsage: sum(C.f_vector()) * C.n_facets() ** 2 * C.n_vertices()  # complexity primal\n19882385613774\n```\n\nNote that the primal algorithm appears to be much better than our estimate. The reason is that the farther we go into the tree, the better the actual runtime will differ from the worst case scenario.\n\nI also find the runtimes quite counter-intuitive. It seems that obtaining the f-vector of a simple/simplicial polytope with this iterator is much better than using the h-vector method.",
    "created_at": "2022-04-05T08:05:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507558",
    "user": "https://github.com/kliem"
}
```

<a id='comment:13'></a>Replying to [comment:11 tscrim]:
> comment:7: I would use `algorithm` as it is more flexible for the future.


I also think this is a better name, but it involves deprecation. But well, that's life I guess.
> 
> comment:9: Thank you. I agree with Yuan that they should be cached. From what you're saying, I agree that they should be last in the checking order. Could there be a typo in your formulas?


> I don't understand what `***` is.


A typo, fixed now. Also the simple/simplical complexity had a typo.

> Perhaps this is my naïvity, but aren't facets in bijection with a minimal number of hyperplanes defining the polytope? Then I would expect the dual algorithm to almost always be the faster algorithm since squares grow much slow than binomials (after dividing by common factors). Unless the `sum(f_vector)` grows much slower than the upper bound theorem implies. (Sorry if these are more basic facts you need to explain to me; it's been a little while since I have done anything nontrivial in this area).


A couple of simple/simplicial examples:

```
sage: C = polytopes.hypercube(10).combinatorial_polyhedron()
sage: C.f_vector()
(1, 1024, 5120, 11520, 15360, 13440, 8064, 3360, 960, 180, 20, 1)
sage: %time sum(1 for _ in C.face_iter(1, dual=True))
CPU times: user 175 ms, sys: 0 ns, total: 175 ms
Wall time: 175 ms
5120
sage: %time sum(1 for _ in C.face_iter(1, dual=False))
CPU times: user 3.71 ms, sys: 0 ns, total: 3.71 ms
Wall time: 3.71 ms
5120
sage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual
21474836480
sage: sum(C.f_vector()) * C.n_facets() * C.n_vertices()  # complexity primal
1209344000
```

```
sage: C = polytopes.hypercube(12).combinatorial_polyhedron()
sage: C.f_vector()
(1, 4096, 24576, 67584, 112640, 126720, 101376, 59136, 25344, 7920, 1760, 264, 24, 1)
sage: %time sum(1 for _ in C.face_iter(1, dual=True))
CPU times: user 9.89 s, sys: 154 µs, total: 9.89 s
Wall time: 9.89 s
24576
sage: %time sum(1 for _ in C.face_iter(1, dual=False))
CPU times: user 36.7 ms, sys: 0 ns, total: 36.7 ms
Wall time: 36.3 ms
24576
sage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual
1649267441664
sage: sum(C.f_vector()) * C.n_facets() * C.n_vertices()  # complexity primal
52242874368
```

```
sage: C = polytopes.cyclic_polytope(10, 20).combinatorial_polyhedron()
sage: C = C.polar()
sage: C.f_vector()
(1, 4004, 20020, 42315, 49140, 34470, 15504, 4845, 1140, 190, 20, 1)
sage: %time sum(1 for _ in C.face_iter(1, dual=True))
CPU times: user 9.55 s, sys: 18 µs, total: 9.55 s
Wall time: 9.55 s
20020
sage: %time sum(1 for _ in C.face_iter(1, dual=False))
CPU times: user 19.9 ms, sys: 0 ns, total: 19.9 ms
Wall time: 19.8 ms
20020
sage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual
1283843841280
sage: sum(C.f_vector()) * C.n_facets() * C.n_vertices()  # complexity primal
13745732000
```

A non-simple and non-simplicial case:

```
sage: P = polytopes.permutahedron(7) 
sage: P1 = P.stack(next(P.face_generator(1)))
sage: C = CombinatorialPolyhedron(P1)
sage: %time C.f_vector()
CPU times: user 184 ms, sys: 0 ns, total: 184 ms
Wall time: 28.9 ms
(1, 5041, 16251, 19761, 11144, 2860, 267, 1)
sage: %time sum(1 for _ in C.face_iter(1, dual=True))
CPU times: user 20.1 s, sys: 0 ns, total: 20.1 s
Wall time: 20.1 s
16251
sage: %time sum(1 for _ in C.face_iter(1, dual=False))
CPU times: user 28.1 ms, sys: 0 ns, total: 28.1 ms
Wall time: 27.9 ms
16251
sage: C.n_vertices() ** 3 * C.n_facets()  # complexity dual
34202775806907
sage: sum(C.f_vector()) * C.n_facets() ** 2 * C.n_vertices()  # complexity primal
19882385613774
```

Note that the primal algorithm appears to be much better than our estimate. The reason is that the farther we go into the tree, the better the actual runtime will differ from the worst case scenario.

I also find the runtimes quite counter-intuitive. It seems that obtaining the f-vector of a simple/simplicial polytope with this iterator is much better than using the h-vector method.



---

archive/issue_comments_507559.json:
```json
{
    "body": "<a id='comment:14'></a>On the internal function, having it be an `int` is much faster than a `string` for checking cases. You can also change that without any deprecation.\n\nThank you for the timings. I don't really have any intuition for what should be faster. So I won't be much help and will simply defer to your (and Yuan's) judgement.",
    "created_at": "2022-04-05T09:04:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507559",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:14'></a>On the internal function, having it be an `int` is much faster than a `string` for checking cases. You can also change that without any deprecation.

Thank you for the timings. I don't really have any intuition for what should be faster. So I won't be much help and will simply defer to your (and Yuan's) judgement.



---

archive/issue_comments_507560.json:
```json
{
    "body": "<a id='comment:16'></a>Replying to [comment:14 tscrim]:\n> On the internal function, having it be an `int` is much faster than a `string` for checking cases. You can also change that without any deprecation.\n> \n> Thank you for the timings. I don't really have any intuition for what should be faster. So I won't be much help and will simply defer to your (and Yuan's) judgement.\n\n\nIn #33646 I propose to use the keyword `algorithm` and `face_generator` over `face_iter`, but without deprecation.\n\nThe problem with exponential size is the following: Given a polytope as finite intersection of closed halfspaces. The number of vertices can be expected to be exponential with respect to the number of facets.\n\nHowever, if you have a non-simple and non-simplicial polytope things might be a lot different. Those polytopes are less-generic but certainly more interesting.",
    "created_at": "2022-04-05T10:10:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507560",
    "user": "https://github.com/kliem"
}
```

<a id='comment:16'></a>Replying to [comment:14 tscrim]:
> On the internal function, having it be an `int` is much faster than a `string` for checking cases. You can also change that without any deprecation.
> 
> Thank you for the timings. I don't really have any intuition for what should be faster. So I won't be much help and will simply defer to your (and Yuan's) judgement.


In #33646 I propose to use the keyword `algorithm` and `face_generator` over `face_iter`, but without deprecation.

The problem with exponential size is the following: Given a polytope as finite intersection of closed halfspaces. The number of vertices can be expected to be exponential with respect to the number of facets.

However, if you have a non-simple and non-simplicial polytope things might be a lot different. Those polytopes are less-generic but certainly more interesting.



---

archive/issue_comments_507561.json:
```json
{
    "body": "<a id='comment:17'></a>New commits:",
    "created_at": "2022-04-07T15:33:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507561",
    "user": "https://github.com/kliem"
}
```

<a id='comment:17'></a>New commits:



---

archive/issue_comments_507562.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2022-04-07T15:33:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507562",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_507563.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,74 @@\n+In #30040 we have improved the face iterator for simple/simplicial polytopes, but have not applied this to our heuristic, whether we should find edges/ridges in dual/non-dual mode.\n \n+This is noticeable for edges of the permutahedron (and theoretically also for other edges of simple polytopes) and does not make a difference otherwise.\n+\n+Before:\n+\n+```\n+sage: C = polytopes.hypercube(12).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 86.1 ms, sys: 9 \u00b5s, total: 86.1 ms\n+Wall time: 86 ms\n+sage: %time _ = C.ridges()\n+CPU times: user 617 \u00b5s, sys: 3 \u00b5s, total: 620 \u00b5s\n+Wall time: 622 \u00b5s\n+sage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 114 \u00b5s, sys: 0 ns, total: 114 \u00b5s\n+Wall time: 117 \u00b5s\n+sage: %time _ = C.ridges()\n+CPU times: user 1.09 ms, sys: 5 \u00b5s, total: 1.09 ms\n+Wall time: 1.1 ms\n+sage: C = polytopes.permutahedron(7).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 16.1 s, sys: 0 ns, total: 16.1 s\n+Wall time: 16.1 s\n+sage: %time _ = C.ridges()\n+CPU times: user 2.35 ms, sys: 0 ns, total: 2.35 ms\n+Wall time: 2.36 ms\n+```\n+\n+After:\n+\n+```\n+sage: C = polytopes.hypercube(12).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 39.5 ms, sys: 0 ns, total: 39.5 ms\n+Wall time: 39.4 ms\n+sage:  %time _ = C.ridges()\n+CPU times: user 725 \u00b5s, sys: 60 \u00b5s, total: 785 \u00b5s\n+Wall time: 791 \u00b5s\n+sage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 154 \u00b5s, sys: 12 \u00b5s, total: 166 \u00b5s\n+Wall time: 168 \u00b5s\n+sage: %time _ = C.ridges()\n+CPU times: user 1.16 ms, sys: 95 \u00b5s, total: 1.25 ms\n+Wall time: 1.26 ms\n+sage: C = polytopes.permutahedron(7).combinatorial_polyhedron()\n+sage: %time _ = C.edges()\n+CPU times: user 63.2 ms, sys: 0 ns, total: 63.2 ms\n+Wall time: 63.2 ms\n+sage: %time _ = C.ridges()\n+CPU times: user 4.56 ms, sys: 0 ns, total: 4.56 ms\n+Wall time: 4.57 ms\n+```\n+\n+The heuristic isn't perfect, but if it fails, you can now select a better algorithm:\n+\n+```\n+sage: P = polytopes.permutahedron(7) \n+sage: P1 = P.stack(next(P.face_generator(1)))\n+sage: %time P1.vertex_adjacency_matrix()\n+CPU times: user 20.6 s, sys: 7.96 ms, total: 20.6 s\n+Wall time: 20.6 s\n+5041 x 5041 dense matrix over Integer Ring (use the '.str()' method to see the entries)\n+sage: P1 = P.stack(next(P.face_generator(1)))\n+sage: %time P1.vertex_adjacency_matrix(algorithm='primal')\n+CPU times: user 206 ms, sys: 16 ms, total: 222 ms\n+Wall time: 222 ms\n+5041 x 5041 dense matrix over Integer Ring (use the '.str()' method to see the entries)\n+```\n \n Author: Jonathan Kliem\n \n``````\n",
    "created_at": "2022-04-07T15:33:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507563",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,74 @@
+In #30040 we have improved the face iterator for simple/simplicial polytopes, but have not applied this to our heuristic, whether we should find edges/ridges in dual/non-dual mode.
 
+This is noticeable for edges of the permutahedron (and theoretically also for other edges of simple polytopes) and does not make a difference otherwise.
+
+Before:
+
+```
+sage: C = polytopes.hypercube(12).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 86.1 ms, sys: 9 µs, total: 86.1 ms
+Wall time: 86 ms
+sage: %time _ = C.ridges()
+CPU times: user 617 µs, sys: 3 µs, total: 620 µs
+Wall time: 622 µs
+sage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 114 µs, sys: 0 ns, total: 114 µs
+Wall time: 117 µs
+sage: %time _ = C.ridges()
+CPU times: user 1.09 ms, sys: 5 µs, total: 1.09 ms
+Wall time: 1.1 ms
+sage: C = polytopes.permutahedron(7).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 16.1 s, sys: 0 ns, total: 16.1 s
+Wall time: 16.1 s
+sage: %time _ = C.ridges()
+CPU times: user 2.35 ms, sys: 0 ns, total: 2.35 ms
+Wall time: 2.36 ms
+```
+
+After:
+
+```
+sage: C = polytopes.hypercube(12).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 39.5 ms, sys: 0 ns, total: 39.5 ms
+Wall time: 39.4 ms
+sage:  %time _ = C.ridges()
+CPU times: user 725 µs, sys: 60 µs, total: 785 µs
+Wall time: 791 µs
+sage: C = polytopes.cyclic_polytope(6, 20).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 154 µs, sys: 12 µs, total: 166 µs
+Wall time: 168 µs
+sage: %time _ = C.ridges()
+CPU times: user 1.16 ms, sys: 95 µs, total: 1.25 ms
+Wall time: 1.26 ms
+sage: C = polytopes.permutahedron(7).combinatorial_polyhedron()
+sage: %time _ = C.edges()
+CPU times: user 63.2 ms, sys: 0 ns, total: 63.2 ms
+Wall time: 63.2 ms
+sage: %time _ = C.ridges()
+CPU times: user 4.56 ms, sys: 0 ns, total: 4.56 ms
+Wall time: 4.57 ms
+```
+
+The heuristic isn't perfect, but if it fails, you can now select a better algorithm:
+
+```
+sage: P = polytopes.permutahedron(7) 
+sage: P1 = P.stack(next(P.face_generator(1)))
+sage: %time P1.vertex_adjacency_matrix()
+CPU times: user 20.6 s, sys: 7.96 ms, total: 20.6 s
+Wall time: 20.6 s
+5041 x 5041 dense matrix over Integer Ring (use the '.str()' method to see the entries)
+sage: P1 = P.stack(next(P.face_generator(1)))
+sage: %time P1.vertex_adjacency_matrix(algorithm='primal')
+CPU times: user 206 ms, sys: 16 ms, total: 222 ms
+Wall time: 222 ms
+5041 x 5041 dense matrix over Integer Ring (use the '.str()' method to see the entries)
+```
 
 Author: Jonathan Kliem
 
``````




---

archive/issue_comments_507564.json:
```json
{
    "body": "<a id='comment:18'></a>In docstring of `facet_graph`, incidences --> indices\n\n``` \nIf ``names`` is ``False``, the ``vertices`` of the graph  will\n         be the incidences of the facets in the Hrepresentation.\n```",
    "created_at": "2022-04-07T18:04:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507564",
    "user": "https://github.com/yuan-zhou"
}
```

<a id='comment:18'></a>In docstring of `facet_graph`, incidences --> indices

``` 
If ``names`` is ``False``, the ``vertices`` of the graph  will
         be the incidences of the facets in the Hrepresentation.
```



---

archive/issue_comments_507565.json:
```json
{
    "body": "<a id='comment:19'></a>In the docstring of `def edges(self, names=True, algorithm=None):`,\n` ``names`` -- boolean (default: ``True``); if ``True``, ...` --> if False ?",
    "created_at": "2022-04-07T18:13:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507565",
    "user": "https://github.com/yuan-zhou"
}
```

<a id='comment:19'></a>In the docstring of `def edges(self, names=True, algorithm=None):`,
` ``names`` -- boolean (default: ``True``); if ``True``, ...` --> if False ?



---

archive/issue_comments_507566.json:
```json
{
    "body": "<a id='comment:20'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-04-07T18:23:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507566",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:20'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_507567.json:
```json
{
    "body": "<a id='comment:21'></a>Maybe change all `face iterator` in the docstrings to `face generator` as well?",
    "created_at": "2022-04-07T18:30:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507567",
    "user": "https://github.com/yuan-zhou"
}
```

<a id='comment:21'></a>Maybe change all `face iterator` in the docstrings to `face generator` as well?



---

archive/issue_comments_507568.json:
```json
{
    "body": "<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-04-07T18:33:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507568",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_507569.json:
```json
{
    "body": "<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-04-07T18:34:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507569",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_507570.json:
```json
{
    "body": "<a id='comment:24'></a>Regarding\n\n```\n     sage: C.edges()[:2]\n-    ((A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)),\n-     (A vertex at (-1, 1, -1, -1), A vertex at (-1, -1, -1, -1)))\n+    ((A vertex at (1, -1, -1, -1), A vertex at (-1, -1, -1, -1)),\n+     (A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)))\n     sage: C.edges(names=False)[:2]\n-    ((14, 15), (10, 15))\n+    ((6, 15), (14, 15))\n```\nAre the vertices and facets of a `CombinatorialPolyhedron` always stored in a fixed order? \nI vaguely recall that there was an ordering problem for the representations of a `Polyhedron` with different backends. I'm not sure if this is relevant here.\n\n---\nNew commits:",
    "created_at": "2022-04-07T18:43:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507570",
    "user": "https://github.com/yuan-zhou"
}
```

<a id='comment:24'></a>Regarding

```
     sage: C.edges()[:2]
-    ((A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)),
-     (A vertex at (-1, 1, -1, -1), A vertex at (-1, -1, -1, -1)))
+    ((A vertex at (1, -1, -1, -1), A vertex at (-1, -1, -1, -1)),
+     (A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)))
     sage: C.edges(names=False)[:2]
-    ((14, 15), (10, 15))
+    ((6, 15), (14, 15))
```
Are the vertices and facets of a `CombinatorialPolyhedron` always stored in a fixed order? 
I vaguely recall that there was an ordering problem for the representations of a `Polyhedron` with different backends. I'm not sure if this is relevant here.

---
New commits:



---

archive/issue_comments_507571.json:
```json
{
    "body": "<a id='comment:25'></a>Replying to [comment:24 yzh]:\n> Regarding\n> \n> ```\n>      sage: C.edges()[:2]\n> -    ((A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)),\n> -     (A vertex at (-1, 1, -1, -1), A vertex at (-1, -1, -1, -1)))\n> +    ((A vertex at (1, -1, -1, -1), A vertex at (-1, -1, -1, -1)),\n> +     (A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)))\n>      sage: C.edges(names=False)[:2]\n> -    ((14, 15), (10, 15))\n> +    ((6, 15), (14, 15))\n> ```\n> Are the vertices and facets of a `CombinatorialPolyhedron` always stored in a fixed order? \n> I vaguely recall that there was an ordering problem for the representations of a `Polyhedron` with different backends. I'm not sure if this is relevant here.\n> \n> ---\n> New commits:\n> |                                                                                                                                          |                                           |\n> |------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------|\n> |[f986979](https://git.sagemath.org/sage.git/commit?id=f986979ad764084fcf43050bb4fa5e8a9ebb1807)|`use \"face generator\" in the documentation`|\n> |[3bccc27](https://git.sagemath.org/sage.git/commit?id=3bccc276294a25ef8106156cabfb9e1df0bdd864)|`fix documentation error`|\n\n\nThe order of Vrepresentation and Hrepresentation is taken from the input and is then fixed.\nWhat is happening here is that the default algorithm for the edges changed and then this changed the order edges.",
    "created_at": "2022-04-07T18:47:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507571",
    "user": "https://github.com/kliem"
}
```

<a id='comment:25'></a>Replying to [comment:24 yzh]:
> Regarding
> 
> ```
>      sage: C.edges()[:2]
> -    ((A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)),
> -     (A vertex at (-1, 1, -1, -1), A vertex at (-1, -1, -1, -1)))
> +    ((A vertex at (1, -1, -1, -1), A vertex at (-1, -1, -1, -1)),
> +     (A vertex at (-1, -1, -1, 1), A vertex at (-1, -1, -1, -1)))
>      sage: C.edges(names=False)[:2]
> -    ((14, 15), (10, 15))
> +    ((6, 15), (14, 15))
> ```
> Are the vertices and facets of a `CombinatorialPolyhedron` always stored in a fixed order? 
> I vaguely recall that there was an ordering problem for the representations of a `Polyhedron` with different backends. I'm not sure if this is relevant here.
> 
> ---
> New commits:
> |                                                                                                                                          |                                           |
> |------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------|
> |[f986979](https://git.sagemath.org/sage.git/commit?id=f986979ad764084fcf43050bb4fa5e8a9ebb1807)|`use "face generator" in the documentation`|
> |[3bccc27](https://git.sagemath.org/sage.git/commit?id=3bccc276294a25ef8106156cabfb9e1df0bdd864)|`fix documentation error`|


The order of Vrepresentation and Hrepresentation is taken from the input and is then fixed.
What is happening here is that the default algorithm for the edges changed and then this changed the order edges.



---

archive/issue_comments_507572.json:
```json
{
    "body": "<a id='comment:26'></a>Thank you very much! All looks good to me. \n\n`@`tscrim: Would you mind taking a look at the Patchbot failing? (I don't understand it.)",
    "created_at": "2022-04-07T18:55:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507572",
    "user": "https://github.com/yuan-zhou"
}
```

<a id='comment:26'></a>Thank you very much! All looks good to me. 

`@`tscrim: Would you mind taking a look at the Patchbot failing? (I don't understand it.)



---

archive/issue_comments_507573.json:
```json
{
    "body": "<a id='comment:27'></a>At the moment there is only one failure and looks like a `mathematica` time out, so unrelated.",
    "created_at": "2022-04-07T19:36:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507573",
    "user": "https://github.com/kliem"
}
```

<a id='comment:27'></a>At the moment there is only one failure and looks like a `mathematica` time out, so unrelated.



---

archive/issue_comments_507574.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2022-04-07T23:20:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507574",
    "user": "https://github.com/yuan-zhou"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_507575.json:
```json
{
    "body": "<a id='comment:29'></a>Indeed, it is unrelated. The latest patchbot run also came back morally green as well.",
    "created_at": "2022-04-08T00:05:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507575",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:29'></a>Indeed, it is unrelated. The latest patchbot run also came back morally green as well.



---

archive/issue_comments_507576.json:
```json
{
    "body": "<a id='comment:30'></a>Thank you.",
    "created_at": "2022-04-08T04:46:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507576",
    "user": "https://github.com/kliem"
}
```

<a id='comment:30'></a>Thank you.



---

archive/issue_events_088420.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-07T18:42:13Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33611#event-88420"
}
```



---

archive/issue_events_088421.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2022-05-20T22:27:06Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33611#event-88421"
}
```



---

archive/issue_comments_507577.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2022-05-20T22:27:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33611",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33611#issuecomment-507577",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
