# Issue 28498: Lattice Polytopes: Obtain facets directly from facet_normals

Issue created by migration from https://trac.sagemath.org/ticket/28735

Original creator: @kliem

Original creation time: 2019-11-14 13:05:24

CC:  jipilab @laisrast

Keywords: lattice polytopes, facets

We improve the method `facets` of lattice polytopes to be obtained directly from the facet normals.

Before, this method implicitly computed the face lattice and then obtained the codimension 1 faces of the face lattice.

Timings before:

```
sage: o = lattice_polytope.cross_polytope(5)
sage: %time _ = o.facets()
CPU times: user 24.8 ms, sys: 4.13 ms, total: 28.9 ms
Wall time: 26.8 ms
sage: o = lattice_polytope.cross_polytope(7)
sage: %time _ = o.facets()
CPU times: user 302 ms, sys: 4.04 ms, total: 306 ms
Wall time: 288 ms
sage: o = lattice_polytope.cross_polytope(10)
sage: %time _ = o.facets()
CPU times: user 16.2 s, sys: 70.6 ms, total: 16.3 s
Wall time: 16.3 s
```


Timings with this ticket:

```
sage: o = lattice_polytope.cross_polytope(5)
sage: %time _ = o.facets()
CPU times: user 2.29 ms, sys: 0 ns, total: 2.29 ms
Wall time: 1.97 ms
sage: o = lattice_polytope.cross_polytope(7)
sage: %time _ = o.facets()
CPU times: user 5.76 ms, sys: 0 ns, total: 5.76 ms
Wall time: 5.22 ms
sage: o = lattice_polytope.cross_polytope(10)
sage: %time _ = o.facets()
CPU times: user 45.1 ms, sys: 4.7 ms, total: 49.8 ms
Wall time: 46.2 ms
```


Remark: This makes `CombinatorialPolyhedron` useful for lattice polytopes, as it is obtained from the method `facets`. Currently the entire face lattice is implicitly computed to obtain the combinatorial polyhedron.


---

Comment by @kliem created at 2019-11-14 13:06:11

New commits:


---

Comment by @kliem created at 2019-11-14 13:06:11

Changing status from new to needs_review.


---

Comment by novoselt created at 2019-11-14 17:17:15

Changing status from needs_review to needs_work.


---

Comment by novoselt created at 2019-11-14 17:17:15

While it certainly makes sense, some things should be addressed:
1. Caching of facets - while the existing code computes more than necessary, it does it once and on the second invocation nothing is computed at all, plus all the properties of the facets (like lattice point count) are cached as well.
2. Face lattice methods - is it still possible with this change to ask for neighbours of a facet or its own facets and get the same results as before? I have doubts about it as it relied on facets being elements of a poset.
3. Sorting in low-dimensional cases - there is care the in the existing code to have consistent order of vertices and 0-dimensional faces, as well as facet normals and facets. And sometimes these coinside. Will the new code preserve the order?

As a possible easy solution - facets may take some argument like ``from_lattice=True`` which will trigger full lattice computation when ``True`` (default) and when ``False`` it will check if lattice is already computed (in which case there is no harm in using it) and if not - use the suggested code.


---

Comment by git created at 2019-11-14 20:18:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2019-11-14 20:24:26

Thanks for the comments.

Replying to [comment:2 novoselt]:
> While it certainly makes sense, some things should be addressed:
> 1. Caching of facets - while the existing code computes more than necessary, it does it once and on the second invocation nothing is computed at all, plus all the properties of the facets (like lattice point count) are cached as well.
Sure.
> 2. Face lattice methods - is it still possible with this change to ask for neighbours of a facet or its own facets and get the same results as before? I have doubts about it as it relied on facets being elements of a poset.
It seems to still work:

```
sage: o = lattice_polytope.cross_polytope(5)
sage: f = o.facets()[0]
sage: f.facet_of()
(5-d reflexive polytope in 5-d lattice M,)
sage: L = o.face_lattice()
sage: D = L.hasse_diagram()
sage: D.neighbors(f)
[3-d face of 5-d reflexive polytope in 5-d lattice M,
 5-d reflexive polytope in 5-d lattice M,
 3-d face of 5-d reflexive polytope in 5-d lattice M,
 3-d face of 5-d reflexive polytope in 5-d lattice M,
 3-d face of 5-d reflexive polytope in 5-d lattice M,
 3-d face of 5-d reflexive polytope in 5-d lattice M]
sage: f.facet_of()
(5-d reflexive polytope in 5-d lattice M,)
sage: 
```

Nevertheless, I adopted `face_lattice` to return exactly the facets in codimension 1.

I also changed my could to only be applied, when `self is self.ambient()`.
> 3. Sorting in low-dimensional cases - there is care the in the existing code to have consistent order of vertices and 0-dimensional faces, as well as facet normals and facets. And sometimes these coinside. Will the new code preserve the order?
My facets should be in exactly the same order, as they used to be, as I just took the code from `face_lattice`. They are also in the same order as the normals. So anything else would be very strange. Wouldn't it?
> 
> As a possible easy solution - facets may take some argument like ``from_lattice=True`` which will trigger full lattice computation when ``True`` (default) and when ``False`` it will check if lattice is already computed (in which case there is no harm in using it) and if not - use the suggested code.

Eventually, it makes sense to cache the hasse diagram instead of the `FiniteLatticePoset`. See [https://groups.google.com/d/msg/sage-devel/UuSDdN9QC3M/i2Uzp2SzEAAJ](https://groups.google.com/d/msg/sage-devel/UuSDdN9QC3M/i2Uzp2SzEAAJ).
----
New commits:


---

Comment by @kliem created at 2019-11-14 20:24:36

Changing status from needs_work to needs_review.


---

Comment by git created at 2019-11-15 05:50:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2019-11-15 06:37:39

Changing status from needs_review to needs_work.


---

Comment by @kliem created at 2019-11-15 06:37:39

Actually, I think I'm going to change the design a bit.

- Make `LPFace` a method of the lattice polytope (cached), which
  - if `self.ambient() is self` works as it is
  - otherwise transform the indices to ambient indices (using cached dictionaries) and then call `LPFace` of ambient

This way one can obtain facets directly from any lattice polytope. This will also allow to obtain faces directly from an interator instead of from the face lattice.


---

Comment by novoselt created at 2019-11-15 16:21:25

By face lattice methods I actually meant methods of facets which are related to the lattice:

```
sage: sage: o = lattice_polytope.cross_polytope(5)
....: sage: f = o.facets()[0]
....: sage: f.facet_of()
....: 
(5-d reflexive polytope in 5-d lattice M,)
sage: f.adjacent()
(4-d face of 5-d reflexive polytope in 5-d lattice M,
 4-d face of 5-d reflexive polytope in 5-d lattice M,
 4-d face of 5-d reflexive polytope in 5-d lattice M,
 4-d face of 5-d reflexive polytope in 5-d lattice M,
 4-d face of 5-d reflexive polytope in 5-d lattice M)
```

Will this adjacent method work with your design? What would be nice (and perhaps your last comment was about it as well) is to have an ability to construct standalone faces, but whenever they are requested again for whatever reason (e.g. because the full face lattice is computed) - exactly the same objects are returned.


---

Comment by novoselt created at 2019-11-15 16:24:20

Also a general remark on these improvements and optimizations - they are very welcome, especially since I have no time anymore to work on them myself! But please keep in mind the use case these classes were introduced - working with a lot of quite small polytopes (reflexive, their faces and subpolytopes) where faces and numbers of lattice points are requested repeatedly. So whatever optimizations are added to initial constructions should not affect caching of stuff for later reuse. Thank you!


---

Comment by @kliem created at 2019-11-15 20:33:56

Ok, I keep that in mind.

A few sentences about my motivation:

I mainly just wanted to compute the face lattice by `CombinatorialPolyhedron`. However, it doesn't make any sense to initialize it from the facets, which are in turn taken from the face lattice.

One intermediate step, is to create the incidence matrix (#28743). This is implicitly done for the face lattice anyway. (Actually one can obtain the combinatorial polyhedron instead from the incidence matrix.)

Maybe I just replace face lattice (in the `self is self.ambient()` case) and leave everything else the way it is.

To avoid memory leak, it makes also sense to cache the hasse diagram/digraph instead of `FiniteLatticePoset` (I was told that this is cached anyway). As it looks, many methods can then just call the hasse diagram directly.


---

Comment by embray created at 2020-01-06 14:10:03

Ticket retargeted after milestone closed


---

Comment by @kliem created at 2020-01-06 20:20:38

Changing status from needs_work to needs_review.


---

Comment by novoselt created at 2020-01-07 18:08:49

Changing status from needs_review to positive_review.


---

Comment by @kliem created at 2020-02-11 10:52:03

While this ticket is not closed, I updated the description to help people understand what was going on and why we this ticket is a "won't fix".


---

Comment by chapoton created at 2020-04-22 07:38:46

Resolution: wontfix
