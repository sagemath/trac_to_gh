# Issue 33561: Implement the Links-Gould polynomial invariant for links

Issue created by migration from https://trac.sagemath.org/ticket/33798

Original creator: soehms

Original creation time: 2022-05-04 19:01:02

Keywords: Links-Gould polynomial knots links

At the moment there doesn't seem to be any public available calculator for this invariant. We will implement it straight forward according to the definition given in [A CUBIC DEFINING ALGEBRA FOR THE LINKS-GOULD POLYNOMIAL by Marin and Wagner](http://www.lamfa.u-picardie.fr/marin/arts/LG.pdf), section 3. Calculations are done on matrices over the symbolic ring since square-roots of 2 variate Laurent polynomials are involved. As the dimension of these matrices are given by `4^num_strands` the performance slows down accordingly.

In a second step we could try to figure out if the approach followed in [a 2013 paper of David de Witt](https://arxiv.org/pdf/math/9906059.pdf) would improve performance.

Some examples: On an `i7` CPU calculation for 3 strand braids is a matter of a few seconds for 4 strand braids it will take some minutes whereas for 5 strand braids hours will be needed (5 Minutes of that just for setting up the representation matrices). For example for `K8_1` you'll need between two and three hours. Braids with six or more strands are excluded in the above mentioned paper of David de Witt, as well.


---

Comment by soehms created at 2022-05-04 19:03:47

New commits:


---

Comment by soehms created at 2022-05-04 19:03:47

Changing status from new to needs_review.


---

Comment by git created at 2022-06-08 17:33:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by soehms created at 2022-06-08 17:34:56

I just fixed a merge conflict.


---

Comment by tscrim created at 2022-06-16 01:02:04

Since everything only involves square roots of the variables, wouldn't it be better to replace `t_i` with `t_i^2`? That way you can do everything in polynomial rings, which should be much faster. Afterwards you could then substitute back.


---

Comment by soehms created at 2022-06-17 09:15:32

Replying to [comment:5 tscrim]:
> Since everything only involves square roots of the variables, wouldn't it be better to replace `t_i` with `t_i^2`? That way you can do everything in polynomial rings, which should be much faster. Afterwards you could then substitute back.

Maybe I don't understand your idea exactly. I've tried to use a quotient ring over a three variate polynomial ring the third variable of which corresponding to the term abbreviated `Y` in Ivan Marin's paper. At the moment I don't have access to my notes about that, since I'm on vacation. But this was even slower than using the symbolic ring.


---

Comment by tscrim created at 2022-06-17 09:48:10

Replying to [comment:6 soehms]:
> Replying to [comment:5 tscrim]:
> > Since everything only involves square roots of the variables, wouldn't it be better to replace `t_i` with `t_i^2`? That way you can do everything in polynomial rings, which should be much faster. Afterwards you could then substitute back.
> 
> Maybe I don't understand your idea exactly. I've tried to use a quotient ring over a three variate polynomial ring the third variable of which corresponding to the term abbreviated `Y` in Ivan Marin's paper.

I am not suggesting that. In the description, you say you use `SR` since for the Laurent polynomial ring variables "x,y", you use x<sup>1/2</sup> and y<sup>1/2</sup> in the computations. I am just saying use the variables t<sub>0</sub> = x<sup>1/2</sup> and t<sub>1</sub> = y<sup>1/2</sup> for the computations to avoid `SR`. Then in the final computation, you just rescale all of the exponents by 1/2 since the result is a polynomial. Although we could just output with the squared variables with a `.. WARNING::` indicating the change in convention.

> At the moment I don't have access to my notes about that, since I'm on vacation. But this was even slower than using the symbolic ring.

No problem. Enjoy your vacation.

I would have the internal cached method use fixed variable names and then do a substitution for different user input to not redo the computation just because the variable names change.

Also, typo: `beeing`.


---

Comment by soehms created at 2022-06-17 14:58:15

Replying to [comment:7 tscrim]:
> Replying to [comment:6 soehms]:
> > Replying to [comment:5 tscrim]:
> > > Since everything only involves square roots of the variables, wouldn't it be better to replace `t_i` with `t_i^2`? That way you can do everything in polynomial rings, which should be much faster. Afterwards you could then substitute back.
> > 
> > Maybe I don't understand your idea exactly. I've tried to use a quotient ring over a three variate polynomial ring the third variable of which corresponding to the term abbreviated `Y` in Ivan Marin's paper.
> 
> I am not suggesting that. In the description, you say you use `SR` since for the Laurent polynomial ring variables "x,y", you use x<sup>1/2</sup> and y<sup>1/2</sup> in the computations. I am just saying use the variables t<sub>0</sub> = x<sup>1/2</sup> and t<sub>1</sub> = y<sup>1/2</sup> for the computations to avoid `SR`. Then in the final computation, you just rescale all of the exponents by 1/2 since the result is a polynomial. Although we could just output with the squared variables with a `.. WARNING::` indicating the change in convention.
> 

It's not just squares of the variables, there are also squares of non monomial Laurent polynomials (see the `Y`). Apparently it's a non-trivial fact that the result always simplifies to Laurent polynomials.

Anyway, I will think about this once again, when I'm back home. Thanks for looking at the ticket!


---

Comment by git created at 2022-07-04 07:06:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by soehms created at 2022-07-04 07:10:08

Travis, you are right! Indeed, the quotient ring  leads to a faster implementation. It seems that I didn't use sparse matrices for this ring in my former tests (note that for symbolics there is no proper sparse implementation and thus dense matrices perform better in this setting).

Nevertheless I keep the usage of the symbolic ring as a second implementation option, since it might be useful for cross checks and verifications.


---

Comment by tscrim created at 2022-07-15 08:53:11

Sorry for taking so long to get to this.

I am glad you were able to speed it up. How does it compare to doing computations in

```python
            LC = LaurentPolynomialRing(ZZ, 's0r, s1r')
            s0r, s1r = LC.gens()
            LR = PolynomialRing(LC 'Yr')
            Yr = LR.gen()
            pqr = Yr**2 + (s0r**2-1)*(s1r**2 -1)
```

This way it is the quotient ring of a _univariate_ polynomial ring. I would think working with quotients there would be faster since the data type is more simple.

Also, I would have

```python
def links_gould_polynomial(self, varnames=None, use_symbolics=False):
    if varnames is not None:
         poly = links_gould_polynomial(use_symbolics=use_symbolics)
         R = PolynomialRing(ZZ, varnames)
         t0, t1 = R.gens()
         return poly(t0=t0, t1=t1)
    varnames = 't0, t1'
```

to not do the full computation again when only the variable names have changed.


---

Comment by git created at 2022-07-18 16:56:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by soehms created at 2022-07-18 17:01:51

Replying to [comment:11 tscrim]:
> Sorry for taking so long to get to this.

No problem!
 
> I am glad you were able to speed it up. How does it compare to doing computations in
> {{{#!python
>             LC = LaurentPolynomialRing(ZZ, 's0r, s1r')
>             s0r, s1r = LC.gens()
>             LR = PolynomialRing(LC 'Yr')
>             Yr = LR.gen()
>             pqr = Yr**2 + (s0r**2-1)*(s1r**2 -1)
> }}}
> This way it is the quotient ring of a _univariate_ polynomial ring. I would think working with quotients there would be faster since the data type is more simple.
 
Many thanks for this useful suggestion. Once again, I could achieve a remarkable improvement of performance with it. The calculation for knot K10_1 which didn't terminate using symbolics within a day, now needs 22 minutes. With the former quotient ring version it has been 4 hours.

Furthermore, I now could successfully run a crosscheck over all links listed in the KnotInfo and LinkInfo databases having less than 5 strands (3342 in sum) against the according specialization of the formal Markov trace on the cubic Hecke algebra (see method `formal_markov_trace` of class `CubicHeckeElement` in ticket #29717) in less than 5.5 hours.




> Also, I would have
> {{{#!python
> def links_gould_polynomial(self, varnames=None, use_symbolics=False):
>     if varnames is not None:
>          poly = links_gould_polynomial(use_symbolics=use_symbolics)
>          R = PolynomialRing(ZZ, varnames)
>          t0, t1 = R.gens()
>          return poly(t0=t0, t1=t1)
>     varnames = 't0, t1'
> }}}
> to not do the full computation again when only the variable names have changed.

This is done now, as well!

BTW: You may have asked why I wrote `(R1*R2*R1 - R2*R1*R2).is_zero())` before. The reason was that comparison in quotient rings over multivariate Laurent polynomial rings doesn't work. I will open a corresponding ticket about that, soon.


---

Comment by tscrim created at 2022-07-19 03:16:24

Thank you. I am glad it was useful. LGTM.


---

Comment by tscrim created at 2022-07-19 03:16:24

Changing status from needs_review to positive_review.


---

Comment by soehms created at 2022-07-19 08:00:35

Replying to [comment:15 tscrim]:
> Thank you. I am glad it was useful. LGTM.
I'm also glad. Thank you, too!


---

Comment by vbraun created at 2022-07-28 19:10:16

Resolution: fixed
