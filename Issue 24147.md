# Issue 24147: py3: a few changes about range

Issue created by migration from Trac.

Original creator: chapoton

Original creation time: 2017-12-15 16:31:28

CC:  tscrim jdemeyer embray

as part of #16081


---

Comment by chapoton created at 2017-12-15 16:32:00

Changing status from new to needs_review.


---

Comment by chapoton created at 2017-12-15 16:32:00

New commits:


---

Comment by chapoton created at 2017-12-15 17:37:53

green bot, please review


---

Comment by tscrim created at 2017-12-15 22:09:28

So the changes to `tensor_operations.py` would not be necessary if we add `range` to the known Python classes handled by `cartesian_product`:

```diff
-native_python_containers   = set([tuple, list, set, frozenset])
+native_python_containers   = set([tuple, list, set, frozenset, range])
```

It would be good if we could somehow add all possible views to this (and other similar places for previously-list objects), but `range` is the most common one that will be passed for this construction.

I also do not see the need to any changes in `abvar.py`. In Python3 (3.5.2 to be specific), I can do

```
>>> x = range(5)
>>> x[-2]
3
>>> list(x)
[0, 1, 2, 3, 4]
```

so `i = rows[-1][-1]+1` should not be a problem. Additionally, `matrix_from_rows` would just convert the `range` into a `list` (although I think it probably should not do any such conversion). Am I missing something there?


---

Comment by git created at 2017-12-17 17:33:24

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by chapoton created at 2017-12-17 17:33:50

I have undone the changes to abvar.
----
New commits:


---

Comment by chapoton created at 2017-12-17 20:34:14

green bot. Would it be ok like that for the moment ?


---

Comment by tscrim created at 2017-12-17 21:14:27

I ended up doing the changes to `cartesian_product` to make that handle a `range` input as that is something we will want to do eventually and it means we do not have to add a bunch of `list` wrappers.
----
New commits:


---

Comment by chapoton created at 2017-12-18 12:34:15

ok, thanks


---

Comment by chapoton created at 2017-12-18 12:34:15

Changing status from needs_review to positive_review.


---

Comment by embray created at 2017-12-19 11:42:39

I think changes like this should also include native iterables that were previously functions that returned `list`s, such as `map` and `filter` as well.  Or maybe arbitrary iterables (or at least finite iterables as in `isinstance(x, Iterable) and isinstance(x, Sized)`.  The only problem I've found with this is sometimes it's necessary to take care between specific Sage objects that happen to be iterable, and arbitrary/unknown iterables that should be converted to a list.


---

Comment by embray created at 2017-12-19 11:43:17

Other examples include containers like `dict_keys`, `dict_values`, and `dict_items`.


---

Comment by embray created at 2017-12-19 11:48:16

Replying to [comment:9 embray]:
> I think changes like this should also include native iterables that were previously functions that returned `list`s, such as `map` and `filter` as well.  Or maybe arbitrary iterables (or at least finite iterables as in `isinstance(x, Iterable) and isinstance(x, Sized)`.  The only problem I've found with this is sometimes it's necessary to take care between specific Sage objects that happen to be iterable, and arbitrary/unknown iterables that should be converted to a list.

Actually, maybe not `Sized` since a `map` is not `Sized`, and there's no (Pythonic) way to get from a `map` object what its underlying iterators are, so if it were a map of an infinite iterator you run the risk of blowing up, but I guess that's a problem in general as well.


---

Comment by embray created at 2017-12-19 12:00:46

Would a test like `isinstance(x, Iterable) and not isinstance(x, SageObject)` be good enough for most cases of "arbitrary iterable that is not otherwise meaningful to Sage"?


---

Comment by tscrim created at 2017-12-19 22:16:14

I wish those Python3 containers all have some nice common base class, but they don't. `:/`

Unfortunately, I'm not sure your suggestion in comment:12 would not work because generators are iterable:

```
sage: g = (x for x in ZZ)
sage: isinstance(g, collections.Iterable) and not isinstance(g, SageObject)
True
```

So there is no way to guarantee finiteness (right now, I this might be guaranteed for Python object input). Nor do we want strings to be such an object. Granted, we might be able to refine this in a reasonable way, but it will likely be a bit more involved (IDK how much from a quick look).


---

Comment by vbraun created at 2017-12-25 18:21:36

Resolution: fixed


---

Comment by embray created at 2018-01-02 14:55:48

I'm also annoyed that there isn't a standard ABC in Python for a _finite_ iteratable.  We could make our own though.  The problem is that you can't just say it has to have `__len__` because some iterables like `map` aren't _necessarily_ finite, but they can be if the iterable they wrap is finite.

So since there's no way to know absolutely for sure if an iterable is finite I would propose to not worry about it, and if the user provides an infinite iterable that's just as much user error as writing an infinite `while` loop.  It seems to be the only way really, not that I'm happy about it.
