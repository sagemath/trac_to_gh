# Issue 18034: Stanley hook content formula

Issue created by migration from Trac.

Original creator: deinst

Original creation time: 2015-04-21 17:15:05

CC:  sage-combinat




---

Comment by deinst created at 2015-04-21 17:25:12

Changing type from PLEASE CHANGE to enhancement.


---

Comment by deinst created at 2015-04-21 17:25:12

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by deinst created at 2015-04-21 17:25:12

Set assignee to deinst.


---

Comment by deinst created at 2015-04-21 17:25:12

Changing priority from major to minor.


---

Comment by deinst created at 2015-04-23 15:53:46

New commits:


---

Comment by deinst created at 2015-04-23 15:53:46

Changing status from new to needs_review.


---

Comment by tscrim created at 2015-04-23 16:52:21

This definitely sounds like a good idea. Could you do some timings with `%timeit` on small/large partitions with small/large `max_part`? It might also be faster to do the fraction division at each step to get cancellations sooner. Also, I think it is a good idea to have both implementations (accessible via an `algorithm` keyword with the default being the hook formula) as they are different algorithms and can be used as cross-checks in tests.

It's slightly worrisome that we're abusing `Composition` here, but that's a side note.


---

Comment by deinst created at 2015-04-23 17:10:17

I'll implement both algorithms.
I'll get some timings. 
How do I force the fraction divisions to be done in Q?  I've run into the situation where sometimes the division is truncating (like python default) and sometimes creates rational numbers.  These different behaviors can occur for apparently identical calls. (see the abandoned commit)

I'll also spell Corollary correctly.


---

Comment by tscrim created at 2015-04-23 17:23:28

You could try something like this:

```python
res = Integer(1)
for i,l in enumerate(self.shape):
    for j in range(l):
        res *= Integer(self.max_entry + j -i) / (l + conj[j] - i - j - 1)
return res
```

(which becomes something else to compare timings with), where the division is as Sage integers, which becomes rational numbers instead of doing python `int` division (which is `//` or floor division). Translating your first commit, you could do:

```python
from sage.combinat.partition import Partitions
number = prod(Integer(self.max_entry + self.shape.content(*c)) / self.shape.hook_length(*c)
              for c in self.shape.cells())
```

(although the hook length should return a Sage integer and there shouldn't be a problem...).


---

Comment by deinst created at 2015-04-23 17:33:08

Thanks.
The reason I abandoned that first commit was that  it was running into exactly that problem.
Sometimes SemistandardTableaux([2,1,1,1], max_entry=5).cardinality() would return 24 (correct) and sometimes it would return 12 (incorrect).


---

Comment by deinst created at 2015-04-23 20:40:41

Some timings.
Algorithms)
sum:  This is the current algorithm that sums over the weights
hook: (default) This is the implementation that computes the hook_lengths and contents directly and sums the numerator and denominator separately.
hook2:  This lets the Partition object compute the hook lengths and the contents of the cells and does the summation in QQ
hook3: This is the same as hook, but does the summation in QQ .

sage: t1 = SemistandardTableaux([2,1,1,1], max_entry=5)
sage: t2 = SemistandardTableaux([4,3,2,1], max_entry=12)
sage: timeit("t1.cardinality(algorithm='sum')")
125 loops, best of 3: 5.31 ms per loop
sage: timeit("t1.cardinality()")
625 loops, best of 3: 41.8 µs per loop
sage: timeit("t1.cardinality(algorithm='hook2')")
625 loops, best of 3: 198 µs per loop
sage: timeit("t1.cardinality(algorithm='hook3')")
625 loops, best of 3: 66.2 µs per loop
sage: timeit("t2.cardinality(algorithm='sum')")
5 loops, best of 3: 33.4 s per loop
sage: timeit("t2.cardinality()")
625 loops, best of 3: 52.7 µs per loop
sage: timeit("t2.cardinality(algorithm='hook2')")
625 loops, best of 3: 409 µs per loop
sage: timeit("t2.cardinality(algorithm='hook3')")
625 loops, best of 3: 74.8 µs per loop


It appears that summing the numerator and denominator separately is the fastest way to do things, at least for reasonable size problems.  It also appears that the hook length formula is already two orders of magnitude faster than what we have now for small problems.

Although letting the partition object compute the hook lengths and contents leads to marginally clearer code, it is noticeably slower, and the direct computation is not very complicated, I think that it is best to go with the marginally more complicated code.


---

Comment by tscrim created at 2015-04-23 20:54:10

So then go with the fastest as the default then as it seems like there's not a lot of cancellations. I'd still prefer to have the breakdown by weight as a separate algorithm though.


---

Comment by git created at 2015-04-23 22:50:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-04-25 07:01:29

Thank you. I also made some reviewer tweaks, so if you're happy with my changes, then you can set a positive review.
----
New commits:


---

Comment by git created at 2015-04-25 07:09:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by deinst created at 2015-04-25 17:03:26

Looks great to me.

SemistandardTableaux_size needs a similar (more trivial) enhancement.  Should I stick it here, or open a new ticket.


---

Comment by deinst created at 2015-04-25 17:03:26

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2015-04-25 17:29:59

On a new ticket is best.


---

Comment by vbraun created at 2015-04-26 02:21:38

Resolution: fixed
