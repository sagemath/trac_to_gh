# Issue 18777: Tarjan Strongly Connected Components Algorithm

Issue created by migration from Trac.

Original creator: borassi

Original creation time: 2015-08-12 09:17:16

CC:  ncohen dcoudert




---

Comment by borassi created at 2015-08-12 09:20:11

Changing component from PLEASE CHANGE to graph theory.


---

Comment by borassi created at 2015-08-12 09:20:11

Changing keywords from "" to "Strongly connected components, Tarjan".


---

Comment by borassi created at 2015-08-12 09:20:11

Changing type from PLEASE CHANGE to enhancement.


---

Comment by git created at 2015-08-13 13:39:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by borassi created at 2015-08-13 13:49:32

Changing status from new to needs_review.


---

Comment by borassi created at 2015-08-13 13:49:32

Hi!

I think Sage was really missing a linear-time algorithm for strongly connected components (in particular, I implemented it because I need it for other algorithms). It improves a lot the old algorithm when the graph has many components, but it is a bit slower when the graph is connected, as shown by the following examples. In any case, I removed the old algorithm: I know that it might have been faster in some rare cases, but the difference is small, and the time spent to input the graph is usually bigger than the time needed to run this algorithm.

Do you like it?

Michele


```
Old algorithm
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
100 loops, best of 3: 18.3 ms per loop
New algorithm
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 5.61 s per loop

Old algorithm
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 98.4 ms per loop
New algorithm
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 183 ms per loop
```



---

Comment by dcoudert created at 2015-08-13 16:40:13

Hello,

You have inverted the timing for GNM. I got

```
OLD algorithm
sage: set_random_seed(0)
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 7.87 s per loop
sage: g.add_cycle(g.vertices())
sage: %timeit g.strongly_connected_components()
100 loops, best of 3: 21 ms per loop
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 142 ms per loop

NEW algorithm
sage: set_random_seed(0)
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
100 loops, best of 3: 21.5 ms per loop
sage: g.add_cycle(g.vertices())
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 22.1 ms per loop
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 260 ms per loop
```


I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.

I have some remarks:
- Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?
- What's the need for returning a dictionary? it is immediately converted to a list of lists in `strongly_connected_components`. Do you need this feature for something else?
- You have let another version of `strongly_connected_components` in `static_sparse_graph.pyx`. Is this method used somewhere?
- Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`
- In `_strongly_connected_components_digraph` you have but you don't use `MemoryAllocator`. Here also, you could use array of shorts instead of bitset.
- I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like

```
d = {i:list() for i in range(nscc)}
for u,i in scc.iteritems():
    d[i].append(u)
output = [d[i] for i in range(nscc)]
```


David.


---

Comment by ncohen created at 2015-08-13 17:07:05

> I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.

Is there any slowdown for `is_strongly_connected`?

Nathann


---

Comment by dcoudert created at 2015-08-13 17:25:27

I don't see any slowdown, But there is room for improvements...
- Without this patch

```
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(10000,50000)
sage: %timeit D.is_strongly_connected()
100 loops, best of 3: 10.2 ms per loop
sage: D.add_cycle(D.vertices())
sage: %timeit D.is_strongly_connected()
10 loops, best of 3: 20.9 ms per loop
```

- With this patch

```
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(10000,50000)
sage: %timeit D.is_strongly_connected()
100 loops, best of 3: 9.98 ms per loop
sage: D.add_cycle(D.vertices())
sage: %timeit D.is_strongly_connected()
10 loops, best of 3: 22 ms per loop
```


David.


---

Comment by ncohen created at 2015-08-13 17:28:51

Okayokay, it seems orthogonal. Thanks!


---

Comment by dcoudert created at 2015-08-13 17:36:16

Well, if you look at the code you will see that it is not so orthogonal: if the backend has the method, we use it. Otherwise we count the number of scc, and so we rely on this ticket.
We need a backward BFS/DFS to get ride of this dependency.


---

Comment by borassi created at 2015-08-14 08:09:10

Hello!

I think that the method `is_strongly_connected` does not depend on this patch, and what you are proposing is already implemented in routine `is_strongly_connected` in `c_graph` (which also saves some time since it does not copy the whole graph). 

Indeed, this method is much simpler than computing SCCs: it performs a forward and backward visit from any node, and sees if we reach all vertices. Hence, I think it should be left as it is. For completeness, I attach the code of this routine.

Soon I will correct all the issues you raised in comment 5!

See you,

Michele


```
    def is_strongly_connected(self):
        cdef int v_int = 0
        cdef CGraph cg = self._cg

        # Pick one vertex
        v_int = bitset_first(cg.active_vertices)

        if v_int == -1:
            return True

        v = self.vertex_label(v_int)

        cdef int n = 0
        for _ in self.depth_first_search(v):
            n += 1
        if cg.num_verts != n:
            return False
        n = 0
        for _ in self.depth_first_search(v, reverse=True):
            n += 1
        return cg.num_verts == n
```

Replying to [comment:9 dcoudert]:

> Well, if you look at the code you will see that it is not so orthogonal: if the backend has the method, we use it. Otherwise we count the number of scc, and so we rely on this ticket.
> We need a backward BFS/DFS to get ride of this dependency.


---

Comment by borassi created at 2015-08-14 09:09:30

Replying to [comment:5 dcoudert]:

> Hello,
> 
> You have inverted the timing for GNM. I got
> {{{
> OLD algorithm
> sage: set_random_seed(0)
> sage: g = digraphs.RandomDirectedGNM(10000,30000)
> sage: %timeit g.strongly_connected_components()
> 1 loops, best of 3: 7.87 s per loop
> sage: g.add_cycle(g.vertices())
> sage: %timeit g.strongly_connected_components()
> 100 loops, best of 3: 21 ms per loop
> sage: g = digraphs.Circuit(100000)
> sage: %timeit g.strongly_connected_components()
> 10 loops, best of 3: 142 ms per loop
> 
> NEW algorithm
> sage: set_random_seed(0)
> sage: g = digraphs.RandomDirectedGNM(10000,30000)
> sage: %timeit g.strongly_connected_components()
> 100 loops, best of 3: 21.5 ms per loop
> sage: g.add_cycle(g.vertices())
> sage: %timeit g.strongly_connected_components()
> 10 loops, best of 3: 22.1 ms per loop
> sage: g = digraphs.Circuit(100000)
> sage: %timeit g.strongly_connected_components()
> 10 loops, best of 3: 260 ms per loop
> }}}
> 
> I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.

Ups, sorry! Clearly, the fastest method was the new one.

> I have some remarks:
> - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?

Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?

> - What's the need for returning a dictionary? it is immediately converted to a list of lists in `strongly_connected_components`. Do you need this feature for something else?

You are right: I have moved all the code in `static_sparse_graph.pyx`, and I removed the dictionary. In order to import the method to DiGraph, I used types.methodtype.

> - You have let another version of `strongly_connected_components` in `static_sparse_graph.pyx`. Is this method used somewhere?

You are right, it is an old remnant of old routines, used only in a test. I removed everything.

> - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`

Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.

> - In `_strongly_connected_components_digraph` you have but you don't use `MemoryAllocator`. Here also, you could use array of shorts instead of bitset.

Since I removed the bitsets, now I use `MemoryAllocator`.

> - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like
> {{{
> d = {i:list() for i in range(nscc)}
> for u,i in scc.iteritems():
> d[i].append(u)
> output = [d[i] for i in range(nscc)]
> }}}

Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.


```
WITH NUMPY
sage: g = DiGraph(10000000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 9.44 s per loop

WITH DICTIONARIES
sage: g = DiGraph(10000000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 9.87 s per loop
```

> David.

[1] !http://arxiv.org/abs/1507.01490


---

Comment by git created at 2015-08-14 09:17:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2015-08-14 14:24:49

> > I have some remarks:
> > - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?
> 
> Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?

If you plan to call these methods directly from other cython files, it make sense to split the method in two pieces.
With Nathann we recently started to name such methods `compute_cool_stuff_C` rather than `_compute_cool_stuff`. I don't know if there is a general rule for that.
 
> > - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`
> 
> Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.

Well, bitsets are really fast, and to be honest we save very little using an array instead. The code is shorter. This is already something.
 
> > - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like
> > {{{
> > d = {i:list() for i in range(nscc)}
> > for u,i in scc.iteritems():
> > d[i].append(u)
> > output = [d[i] for i in range(nscc)]
> > }}}
> 
> Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.
> 
> {{{
> WITH NUMPY
> sage: g = DiGraph(10000000)
> sage: %timeit g.strongly_connected_components()
> 1 loops, best of 3: 9.44 s per loop
> 
> WITH DICTIONARIES
> sage: g = DiGraph(10000000)
> sage: %timeit g.strongly_connected_components()
> 1 loops, best of 3: 9.87 s per loop
> }}}

another option (don't know if it is faster or not)

```
cdef int i
cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
for i,v in enumerate(G.vertex_iterator()):
    output[scc[i]].append(v)
```


Method `strongly_connected_components_digraph`:
- is not currently called by `DiGraph().strongly_connected_components_digraph()` and will certainly never be
- seems more complicated than what it should. Indeed, as soon as you have a mapping `vertex->scc` you can simply iterate over the edges `(u,v)` of the input digraph and add edges `(scc[u],scc[v])` to the output digraph. I don't see the need for the `_strongly_connected_components_digraph` method and it is rather complicated.



General comments:
- `if visited[u] == 0:` -> `if not visited[u]`
- `return [output, {v:scc[i] for i,v in enumerate(G.vertices())}]` -> `return output, {v:scc[i] for i,v in enumerate(G.vertices())}`  no need for explicitely creating a list
- you have broken doctests caused by this ticket. I have not tracked the dependencies.

```
sage -t --long src/sage/monoids/automatic_semigroup.py
**********************************************************************
File "src/sage/monoids/automatic_semigroup.py", line 135, in sage.monoids.automatic_semigroup.AutomaticSemigroup
Failed example:
    map(sorted, M.j_classes())
Expected:
    [[[], [2]], [[1, 1], [1]]]
Got:
    [[[1], [1, 1]], [[], [2]]]
**********************************************************************
File "src/sage/monoids/automatic_semigroup.py", line 137, in sage.monoids.automatic_semigroup.AutomaticSemigroup
Failed example:
    M.j_classes_of_idempotents()
Expected:
    [This is the Trac macro *[* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[-macro), [This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro)]
Got:
    [This is the Trac macro *[1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[1, 1-macro), [[]]]
**********************************************************************
File "src/sage/monoids/automatic_semigroup.py", line 139, in sage.monoids.automatic_semigroup.AutomaticSemigroup
Failed example:
    M.j_transversal_of_idempotents()
Expected:
    [[], [1, 1]]
Got:
    [[1, 1], []]
**********************************************************************
1 item had failures:
   3 of  80 in sage.monoids.automatic_semigroup.AutomaticSemigroup
    [264 tests, 3 failures, 1.94 s]
sage -t --long src/sage/categories/finite_semigroups.py
**********************************************************************
File "src/sage/categories/finite_semigroups.py", line 119, in sage.categories.finite_semigroups.FiniteSemigroups.ParentMethods.j_transversal_of_idempotents
Failed example:
    sorted(S.j_transversal_of_idempotents())
Expected:
    ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']
Got:
    ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']
```



---

Comment by borassi created at 2015-08-16 17:42:02

Hello!
Let me try to address these problems!
Thank you very much,
Michele

Replying to [comment:13 dcoudert]:

> > > I have some remarks:
> > > - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?
> > > 
> > > 
> > > 
> > > 
> > 
> > Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?
> > 
> > 
> > 
> > 
> 
> If you plan to call these methods directly from other cython files, it make sense to split the method in two pieces.
> With Nathann we recently started to name such methods `compute_cool_stuff_C` rather than `_compute_cool_stuff`. I don't know if there is a general rule for that.

Done!

> > > - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`
> > > 
> > > 
> > > 
> > > 
> > 
> > Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.
> > 
> > 
> > 
> > 
> 
> Well, bitsets are really fast, and to be honest we save very little using an array instead. The code is shorter. This is already something.

Ok, let's leave it as it is!

> > > - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like
> > > {{{
> > > d = {i:list() for i in range(nscc)}
> > > for u,i in scc.iteritems():
> > > d[i].append(u)
> > > output = [d[i] for i in range(nscc)]
> > > }}}
> > > 
> > > 
> > > 
> > > 
> > 
> > Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.
> > 
> > {{{
> > WITH NUMPY
> > sage: g = DiGraph(10000000)
> > sage: %timeit g.strongly_connected_components()
> > 1 loops, best of 3: 9.44 s per loop
> > 
> > WITH DICTIONARIES
> > sage: g = DiGraph(10000000)
> > sage: %timeit g.strongly_connected_components()
> > 1 loops, best of 3: 9.87 s per loop
> > }}}
> > 
> > 
> > 
> > 
> 
> another option (don't know if it is faster or not)
> {{{
> cdef int i
> cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
> for i,v in enumerate(G.vertex_iterator()):
> output[scc[i]].append(v)
> }}}

Cool! Not only it is simpler, it is also faster!


```
sage: g = DiGraph(10000000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 7.89 s per loop
```

> Method `strongly_connected_components_digraph`:
> - is not currently called by `DiGraph().strongly_connected_components_digraph()` and will certainly never be
> - seems more complicated than what it should. Indeed, as soon as you have a mapping `vertex->scc` you can simply iterate over the edges `(u,v)` of the input digraph and add edges `(scc[u],scc[v])` to the output digraph. I don't see the need for the `_strongly_connected_components_digraph` method and it is rather complicated.

Hmmm, this is the hard part of my answer...

The problem is that I will need a C algorithm working on `static_sparse_graphs` to compute the digraph of strongly connected components in linear time, with no parallel edge. I think this is the only way to do it: I know it is complicated, but I do not know any other way. Do you think I should use n dictionaries, to check for parallel edges?

> General comments:
> - `if visited[u] == 0:` -> `if not visited[u]`

Done!

> - `return [output, {v:scc[i] for i,v in enumerate(G.vertices())}]` -> `return output, {v:scc[i] for i,v in enumerate(G.vertices())}`  no need for explicitely creating a list

Done!

> - you have broken doctests caused by this ticket. I have not tracked the dependencies.

The problem is the order in which strongly connected components are outputted in the list: we can change the results without any problem. In the following, I try to explain why.

> {{{
> sage -t --long src/sage/monoids/automatic_semigroup.py
> **********************************************************************
> File "src/sage/monoids/automatic_semigroup.py", line 135, in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> Failed example:
> map(sorted, M.j_classes())
> Expected:
> [[[], [2]], [[1, 1], [1]]]
> Got:
> [[[1], [1, 1]], [[], [2]]]

The J-classes are sets of elements in a semigroups satisfying a specific property (for more information, see http://www.liafa.jussieu.fr/~jep/PDF/HandBook.pdf). The difference amont the results is the order in which the elements are listed, but since in sets the order does not count, both results are correct.

> **********************************************************************
> File "src/sage/monoids/automatic_semigroup.py", line 137, in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> Failed example:
> M.j_classes_of_idempotents()
> Expected:
> [This is the Trac macro *[* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[-macro), [This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro)]
> Got:
> [This is the Trac macro *[1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[1, 1-macro), [[]]]

Here, the difference is the order in which the two classes of idempotents are outputted. Since method j_classes_of_idempotents does not set a specific order, both results are correct.

> **********************************************************************
> File "src/sage/monoids/automatic_semigroup.py", line 139, in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> Failed example:
> M.j_transversal_of_idempotents()
> Expected:
> [[], [1, 1]]
> Got:
> [[1, 1], []]

Here, we simply get one element from the classes found in the previous example: the order is maintained. Hence, both results are again correct.

> **********************************************************************
> 1 item had failures:
> 3 of  80 in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> [264 tests, 3 failures, 1.94 s]
> sage -t --long src/sage/categories/finite_semigroups.py
> **********************************************************************
> File "src/sage/categories/finite_semigroups.py", line 119, in sage.categories.finite_semigroups.[This is the Trac macro *FiniteSemigroups* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#FiniteSemigroups-macro).[This is the Trac macro *ParentMethods* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#ParentMethods-macro).j_transversal_of_idempotents
> Failed example:
> sorted(S.j_transversal_of_idempotents())
> Expected:
> ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']
> Got:
> ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']
> }}}

Here, 'abc' is in the same class of idempotents as 'acb', and 'bc' is in the same class of idempotents as 'cb', as shown by the example before this one. Since this routine should output one idempotent per class, we are fine!


---

Comment by borassi created at 2015-08-16 21:09:43

Just a detail, for future references:


```
cdef int i
cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
for i,v in enumerate(G.vertex_iterator()):
output[scc[i]].append(v)

```

If we use `G.vertex_iterator()`, the vertex labels are not correct (I also added an example with labels, that shows the problem). With `G.vertices()`, everything works fine.

Why?


---

Comment by git created at 2015-08-16 21:24:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-08-16 21:25:46

because `G.vertices()` sorts the output (I know, I know...). I fixed something similar recently in an igraph ticket: the output of `.edge_iterator` is not the same as `.edges`.

Nathann


---

Comment by dcoudert created at 2015-08-17 11:45:03

In method `tarjan_strongly_connected_components_C`, you could do the following:

```
if visited[v]:
   continue
```

and then remove one level of indentation.

In method `strongly_connected_components_digraph_C`.

```
   output.edges = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
   if output.edges == NULL and output.m != 0:
       raise ValueError("Problem while allocating memory (edges)")
   output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
   if output.neighbors == NULL and output.m != 0:
       raise ValueError("Problem while allocating memory (neighbors)")
```

must be replaced by something link

```
   if output.m==0:
      << DO APPROPRIATE OPERATIONS FOR THIS CASE >>
      << RETURN >>

   output.edges     = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
   output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
   if output.edges == NULL or output.neighbors == NULL:
       raise MemoryError("Problem while allocating memory (edges or neighbors).")
```

This is not only a cosmetic change since when `m==0` you allow `output.neighbors==NULL` before the instruction `output.neighbors[0] = output.edges`. So your code is currently not safe.


Otherwise, the method is working very well

```
Before
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(100000,500000)
sage: D.is_strongly_connected()
False
sage: %time res = D.strongly_connected_components()
len(res)
CPU times: user 3min 50s, sys: 4.28 s, total: 3min 55s
Wall time: 3min 56s
sage: len(res)
1413

With this patch
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(100000,500000)
sage: D.is_strongly_connected()
False
sage: %time res = D.strongly_connected_components()
CPU times: user 481 ms, sys: 16.2 ms, total: 497 ms
Wall time: 499 ms
sage: len(res)
1413
sage: D.allow_multiple_edges(True)
sage: D
Multi-digraph on 100000 vertices
sage: D.add_edges(D.edges())
sage: D.size()
1000000
sage: %time res = D.strongly_connected_components()
CPU times: user 566 ms, sys: 20.4 ms, total: 587 ms
Wall time: 594 ms
sage: len(res)
1413
```

and as you can see, I also tried with a multi-digraph and its working as expected.

David.


---

Comment by dcoudert created at 2015-08-17 11:45:03

Changing status from needs_review to needs_work.


---

Comment by borassi created at 2015-08-17 14:56:13

Done!

> 
> In method `tarjan_strongly_connected_components_C`, you could do the following:
> {{{
> if visited[v]:
> continue
> }}}
> and then remove one level of indentation.

Probably, you meant


```
if visited[u]:
    continue
```

because the line `if visited[v]:` is followed by an else. Correct?

> In method `strongly_connected_components_digraph_C`.
> {{{
> output.edges = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
> if output.edges == NULL and output.m != 0:
> raise ValueError("Problem while allocating memory (edges)")
> output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
> if output.neighbors == NULL and output.m != 0:
> raise ValueError("Problem while allocating memory (neighbors)")
> }}}
> must be replaced by something link
> {{{
> if output.m==0:
> << DO APPROPRIATE OPERATIONS FOR THIS CASE >>
> << RETURN >>
> 
> output.edges     = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
> output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
> if output.edges == NULL or output.neighbors == NULL:
> raise MemoryError("Problem while allocating memory (edges or neighbors).")
> }}}
> This is not only a cosmetic change since when `m==0` you allow `output.neighbors==NULL` before the instruction `output.neighbors[0] = output.edges`. So your code is currently not safe.

Hmm, I did as you said, but the same problem might occur also in `init_short_digraph`: if there are no edges, we set `edges=malloc(0)`, and in the next line we test if edges is `NULL`. The result of `malloc(0)` depends on the compiler implementation ![1], so for some compilers it might output `NULL` by default. Do you think we should open a ticket solving this issue?

[1] !http://stackoverflow.com/questions/1073157/zero-size-malloc


---

Comment by git created at 2015-08-17 15:10:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2015-08-17 16:17:17

> because the line `if visited[v]:` is followed by an else. Correct?

you did the correct modification.
 
> > In method `strongly_connected_components_digraph_C`.
> ...
> 
> Hmm, I did as you said, but the same problem might occur also in `init_short_digraph`: if there are no edges, we set `edges=malloc(0)`, and in the next line we test if edges is `NULL`. The result of `malloc(0)` depends on the compiler implementation ![1], so for some compilers it might output `NULL` by default. Do you think we should open a ticket solving this issue?
> 
> [1] !http://stackoverflow.com/questions/1073157/zero-size-malloc

I have checked in files `sage/ext/memory_allocator.pyx`. It uses methods like `check_allocarray` which can be found in `memory.pxd`. These methods ensure that if `n==0` then the returned pointer is `NULL`, and this is compiler independent. Furthermore, these methods raise an error if something goes wrong with malloc. So no need for opening a ticket, it's already done ;)
So if you want to be on the safe side and to ease your life, use the memory allocator and/or the `check_alloc` methods, depending on the context.
In your code, it means that you can call

```
output.edges = <uint32_t *> check_allocarray(m, sizeof(uint32_t))
```

and then remove the NULL test.

Of course, what you did for the case `m==0` is also important. 

David.


---

Comment by git created at 2015-08-17 17:02:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by borassi created at 2015-08-17 17:02:59

Changing status from needs_work to needs_review.


---

Comment by borassi created at 2015-08-17 17:02:59

Done!


---

Comment by dcoudert created at 2015-08-17 18:43:09

Good.
David.


---

Comment by dcoudert created at 2015-08-17 18:43:09

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-08-18 21:33:26

I'll take it this is caused by this ticket:

http://build.sagemath.org/release/builders/%20%20slow%20AIMS%20%20%28Debian%207%2064%20bit%29%20incremental/builds/40/steps/compile/logs/stdio


---

Comment by vbraun created at 2015-08-18 21:33:26

Changing status from positive_review to needs_work.


---

Comment by git created at 2015-08-18 22:12:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by borassi created at 2015-08-18 22:16:01

Yes, I think the problem is caused by this ticket, because I changed the language of `static_sparse_graph` from C to C++ (I needed vectors). In particular, I think the problem was the use of `stdint` library, as explained in [1]. I replaced this library with `limits`, and now it should work.

[1] !http://stackoverflow.com/questions/3233054/error-int32-max-was-not-declared-in-this-scope


---

Comment by dcoudert created at 2015-08-19 06:49:51

Hello,

could you change in the doctest of `tarjan_strongly_connected_components`

```
       sage: for i in range(100):                                     # long
       ...        g = digraphs.RandomDirectedGNP(100,.05)
```

with

```
       sage: for i in range(100):                                     # long
       ....:      g = digraphs.RandomDirectedGNP(100,.05)
```

so use `...` with `....:` for continuation.
Sorry to miss it before.
And also you can now change `for i in range(100)` with something small in all test.

David.


---

Comment by git created at 2015-08-19 08:08:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by borassi created at 2015-08-19 08:13:49

Changing status from needs_work to needs_review.


---

Comment by borassi created at 2015-08-19 08:13:49

Done!


---

Comment by dcoudert created at 2015-08-19 09:59:56

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2015-08-19 09:59:56

This patch passes all tests/docbuild/etc. on my mac.

David.


---

Comment by vbraun created at 2015-08-21 01:56:19

Resolution: fixed


---

Comment by jdemeyer created at 2017-06-02 09:38:07

Replying to [comment:13 dcoudert]:
> {{{
> cdef int i
> cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
> for i,v in enumerate(G.vertex_iterator()):
>     output[scc[i]].append(v)
> }}}

Why the `# We cannot use [] here`??? I am changing this in #23123 to use `[]`.


---

Comment by dcoudert created at 2017-06-03 10:36:58

If I remember well (but it was 2 years ago), at the time Michele implemented the method,  the `output` list was containing `nscc` pointers to the same (empty) list when using `[]`.
