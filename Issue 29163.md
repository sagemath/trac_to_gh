# Issue 29163: Cotangent producing incorrect real/imaginary parts.

Issue created by migration from https://trac.sagemath.org/ticket/29400

Original creator: @TheFool5

Original creation time: 2020-03-24 16:02:42

Keywords: defect cotangent complex

While doing some complex analysis, I encountered a bug when evaluating the cotangent function of a complex number when multiplied by a complex number.  When p and q are complex, real(p*cot(q)) or imag(p*cot(q)) produces a wrong result, while real(p/tan(q)) or imag(p/tan(q)) produces the correct result.

For example:


```
sage: a=(1+2*i)/tan(3+4*i)                                                                                                                                                                                 
sage: b=(1+2*i)*cot(3+4*i)
sage: a.real().n()                                                                                                                                                                                         
2.00110119720514
sage: b.real().n()                                                                                                                                                                                         
-2.00147637268110
sage: a.imag().n()                                                                                                                                                                                         
-1.00101956794753
sage: b.imag().n()                                                                                                                                                                                         
1.00026921699559
```


Additionally, when trying to numerically evaluate b with cotangent, it simply returns an error.  The numerical evaluation of a with tangent is returned without error.


```
sage: a.n()                                                                                                                                                                                                
2.00110119720513 - 1.00101956794753*I
sage: b.n()                                                                                                                                                                                                
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-97-d3276c847f4d> in <module>
----> 1 b.n()

/usr/lib/python3.8/site-packages/sage/structure/element.pyx in sage.structure.element.Element.n (build/cythonized/sage/structure/element.c:8033)()
    857             0.666666666666667
    858         """
--> 859         return self.numerical_approx(prec, digits, algorithm)
    860 
    861     def _mpmath_(self, prec=53, rounding=None):

/usr/lib/python3.8/site-packages/sage/symbolic/expression.pyx in sage.symbolic.expression.Expression.numerical_approx (build/cythonized/sage/symbolic/expression.cpp:34713)()
   5998             res = x.pyobject()
   5999         else:
-> 6000             raise TypeError("cannot evaluate symbolic expression numerically")
   6001 
   6002         # Important -- the  we get might not be a valid output for numerical_approx in

TypeError: cannot evaluate symbolic expression numerically
```


I conducted this same test using both tangent and cotangent in Maxima.  They are both correct, and agree with the results involving tangent in Sage.  But for whatever reason in Sage, cotangent does not seem to work correctly when evaluating numerically or getting the real/imaginary part.


---

Comment by @TheFool5 created at 2020-03-25 06:08:40

Changing component from numerical to symbolics.


---

Comment by @TheFool5 created at 2020-03-25 06:26:19

After further symbolic testing, I was able to show that getting the real or imaginary part contains a sign error when using cotangent.


```
sage: var('a b c d')                                                                                                                                                                                                                         
(a, b, c, d)
sage: assume(a,'real')
sage: assume(b,'real')                                                                                                                                                                                                                       
sage: assume(c,'real')                                                                                                                                                                                                                       
sage: assume(b,'real')                                                                                                                                                                                                                       
sage: x=(a+b*i)/tan(c+d*i)                                                                                                                                                                                                                   
sage: y=(a+b*i)*cot(c+d*i)                                                                                                                                                                                                                   
sage: x.real().trig_reduce().simplify_full()                                                                                                                                                                                                 
(a*cos(c)*sin(c) + b*cosh(d)*sinh(d))/(cosh(d)^2 + sin(c)^2 - 1)
sage: y.real().trig_reduce().simplify_full()                                                                                                                                                                                                 
(a*cos(c)*sin(c) - b*cosh(d)*sinh(d))/(sin(c)^2 + sinh(d)^2)
```


The numerator of y clearly has a sign error, so the formula being used to get the real part is incorrect when using cotangent.  The denominators are equivalent because cosh<sup>2</sup>(d)-1=sinh<sup>2</sup>(d).  A similar sign error is present when taking the imaginary part.


```
sage: x.imag().trig_reduce().simplify_full()                                                                                                                                                                                                 
(b*cos(c)*sin(c) - a*cosh(d)*sinh(d))/(cosh(d)^2 + sin(c)^2 - 1)
sage: y.imag().trig_reduce().simplify_full()                                                                                                                                                                                                 
(b*cos(c)*sin(c) + a*cosh(d)*sinh(d))/(sin(c)^2 + sinh(d)^2)
```



---

Comment by @DaveWitteMorris created at 2020-03-26 05:30:40

Thanks for pointing out the bugs, and for your further comments.

I think these are two different issues, so I have opened a new ticket (#29409) to discuss the `TypeError` caused by `b.n()`, which I think it is easy to fix. 

This ticket can focus on fixing the erroneous results that are described in the title. I have no idea what is wrong, but I did notice that there is no need for `a` and `b` in your example: the sign error already arises in the imaginary part of `cot(c + d*I)`.

```
sage: var('c d')
(c, d)
sage: assume(c,'real')
sage: assume(d,'real')
sage: cot(c + d*I).imag().trig_reduce().simplify_full()
cosh(d)*sinh(d)/(sin(c)^2 + sinh(d)^2)
sage: (1/tan(c + d*I)).imag().trig_reduce().simplify_full()
-cosh(d)*sinh(d)/(cosh(d)^2 + sin(c)^2 - 1)
```

There does not seem to be a sign error if we use a complex variable, instead of writing out `c + d*I`:

```
sage: var('z')
z
sage: cot(z*I).imag()
-cosh(real_part(z))*sinh(real_part(z))/(sin(imag_part(z))^2 + sinh(real_part(z))^2)
```



---

Comment by mkoeppe created at 2020-05-01 04:28:42

Moving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.


---

Attachment

correct sign error in imaginary part of cotangent


---

Comment by @DaveWitteMorris created at 2020-05-19 06:53:43

Changing keywords from "defect cotangent complex" to "defect cotangent  sympy".


---

Comment by @DaveWitteMorris created at 2020-05-19 06:53:43

Changing priority from minor to major.


---

Comment by @DaveWitteMorris created at 2020-05-19 06:53:43

This is a sympy bug, so I reported it upstream ([#19366](https://github.com/sympy/sympy/issues/19366)). The imaginary part of the `as_real_imag` method of sympy's cotangent class (`sympy.functions.elementary.trigonometric.cot`) has the wrong sign.

```
1453      def as_real_imag(self, deep=True, **hints):
1454          re, im = self._as_real_imag(deep=deep, **hints)
1455          if im:
1456              denom = cos(2*re) - cosh(2*im)
1457 -            return (-sin(2*re)/denom, -sinh(2*im)/denom)
1457 +            return (-sin(2*re)/denom, sinh(2*im)/denom)
1458          else:
1459              return (self.func(re), S.Zero)
```



---

Comment by @DaveWitteMorris created at 2020-05-31 17:24:31

This is fixed in [sympy pull request 19468](https://github.com/sympy/sympy/pull/19468). I hope this will be merged in sympy 1.7.


---

Comment by @DaveWitteMorris created at 2020-06-03 00:59:22

The pull request has been merged into sympy master.


---

Comment by @DaveWitteMorris created at 2020-06-03 00:59:22

Changing status from new to needs_info.


---

Comment by mkoeppe created at 2021-05-10 17:42:09

Moving to 9.4, as 9.3 has been released.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by @DaveWitteMorris created at 2021-10-08 05:28:12

Testing in `CoCalc` shows that this was already fixed in 9.3 (presumably because Sympy was updated to 1.7 in #30985).

```
sage: a=(1+2*i)/tan(3+4*i)
sage: b=(1+2*i)*cot(3+4*i)
sage: a.real().n() - b.real().n()
4.44089209850063e-16
```

So we just need a doctest.


---

Comment by @DaveWitteMorris created at 2021-10-08 05:28:12

Changing status from needs_info to needs_work.


---

Comment by @DaveWitteMorris created at 2021-10-09 17:21:32

Changing status from needs_work to needs_review.


---

Comment by @DaveWitteMorris created at 2021-10-09 17:21:32

The PR just adds a doctest to verify that `cot(1 + i).imag().n()` is equal to `(1/tan(1 + i)).imag().n()` (modulo to an error tolerance of `10^-12`). It fails in 9.2:

```
sage: cot(1 + i).imag().n() - (1/tan(1 + i)).imag().n()
1.73602828579185
```

But it passes in 9.3:

```
sage: cot(1 + i).imag().n() - (1/tan(1 + i)).imag().n()
-1.11022302462516e-16
```

----
New commits:


---

Comment by mkoeppe created at 2021-10-10 04:41:43

Changing status from needs_review to positive_review.


---

Comment by @DaveWitteMorris created at 2021-10-10 05:12:29

Thanks!


---

Comment by vbraun created at 2021-10-10 22:34:38

Resolution: fixed
