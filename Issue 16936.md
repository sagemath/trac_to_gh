# Issue 16936: Poset: faster is_distributive_lattice

archive/issues_016936.json:
```json
{
    "body": "CC:  tscrim\n\nAfter #17121 it is faster to say `P.is_lattice() and LatticePoset(P).is_distibutive()` than `P._hasse_diagram.is_distributive_lattice()`. However, there exists also fast algorithm to directly check if a given poset is distributive lattice, see http://www.lirmm.fr/~nourine/Papiers/dist-recognition.ps .\n\nTo show that algorithm works I did a small example code, which is not optimized at all. I will continue with this later. If someone is going to implement this, please add a note to this ticket.\n\n\n```\ndef join_irreducibles(self): return [e for e in self if len(self.lower_covers(e))==1]\ndef meet_irreducibles(self): return [e for e in self if len(self.upper_covers(e))==1]\n\ndef is_distributive_lattice(self):\n    if ( not self.is_graded() or not self.is_bounded() or not\n    self.rank() == len(join_irreducibles(self)) == len(meet_irreducibles(self)) ):\n        return False\n    return _is_distributive_lattice_workhorse(self)\n\ndef _is_distributive_lattice_workhorse(P):\n    # Real workhorse, a recursive algorithm.\n    # To show how the reduction goes:\n    P.show()\n    if not len([x for x in P if len(P.upper_covers(x))==1])==len([x for x in P if len(P.lower_covers(x))==1])==P.rank():\n        return False\n    if P.cardinality() == 2:\n        if len(P.minimal_elements())==1:\n            return True\n        return \"This should not happen!\"\n    M=P.subposet([x for x in P if len(P.upper_covers(x))==1])\n    if len(M) == 0:\n        return \"This should not happen!\"\n    m=M.minimal_elements()[0]\n    if len(P.upper_covers(m)) > 1:\n        return \"This should not happen!\"\n    m_=P.upper_covers(m)[0]\n    M_=P.subposet([x for x in P if not x in P.closed_interval(P.bottom(), m)])\n    if len(M_.minimal_elements()) > 1:\n        return False\n    j=M_.minimal_elements()\n    j=j[0]\n    # Does not really work, but counter-example must be quite big lattice.\n    Z1=P.interval(P.bottom(), m)\n    Z2=Set(P.interval(j, m_))\n    for z in Z1:\n        if len(Set(P.upper_covers(z)).difference(Z1)) != 1:\n            return False\n        if Set(P.upper_covers(z)).intersection(Z2).cardinality() != 1:           \n            return False\n        Z2 = Z2.difference(P.upper_covers(z))\n    if Z2.cardinality() > 0:\n        return False\n    P_=P.subposet(x for x in P if not x in P.interval(P.bottom(), m))\n    return _is_distributive_lattice_workhorse(P_)\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/17173\n\n",
    "created_at": "2014-10-18T07:24:03Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "title": "Poset: faster is_distributive_lattice",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16936",
    "user": "jmantysalo"
}
```
CC:  tscrim

After #17121 it is faster to say `P.is_lattice() and LatticePoset(P).is_distibutive()` than `P._hasse_diagram.is_distributive_lattice()`. However, there exists also fast algorithm to directly check if a given poset is distributive lattice, see http://www.lirmm.fr/~nourine/Papiers/dist-recognition.ps .

To show that algorithm works I did a small example code, which is not optimized at all. I will continue with this later. If someone is going to implement this, please add a note to this ticket.


```
def join_irreducibles(self): return [e for e in self if len(self.lower_covers(e))==1]
def meet_irreducibles(self): return [e for e in self if len(self.upper_covers(e))==1]

def is_distributive_lattice(self):
    if ( not self.is_graded() or not self.is_bounded() or not
    self.rank() == len(join_irreducibles(self)) == len(meet_irreducibles(self)) ):
        return False
    return _is_distributive_lattice_workhorse(self)

def _is_distributive_lattice_workhorse(P):
    # Real workhorse, a recursive algorithm.
    # To show how the reduction goes:
    P.show()
    if not len([x for x in P if len(P.upper_covers(x))==1])==len([x for x in P if len(P.lower_covers(x))==1])==P.rank():
        return False
    if P.cardinality() == 2:
        if len(P.minimal_elements())==1:
            return True
        return "This should not happen!"
    M=P.subposet([x for x in P if len(P.upper_covers(x))==1])
    if len(M) == 0:
        return "This should not happen!"
    m=M.minimal_elements()[0]
    if len(P.upper_covers(m)) > 1:
        return "This should not happen!"
    m_=P.upper_covers(m)[0]
    M_=P.subposet([x for x in P if not x in P.closed_interval(P.bottom(), m)])
    if len(M_.minimal_elements()) > 1:
        return False
    j=M_.minimal_elements()
    j=j[0]
    # Does not really work, but counter-example must be quite big lattice.
    Z1=P.interval(P.bottom(), m)
    Z2=Set(P.interval(j, m_))
    for z in Z1:
        if len(Set(P.upper_covers(z)).difference(Z1)) != 1:
            return False
        if Set(P.upper_covers(z)).intersection(Z2).cardinality() != 1:           
            return False
        Z2 = Z2.difference(P.upper_covers(z))
    if Z2.cardinality() > 0:
        return False
    P_=P.subposet(x for x in P if not x in P.interval(P.bottom(), m))
    return _is_distributive_lattice_workhorse(P_)
```


Issue created by migration from https://trac.sagemath.org/ticket/17173





---

archive/issue_comments_224440.json:
```json
{
    "body": "Also deprecated same function from `hasse_diagram.py`.\n----\nNew commits:",
    "created_at": "2014-10-20T06:41:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224440",
    "user": "jmantysalo"
}
```

Also deprecated same function from `hasse_diagram.py`.
----
New commits:



---

archive/issue_comments_224441.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-10-20T06:41:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224441",
    "user": "jmantysalo"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_224442.json:
```json
{
    "body": "Hello Jori !\n\nA couple of comments:\n\nPlease, try to make your code a bit better-looking:\n\n\n```diff\n-if ( not self.is_graded() or not self.is_bounded() or not\n-     self.rank() == len([e for e in self if len(self.lower_covers(e))==1]) ==\n-     len([e for e in self if len(self.upper_covers(e))==1]) ):\n-    return False\n-return self._is_distributive_lattice_recursion()\n+return (self.is_graded()  and\n+        self.is_bounded() and\n+        (self.rank() == len([e for e in self if len(self.lower_covers(e))==1])\n+                     == len([e for e in self if len(self.upper_covers(e))==1])) and\n+        self._is_distributive_lattice_recursion())\n```\n\n\nBy the way it is very unpleasant to build the list of upper covers when all you want to do is count its length. This is just a call to `in_degree` in the hasse diagram ! \n\nI also see that you compute 'subposet' very often, and I wonder if you should not compute subgraphs instead, as I expect that it is much more efficient (I beware of the `UniqueRepresentation` stuff)\n\nAlso, you cannot write things like that in Sage code\n\n```\n[x for x in self if not x in self.closed_interval(self.bottom(), m)]\n```\n\n\nHere is why:\n\n\n```\nsage: def a():\n....:     print \"Hey\"\n....:     return [1]\n....: [x for x in range(5) if x in a()]\n....: \nHey\nHey\nHey\nHey\nHey\n[1]\n```\n\n\nWhat you want to do is something like `set(self).difference(self.closed_interval(self.bottom(), m))`\n\nThere is also a broken doctest in `hasse_diagram.py`\n\nOh. And I am just noticing that your function does not seem to be recursive at all: you can replace the recursion by a loop ! First create a copy of self, and at each turn of the loop remove some vertices from the copy you work on.\n\nNathann",
    "created_at": "2014-10-20T09:45:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224442",
    "user": "ncohen"
}
```

Hello Jori !

A couple of comments:

Please, try to make your code a bit better-looking:


```diff
-if ( not self.is_graded() or not self.is_bounded() or not
-     self.rank() == len([e for e in self if len(self.lower_covers(e))==1]) ==
-     len([e for e in self if len(self.upper_covers(e))==1]) ):
-    return False
-return self._is_distributive_lattice_recursion()
+return (self.is_graded()  and
+        self.is_bounded() and
+        (self.rank() == len([e for e in self if len(self.lower_covers(e))==1])
+                     == len([e for e in self if len(self.upper_covers(e))==1])) and
+        self._is_distributive_lattice_recursion())
```


By the way it is very unpleasant to build the list of upper covers when all you want to do is count its length. This is just a call to `in_degree` in the hasse diagram ! 

I also see that you compute 'subposet' very often, and I wonder if you should not compute subgraphs instead, as I expect that it is much more efficient (I beware of the `UniqueRepresentation` stuff)

Also, you cannot write things like that in Sage code

```
[x for x in self if not x in self.closed_interval(self.bottom(), m)]
```


Here is why:


```
sage: def a():
....:     print "Hey"
....:     return [1]
....: [x for x in range(5) if x in a()]
....: 
Hey
Hey
Hey
Hey
Hey
[1]
```


What you want to do is something like `set(self).difference(self.closed_interval(self.bottom(), m))`

There is also a broken doctest in `hasse_diagram.py`

Oh. And I am just noticing that your function does not seem to be recursive at all: you can replace the recursion by a loop ! First create a copy of self, and at each turn of the loop remove some vertices from the copy you work on.

Nathann



---

archive/issue_comments_224443.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-10-20T09:45:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224443",
    "user": "ncohen"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_224444.json:
```json
{
    "body": "Replying to [comment:4 ncohen]:\n\n> Please, try to make your code a bit better-looking:\n\nOK, I'll try. I was thinkig about some kind of \"short-circuit test\" first: start with trivial ways to see that poset surely has not the property we are looking for. But your code example is cleaner.\n\n> By the way it is very unpleasant to build the list of upper covers when all you want to do is count its length. This is just a call to `in_degree` in the hasse diagram ! \n\nI need the list. It starts with `x=give_an_array(y)` but if it's length is exactly one, then continues with `z=x[0]`. Or do you mean optimizing it so that if code founds out that `len(self.upper_covers(m)` is at least 2, it returns False?\n\n> Also, you cannot write things like that in Sage code\n> {{{\n> [x for x in self if not x in self.closed_interval(self.bottom(), m)]\n> }}}\n> \n> Here is why:\n\nUh, I somehow thinked that it would be optimized out. But of course it can not be done. I will correct this.\n\n> There is also a broken doctest in `hasse_diagram.py`\n\n?? I didn't touch it, just deprecated a function.\n\n> I also see that you compute 'subposet' very often, and I wonder if you should not compute subgraphs instead, as I expect that it is much more efficient (I beware of the `UniqueRepresentation` stuff)\n\n> Oh. And I am just noticing that your function does not seem to be recursive at all: you can replace the recursion by a loop ! First create a copy of self, and at each turn of the loop remove some vertices from the copy you work on.\n\nHmm... First call to `subposet` can be changed to subgraph and to search of element with in-degree zero.\n\nAnd yes, this can be also changed to direct loop without recursion. Actually I just copied the algorithm without thinking speed; in any case this should now be almost `O(n)` instead of `O(n^3)` in current version.\n\nBut elements can not be removed from poset; vertices can be removed from graph (with right internal implementation). I guess it is faster that way; only code might seem slightly complicated.\n\nThanks for comments! I'll continue with these later.",
    "created_at": "2014-10-20T12:27:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224444",
    "user": "jmantysalo"
}
```

Replying to [comment:4 ncohen]:

> Please, try to make your code a bit better-looking:

OK, I'll try. I was thinkig about some kind of "short-circuit test" first: start with trivial ways to see that poset surely has not the property we are looking for. But your code example is cleaner.

> By the way it is very unpleasant to build the list of upper covers when all you want to do is count its length. This is just a call to `in_degree` in the hasse diagram ! 

I need the list. It starts with `x=give_an_array(y)` but if it's length is exactly one, then continues with `z=x[0]`. Or do you mean optimizing it so that if code founds out that `len(self.upper_covers(m)` is at least 2, it returns False?

> Also, you cannot write things like that in Sage code
> {{{
> [x for x in self if not x in self.closed_interval(self.bottom(), m)]
> }}}
> 
> Here is why:

Uh, I somehow thinked that it would be optimized out. But of course it can not be done. I will correct this.

> There is also a broken doctest in `hasse_diagram.py`

?? I didn't touch it, just deprecated a function.

> I also see that you compute 'subposet' very often, and I wonder if you should not compute subgraphs instead, as I expect that it is much more efficient (I beware of the `UniqueRepresentation` stuff)

> Oh. And I am just noticing that your function does not seem to be recursive at all: you can replace the recursion by a loop ! First create a copy of self, and at each turn of the loop remove some vertices from the copy you work on.

Hmm... First call to `subposet` can be changed to subgraph and to search of element with in-degree zero.

And yes, this can be also changed to direct loop without recursion. Actually I just copied the algorithm without thinking speed; in any case this should now be almost `O(n)` instead of `O(n^3)` in current version.

But elements can not be removed from poset; vertices can be removed from graph (with right internal implementation). I guess it is faster that way; only code might seem slightly complicated.

Thanks for comments! I'll continue with these later.



---

archive/issue_comments_224445.json:
```json
{
    "body": "> I need the list.\n\nNot there\n\n```\nlen([e for e in self if len(self.lower_covers(e))==1])\n```\n\n\nnor there\n\n\n```\nif len(self.upper_covers(m))==1:\n```\n\n\nnor there\n\n```\nif len(M_.minimal_elements()) > 1:\n```\n\n\n> It starts with `x=give_an_array(y)` but if it's length is exactly one, then continues with `z=x[0]`. Or do you mean optimizing it so that if code founds out that `len(self.upper_covers(m)` is at least 2, it returns False?\n\nI have not read the algorithm closely yet, I do not know what it does exactly. There are places in the code, however, where those lists are created only to compute their length, e.g. above.\n\n> Uh, I somehow thinked that it would be optimized out. But of course it can not be done. I will correct this.\n\nPython is the worst language ever. It is a script. I hate scripts.\n\n> ?? I didn't touch it, just deprecated a function.\n\nyes yes, but the deprecation breaks the tests. Run the tests and see ! It is trivial, however, you probably only need to fix the output (which now contains the deprecation warning).\n\n> Thanks for comments! I'll continue with these later.\n\nGood luck ! `:-)`\n\nNathann",
    "created_at": "2014-10-20T12:32:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224445",
    "user": "ncohen"
}
```

> I need the list.

Not there

```
len([e for e in self if len(self.lower_covers(e))==1])
```


nor there


```
if len(self.upper_covers(m))==1:
```


nor there

```
if len(M_.minimal_elements()) > 1:
```


> It starts with `x=give_an_array(y)` but if it's length is exactly one, then continues with `z=x[0]`. Or do you mean optimizing it so that if code founds out that `len(self.upper_covers(m)` is at least 2, it returns False?

I have not read the algorithm closely yet, I do not know what it does exactly. There are places in the code, however, where those lists are created only to compute their length, e.g. above.

> Uh, I somehow thinked that it would be optimized out. But of course it can not be done. I will correct this.

Python is the worst language ever. It is a script. I hate scripts.

> ?? I didn't touch it, just deprecated a function.

yes yes, but the deprecation breaks the tests. Run the tests and see ! It is trivial, however, you probably only need to fix the output (which now contains the deprecation warning).

> Thanks for comments! I'll continue with these later.

Good luck ! `:-)`

Nathann



---

archive/issue_comments_224446.json:
```json
{
    "body": "If I convert this to loop, I must have a working copy on Hasse diagram. Do I then still have linear extension? I must find a minimal element of subposet containing only meet-irreducible elements, i.e. a meet-irreducible element that is not greater than any other meet-irreducible element. For a poset `P` I can found it just looping throught `P` --- it will give elements by (some) linear extension.\n\nIn other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?\n\nI forgot one place where `minimal_elements()` was computed twice. Otherwise there is no unneeded lists generated in loop.",
    "created_at": "2014-10-20T15:17:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224446",
    "user": "jmantysalo"
}
```

If I convert this to loop, I must have a working copy on Hasse diagram. Do I then still have linear extension? I must find a minimal element of subposet containing only meet-irreducible elements, i.e. a meet-irreducible element that is not greater than any other meet-irreducible element. For a poset `P` I can found it just looping throught `P` --- it will give elements by (some) linear extension.

In other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?

I forgot one place where `minimal_elements()` was computed twice. Otherwise there is no unneeded lists generated in loop.



---

archive/issue_comments_224447.json:
```json
{
    "body": "Hello !\n\n> In other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?\n\nHmmmmm... If the vertex set consists of integers this will not happens, but is that really a problem ? You can also store and manage the list of vertices yourself. Or rename the set of points.\n\n> I forgot one place where `minimal_elements()` was computed twice. Otherwise there is no unneeded lists generated in loop.\n\nWhat about this ?\n\n\n```\nlen([e for e in self if len(self.lower_covers(e))==1])\nif len(self.upper_covers(m))==1:\nif len(M_.minimal_elements()) > 1:\n```\n\n\nnathann",
    "created_at": "2014-10-20T15:21:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224447",
    "user": "ncohen"
}
```

Hello !

> In other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?

Hmmmmm... If the vertex set consists of integers this will not happens, but is that really a problem ? You can also store and manage the list of vertices yourself. Or rename the set of points.

> I forgot one place where `minimal_elements()` was computed twice. Otherwise there is no unneeded lists generated in loop.

What about this ?


```
len([e for e in self if len(self.lower_covers(e))==1])
if len(self.upper_covers(m))==1:
if len(M_.minimal_elements()) > 1:
```


nathann



---

archive/issue_comments_224448.json:
```json
{
    "body": "Replying to [comment:8 ncohen]:\n> Hello !\n> \n> > In other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?\n> \n> Hmmmmm... If the vertex set consists of integers this will not happens, but is that really a problem ? You can also store and manage the list of vertices yourself. Or rename the set of points.\n\nHasse diagram has always integers `0,...,n-1` as labels. But I don't quite get this: if I write code that manages list of vertex labels, I am doing code that posets code already does.\n\nActually I think that I will start discussion about this on sage-devel.",
    "created_at": "2014-10-20T16:50:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224448",
    "user": "jmantysalo"
}
```

Replying to [comment:8 ncohen]:
> Hello !
> 
> > In other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?
> 
> Hmmmmm... If the vertex set consists of integers this will not happens, but is that really a problem ? You can also store and manage the list of vertices yourself. Or rename the set of points.

Hasse diagram has always integers `0,...,n-1` as labels. But I don't quite get this: if I write code that manages list of vertex labels, I am doing code that posets code already does.

Actually I think that I will start discussion about this on sage-devel.



---

archive/issue_comments_224449.json:
```json
{
    "body": "Travis: This is an old ticket that has been lying for two years. What you think about adding this as a recursive function? I think that it is still better than not having this at all.",
    "created_at": "2016-04-12T10:41:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224449",
    "user": "jmantysalo"
}
```

Travis: This is an old ticket that has been lying for two years. What you think about adding this as a recursive function? I think that it is still better than not having this at all.



---

archive/issue_comments_224450.json:
```json
{
    "body": "Needs a rebase from the latest beta, but I will review this.",
    "created_at": "2016-04-13T13:40:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224450",
    "user": "tscrim"
}
```

Needs a rebase from the latest beta, but I will review this.



---

archive/issue_comments_224451.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-19T07:40:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224451",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_224452.json:
```json
{
    "body": "Merged, but I am re-reading the code, compiling and testing. Not ready for review yet.",
    "created_at": "2016-04-19T07:41:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224452",
    "user": "jmantysalo"
}
```

Merged, but I am re-reading the code, compiling and testing. Not ready for review yet.



---

archive/issue_comments_224453.json:
```json
{
    "body": "New commits:",
    "created_at": "2019-11-23T20:37:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224453",
    "user": "chapoton"
}
```

New commits:



---

archive/issue_comments_224454.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-23T20:47:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16936",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16936#issuecomment-224454",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:
