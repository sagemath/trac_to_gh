# Issue 14788: automatically injected function does not work with desolve

archive/issues_014788.json:
```json
{
    "body": "Keywords: desolve function\n\nThe following does not work:\n\n```\nsage: x = var('x')\nsage: f = function('y', x)\nsage: desolve(diff(y,x)-y == 0,y)\nTraceback (click to the left of this block for traceback)\n...\nTypeError\n```\n\naltough `y` is automatically injected to the gobal namespace.\n\nThis is because `y` is of the wrong type:\n\n```\nsage: f, type(f)\n(y(x), sage.symbolic.expression.Expression)\nsage: y, type(y)\n(y, sage.symbolic.function_factory.NewSymbolicFunction)                                      \n```\n\nIt works with `f`:\n\n```\nsage: desolve(diff(f,x)-f == 0,f)                                                            \nc*e^x\n```\n\n\nThis is confusing, especially, since in the docstring of `function` under \"Note\" you can find\n\n>  The new function is both returned and automatically injected into the global namespace.                                                                                  \n\nTherefore, it is not absurd to assume that this automatically injected variable is the one I want to use, i.e. the one you would get by `y = function('y', x)` (similar to the `var`-command).\n\n(If this is behavior of `function` is (really) on purpose, then at least the error message of `desolve` should be more clearifying and give a hint.)\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/15025\n\n",
    "created_at": "2013-08-09T09:49:57Z",
    "labels": [
        "symbolics",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "automatically injected function does not work with desolve",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14788",
    "user": "dkrenn"
}
```
Keywords: desolve function

The following does not work:

```
sage: x = var('x')
sage: f = function('y', x)
sage: desolve(diff(y,x)-y == 0,y)
Traceback (click to the left of this block for traceback)
...
TypeError
```

altough `y` is automatically injected to the gobal namespace.

This is because `y` is of the wrong type:

```
sage: f, type(f)
(y(x), sage.symbolic.expression.Expression)
sage: y, type(y)
(y, sage.symbolic.function_factory.NewSymbolicFunction)                                      
```

It works with `f`:

```
sage: desolve(diff(f,x)-f == 0,f)                                                            
c*e^x
```


This is confusing, especially, since in the docstring of `function` under "Note" you can find

>  The new function is both returned and automatically injected into the global namespace.                                                                                  

Therefore, it is not absurd to assume that this automatically injected variable is the one I want to use, i.e. the one you would get by `y = function('y', x)` (similar to the `var`-command).

(If this is behavior of `function` is (really) on purpose, then at least the error message of `desolve` should be more clearifying and give a hint.)


Issue created by migration from https://trac.sagemath.org/ticket/15025





---

archive/issue_comments_188606.json:
```json
{
    "body": "It seems what gets injected and what gets returned is always an issue. On top level,\n\n```\nx = var('x')\n```\n\nis redundant: `var('x')` already injects the binding. On the other hand,\n\n```\nt = SR.var('t')\n```\n\nis not redundant because the methods on `SR` do not have injection side effects.\n\nLooking at the side-effect free methods:\n\n```\nsage: from sage.symbolic.function_factory import function as new_function\nsage: new_function('g')\ng\nsage: new_function('g',x)\ng(x)\nsage: type(new_function('g'))\nsage.symbolic.function_factory.NewSymbolicFunction\nsage: type(new_function('g',x))\nsage.symbolic.expression.Expression\n```\n\nyou see the design problem: The routine that constructs new symbolic functions creates entirely different objects depending on the arguments given.\n\nA `NewSymbolicFunction` is really a different kind of object: it goes into the \"operator\" slot of symbolic expressions:\n\n```\nsage: (y(x)).operator()\ny\nsage: (2*x).operator()\n<function operator.mul>\n```\n\nI understand how the shorthand `new_function('f',x)` was  considered convenient, but it really muddles the interface and it's only one character shorter than the unambiguous `new_function('f')(x)`.\n\nThe confusion is compounded by the top-level `function` which does inject the function into the global namespace as well, but both `function('f')` and `function('f',x)` inject the same thing into the global namespace: the NewSymbolicFunction. It has to do that because after typing either, one would expect f(x) to work. But it does raise the expectation that after declaring `function('f',x)`, the system would somehow know that even the bare function `f` has something to do with `x`. It doesn't:\n\n```\nsage: var('t')\nt\nsage: function('f',t)\nf(t)\nsage: f.number_of_arguments()\n0\nsage: f.variables()\n()\nsage: f.default_variable()\nx\n```\n\nYou would get the same results from `function('f')`.\n\nFor the problem at hand in this ticket: The problem is that `desolve` really wants a symbolic expression, and that there's no good way of turning a bare function into a symbolic expression: It might try \n\n```\nf( *(f.default_variable() for i in range(f.number_of_arguments())))\n```\n\nbut you'll quickly see why that's a senseless try.\n\n**IN SHORT:**\n- The interface for `function` leads to wrong expectations by the user\n- The writer of the documentation of `function` was equally confused\n- `desolve` should return a more informative error message when the given argument cannot be turned into a symbolic expression.",
    "created_at": "2013-08-10T17:47:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14788",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14788#issuecomment-188606",
    "user": "nbruin"
}
```

It seems what gets injected and what gets returned is always an issue. On top level,

```
x = var('x')
```

is redundant: `var('x')` already injects the binding. On the other hand,

```
t = SR.var('t')
```

is not redundant because the methods on `SR` do not have injection side effects.

Looking at the side-effect free methods:

```
sage: from sage.symbolic.function_factory import function as new_function
sage: new_function('g')
g
sage: new_function('g',x)
g(x)
sage: type(new_function('g'))
sage.symbolic.function_factory.NewSymbolicFunction
sage: type(new_function('g',x))
sage.symbolic.expression.Expression
```

you see the design problem: The routine that constructs new symbolic functions creates entirely different objects depending on the arguments given.

A `NewSymbolicFunction` is really a different kind of object: it goes into the "operator" slot of symbolic expressions:

```
sage: (y(x)).operator()
y
sage: (2*x).operator()
<function operator.mul>
```

I understand how the shorthand `new_function('f',x)` was  considered convenient, but it really muddles the interface and it's only one character shorter than the unambiguous `new_function('f')(x)`.

The confusion is compounded by the top-level `function` which does inject the function into the global namespace as well, but both `function('f')` and `function('f',x)` inject the same thing into the global namespace: the NewSymbolicFunction. It has to do that because after typing either, one would expect f(x) to work. But it does raise the expectation that after declaring `function('f',x)`, the system would somehow know that even the bare function `f` has something to do with `x`. It doesn't:

```
sage: var('t')
t
sage: function('f',t)
f(t)
sage: f.number_of_arguments()
0
sage: f.variables()
()
sage: f.default_variable()
x
```

You would get the same results from `function('f')`.

For the problem at hand in this ticket: The problem is that `desolve` really wants a symbolic expression, and that there's no good way of turning a bare function into a symbolic expression: It might try 

```
f( *(f.default_variable() for i in range(f.number_of_arguments())))
```

but you'll quickly see why that's a senseless try.

**IN SHORT:**
- The interface for `function` leads to wrong expectations by the user
- The writer of the documentation of `function` was equally confused
- `desolve` should return a more informative error message when the given argument cannot be turned into a symbolic expression.



---

archive/issue_comments_188607.json:
```json
{
    "body": "A similar problem was just hit on [this ask question](http://ask.sagemath.org/question/25641/typeerror-in-creating-ode-variable/).\n\nThe bug is about wrong variable injection (the value injected into the Python variable does not correspond to the returned value, while it is claimed), not about `desolve`:\n\n\n```\nsage: z = function('y', x)\nsage: y\ny\nsage: z\ny(x)\nsage: y == z\nFalse\nsage: type(y)\n<class 'sage.symbolic.function_factory.NewSymbolicFunction'>\nsage: type(z)\n<type 'sage.symbolic.expression.Expression'>\n```\n\n\nBesides fixing this bug, i have nothing against removing automatic variable injection from Sage (which seems to concern only `var()` and `function()`), since it creates a lot of confusion between symbolic and Python variables among new users, for example we can see a lot of `var('n') ; n=2` on ask.sagemath.org, as if `var()` was a kind of variable declaration.\n\nAs for the `NewSymbolicFunction` vs `Expression` issue depending on the arguments of `function()`, our options are: \n- create two distinct Python functions for the two situations,\n- deprecate the use of `function('y', x)`,\n- do not touch anything and provide a better documentation in the `function()` function.\n\nI like the second one since it goes towards better consistency. But, as for removing the ugly `var()` (or even the ugly `RR` that breaks the `RDF`, `RIF`, `RLF` naming scheme and causes meaningless discussions about whether `Infinity` or `NaN` belong to it), i expect not everyone to agree, even if this would help newcomers to grasp Sage's logic.",
    "created_at": "2015-01-30T12:26:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14788",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14788#issuecomment-188607",
    "user": "tmonteil"
}
```

A similar problem was just hit on [this ask question](http://ask.sagemath.org/question/25641/typeerror-in-creating-ode-variable/).

The bug is about wrong variable injection (the value injected into the Python variable does not correspond to the returned value, while it is claimed), not about `desolve`:


```
sage: z = function('y', x)
sage: y
y
sage: z
y(x)
sage: y == z
False
sage: type(y)
<class 'sage.symbolic.function_factory.NewSymbolicFunction'>
sage: type(z)
<type 'sage.symbolic.expression.Expression'>
```


Besides fixing this bug, i have nothing against removing automatic variable injection from Sage (which seems to concern only `var()` and `function()`), since it creates a lot of confusion between symbolic and Python variables among new users, for example we can see a lot of `var('n') ; n=2` on ask.sagemath.org, as if `var()` was a kind of variable declaration.

As for the `NewSymbolicFunction` vs `Expression` issue depending on the arguments of `function()`, our options are: 
- create two distinct Python functions for the two situations,
- deprecate the use of `function('y', x)`,
- do not touch anything and provide a better documentation in the `function()` function.

I like the second one since it goes towards better consistency. But, as for removing the ugly `var()` (or even the ugly `RR` that breaks the `RDF`, `RIF`, `RLF` naming scheme and causes meaningless discussions about whether `Infinity` or `NaN` belong to it), i expect not everyone to agree, even if this would help newcomers to grasp Sage's logic.



---

archive/issue_comments_188608.json:
```json
{
    "body": "See also #17447, #14270\n\nFWIW, in Sympy `Function` creates an `UndefinedFunction` which is clear enough, and you get simply\n\n```\nIn [2]: f = Function('f',x)\n...\nTypeError: __new__() takes exactly 2 arguments (3 given)\n```\n",
    "created_at": "2015-01-30T14:42:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14788",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14788#issuecomment-188608",
    "user": "rws"
}
```

See also #17447, #14270

FWIW, in Sympy `Function` creates an `UndefinedFunction` which is clear enough, and you get simply

```
In [2]: f = Function('f',x)
...
TypeError: __new__() takes exactly 2 arguments (3 given)
```




---

archive/issue_comments_188609.json:
```json
{
    "body": "Thanks for the pointers !",
    "created_at": "2015-01-30T15:05:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14788",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14788#issuecomment-188609",
    "user": "tmonteil"
}
```

Thanks for the pointers !



---

archive/issue_comments_188610.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-03-19T15:45:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14788",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14788#issuecomment-188610",
    "user": "rws"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_188611.json:
```json
{
    "body": "I think it's a duplicate of #17701 (ready for review). True?",
    "created_at": "2016-03-19T15:45:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14788",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14788#issuecomment-188611",
    "user": "rws"
}
```

I think it's a duplicate of #17701 (ready for review). True?



---

archive/issue_comments_188612.json:
```json
{
    "body": "outdated, closing",
    "created_at": "2021-12-04T12:39:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14788",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14788#issuecomment-188612",
    "user": "dimpase"
}
```

outdated, closing



---

archive/issue_comments_188613.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-12-04T12:39:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14788",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14788#issuecomment-188613",
    "user": "dimpase"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_188614.json:
```json
{
    "body": "Resolution: invalid",
    "created_at": "2022-01-08T21:27:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14788",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14788#issuecomment-188614",
    "user": "mkoeppe"
}
```

Resolution: invalid
