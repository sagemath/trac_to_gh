# Issue 29239: Improvement on numerical modular symbols

Issue created by migration from https://trac.sagemath.org/ticket/29476

Original creator: wuthrich

Original creation time: 2020-04-07 21:04:14

CC:  @varenyambakshi cremona

Keywords: modular symbols

This is a follow up ticket on the recently closed #21046, where new code for numerical modular symbols for elliptic curves was added.

1. Issue

```
sage: E = EllipticCurve("20a1")
sage: m = E.modular_symbol_numerical()
sage: m(1/2)
```

fails as it attempts to use the code for unitary cusps.

2. Bug

```
sage: E = EllipticCurve("361a1")
sage: ms = E.modular_symbol(+1,implementation="num")
sage: ms(1/19)
158837/603592
sage: _*19.
4.99990556534878
```

is a problem with rounding. The correct value is 5/19.

I will continue to ad if I find things. But if part is solved I will move it on to a next tickets to separate issues when possible.


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by wuthrich created at 2020-04-19 13:10:18

New commits:


---

Comment by wuthrich created at 2020-04-19 13:17:31

Changing status from new to needs_review.


---

Comment by git created at 2020-04-19 16:02:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2020-04-23 16:40:28

Please don't do

```
             sage: f(1/7)      # abs tol 1e-4
-            1.00001356670155
+            0.999844176260303
```

If the expected value is `1.0` just write

```
sage: f(1/7)      # abs tol 1e-4
1.0
```

The `abs tol` keyword is exactly here to take care of the numerical noise.


---

Comment by vdelecroix created at 2020-04-23 16:40:50

Similar here

```
     sage: Mn(3/123)       # abs tol 1e-10
-    3.00000000000001
+    3.00000000000018
```

Just use `3.0`.


---

Comment by vdelecroix created at 2020-04-23 16:41:52

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2020-04-23 16:41:52

You must also remove trailing whitespaces (spaces before end of line).


---

Comment by wuthrich created at 2020-04-24 09:36:34

Replying to [comment:5 vdelecroix]:

I see your point, but surprisingly I disagree. The algorithm produces a floating point number that is within a given precision of the correct result. It is NOT suppose to return the exact value. It will be off and up to a much higher precision all hardware should return the same number. The abs tol that I set is higher than whan is guaranteed by the algorithm.

This ticket changes some behaviour of the algorithm and it now produces different values than before.            

```
sage: f(1/7)      # abs tol 1e-4
-            1.00001356670155
+            0.999844176260303
```

is a case where it actually matters.

It is probably a matter of opinion and taste in the end, but I would like to keep output that is not 1.0 for this as it illustrates the errors that are made. If an exact value is needed, one should not use the approximating functions, anyway.

Of course the trailing spaces need to be removed.


---

Comment by cremona created at 2020-04-24 09:44:18

I think I agree with Chris on this.  If the "expected output" in the test is the exact value, such as 1.0, it does give the impression that the code should output 1.0 and anything else is an indication of an error.  Yet again we are using tests for two different things: as a *test* we could write (in effect) "f(1/7) is within 1e-4 of 1.0" and if that holds then the test passes.  But for *documentation* we want to show the user what they should except to actually see.


---

Comment by vdelecroix created at 2020-04-24 09:50:21

Replying to [comment:8 wuthrich]:
> Replying to [comment:5 vdelecroix]:
> 
> I see your point, but surprisingly I disagree. The algorithm produces a floating point number that is within a given precision of the correct result. It is NOT suppose to return the exact value. It will be off and up to a much higher precision all hardware should return the same number. The abs tol that I set is higher than whan is guaranteed by the algorithm.

Of course your algorithm does not return the exact value. By "expected value" I meant "actual value that the numerical algorithm approximates". Sorry for my unprecise english.

To my mind, you are contradicting yourself.
- If you want to test the actual output of the algorithm then don't write `# abs tol` at all.
- If you want to test how close your algorithm gives an answer to the real one, then do write
  {{{
  sage: my_function(xyz)   # abs. tol 1e-5
  exact_value_that_I_should_be_expecting
  }}}
- If you want to emphasize that the answer is non-exact to the reader, then the detail of the output does not matter. And there is no need to update anything.

You are in between these three: you use `# abs. tol` but at the same time claim that what is written in the output should match the actual value. I have hard time figuring out the purpose of it.

> This ticket changes some behaviour of the algorithm and it now produces different values than before.            
> {{{
> sage: f(1/7)      # abs tol 1e-4
> -            1.00001356670155
> +            0.999844176260303
> }}}
> is a case where it actually matters.

Should that be considered as a regression?

> It is probably a matter of opinion and taste in the end, but I would like to keep output that is not 1.0 for this as it illustrates the errors that are made. If an exact value is needed, one should not use the approximating functions, anyway.


---

Comment by vdelecroix created at 2020-04-24 09:58:53

Replying to [comment:9 cremona]:
> I think I agree with Chris on this.  If the "expected output" in the test is the exact value, such as 1.0, it does give the impression that the code should output 1.0 and anything else is an indication of an error.  Yet again we are using tests for two different things: as a *test* we could write (in effect) "f(1/7) is within 1e-4 of 1.0" and if that holds then the test passes.  But for *documentation* we want to show the user what they should except to actually see.

To my mind the `# abs. tol 1e-4` does indicate that the answer is not precise since floating points provide 14 digits. Of course one can argue that people are not educated enough to know the meaning of `# abs. tol` and the precision of floating point numbers. But more importantly, if you really want to guarantee that what is written matches the output don't use `# abs. tol` at all (or perhaps `# abs. tol 1e-13` if it appears that the behavior is machine dependent).


---

Comment by wuthrich created at 2020-04-24 13:47:14

The issue is easy explained with an example. Say

```
sage: def my_pi(prec=100):
....:     return sqrt(6*sum( 1./n^2 for n in [1..prec] ))
sage: my_pi(10)
3.04936163598207
sage: my_pi(1000)
3.14063805620599
```

I think the doc test for my_pi should NOT check if the answer of my_pi(10) is pi up to n digit, it should check if that given precise answer 3.04936163598207 is exact up to 8 digits, say.

It is a regression in precision, but a speedup. In analogy with the above, the algorithm used to sum 1000 terms when asked to compute it so that the answer can be proven to be smaller than epsilon = 0.1. Now it only needs to do 100 terms and we still know how to prove that the answer is within 0.1. The bounds on convergenve of the sequence are much worst than the actual convergence, so with 100 or 1000 terms it comes close to the actual answer, yet with 100 maybe the error is not 0.0001 rather than 0.00000001.

The basic idea behind the algorithm is that we approximate an integer with an infinite sum. So we want to prove rigorously that the error is <0.5. I can estimate the error of the absolute sum which is an upper bound to the error. I don't want to do any extra work, so I am happy if the answer has an error of 0.1.

Does that help?


---

Comment by vdelecroix created at 2020-04-24 15:32:47

Replying to [comment:12 wuthrich]:
> I think the doc test for my_pi should NOT check if the answer of my_pi(10) is pi up to n digit, it should check if that given precise answer 3.04936163598207 is exact up to 8 digits, say.

Why 8 digits? I still don't see the point of using a big `# abs. tol`. If `3.04936163598207` is the expected output then it is what should be in the doctest without `# abs. tol` at all. I don't understand your usage of `# abs. tol`. And you never explained it.

> It is a regression in precision, but a speedup. 
> <SNIP>
> 
> Does that help?

Sure. Thanks for the explanations.


---

Comment by wuthrich created at 2020-04-24 20:13:32

Oh, that is just the usual issue with floating point computations: There is noise depending on the system; so one can not ask for the number to be equal until the last digit. The cython file uses usual llong, int, but also mpfr Real Numbers.
http://doc.sagemath.org/html/en/developer/coding_basics.html#special-markup-to-influence-doctests .

Is this not what has to be done with all floating point results?


---

Comment by vdelecroix created at 2020-04-24 20:26:37

mpfr does behave the same on any platform (or it is a bug). Numerical noise mostly comes from machine `float` and `double`. So it is not yet clear to me that there is numerical noise.

Even though there would be numerical noise, you don't expect it to affect 70% of the digits of your computations. In other words, you should be using `# abs. tol e-13` and not `# abs. tol e-4`.


---

Comment by wuthrich created at 2020-04-26 10:11:37

Sorry, of course I meant to include `double`. Most of the cases only use `double`, but even if the algorithm uses mpfr, it still returns double. 

I see your point about the value. I am happy to change them to `# abs tol e-13` everywhere if that matters.


---

Comment by git created at 2020-04-26 10:51:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2020-04-26 13:24:01

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2020-04-26 13:24:01

Let put in needs review (for patchbots). Is it ready on your side?


---

Comment by vdelecroix created at 2020-04-26 13:24:47

I don't know what you did with the merging, but the automerging now fails...


---

Comment by vdelecroix created at 2020-04-26 13:24:47

Changing status from needs_review to needs_work.


---

Comment by wuthrich created at 2020-04-26 17:28:26

Changing status from needs_work to needs_review.


---

Comment by wuthrich created at 2020-04-26 17:28:26

Oh? Not sure what went wrong. Let's try with this. I expact a minor problem when merging with #29290. (By the way, where do I see that "the automerging now fails..." ?) 
----
New commits:


---

Comment by wuthrich created at 2020-04-26 17:32:40

Changing status from needs_review to needs_work.


---

Comment by git created at 2020-04-26 18:33:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by wuthrich created at 2020-04-26 18:35:16

That merge with #29290 was exactly the problem. Hope this works finally.


---

Comment by wuthrich created at 2020-04-26 18:35:16

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2020-04-26 20:53:20

Replying to [comment:20 wuthrich]:
> Oh? Not sure what went wrong. Let's try with this. I expact a minor problem when merging with #29290. (By the way, where do I see that "the automerging now fails..." ?) 

Sorry. This is in the ticket description, in the "branch" section. If your branch fails to merge with the current beta then it appears in red. Otherwise it is orange or green and is linked to git.sagemath.org.


---

Comment by wuthrich created at 2020-04-27 17:21:23

> Sorry. This is in the ticket description, in the "branch" section. If your branch fails to merge with the current beta then it appears in red. Otherwise it is orange or green and is linked to git.sagemath.org.

Oh, that is helpful. As a colour-blind person I never paid attention to the colour there. Hovering over it, it is spelled out.


---

Comment by vdelecroix created at 2020-04-27 17:59:44

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-04-29 22:27:56

On 32-bit:

```
**********************************************************************
File "src/sage/schemes/elliptic_curves/ell_rational_field.py", line 1358, in sage.schemes.elliptic_curves.ell_rational_field.EllipticCurve_rational_field.modular_symbol_numerical
Failed example:
    f(1/7)      # abs tol 1e-13
Expected:
    0.999844176260303
Got:
    0.999844176260738
Tolerance exceeded:
    0.999844176260303 vs 0.999844176260738, tolerance 5e-13 > 1e-13
**********************************************************************
1 item had failures:
   1 of  13 in sage.schemes.elliptic_curves.ell_rational_field.EllipticCurve_rational_field.modular_symbol_numerical
    [849 tests, 1 failure, 130.58 s]
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 928, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical.approximative_value
Failed example:
    M.approximative_value(123/567,prec=2) # abs tol 1e-13
Expected:
    -4.00002815242902
Got:
    -4.00002815254972
Tolerance exceeded:
    -4.00002815242902 vs -4.00002815254972, tolerance 2e-10 > 1e-13
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 937, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical.approximative_value
Failed example:
    M.approximative_value(1/7,prec=2)  # abs tol 1e-13
Expected:
    0.999981178147778
Got:
    0.999981178140654
Tolerance exceeded:
    0.999981178147778 vs 0.999981178140654, tolerance 8e-12 > 1e-13
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 939, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical.approximative_value
Failed example:
    M.approximative_value(1/7,prec=10) # abs tol 1e-13
Expected:
    0.999999972802649
Got:
    0.999999972795519
Tolerance exceeded:
    0.999999972802649 vs 0.999999972795519, tolerance 8e-12 > 1e-13
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 1920, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical.?
Failed example:
    m._from_ioo_to_r_approx(-1/7,0.01, use_partials=0) #abs tol 1e-13
Expected:
    6.22747410432385 - 1.48055182979493*I
Got:
    6.22747410432453 - 1.48055182979558*I
Tolerance exceeded in 2 of 2:
    6.22747410432385 vs 6.22747410432453, tolerance 7e-13 > 1e-13
    - 1.48055182979493 vs - 1.48055182979558, tolerance 7e-13 > 1e-13
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 2202, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical.?
Failed example:
    M._from_r_to_rr_approx(0/1,44/98761,0.001) # abs tol 1e-13
Expected:
    0.634604184365293 + 1.45881886531983*I
Got:
    0.634604184358477 + 1.45881886531049*I
Tolerance exceeded in 2 of 2:
    0.634604184365293 vs 0.634604184358477, tolerance 7e-12 > 1e-13
    + 1.45881886531983 vs + 1.45881886531049, tolerance 1e-11 > 1e-13
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 2388, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._transportable_approx
Failed example:
    M._from_r_to_rr_approx( 0/1, -35/144, 0.001) # abs tol 1e-13
Expected:
    -6.22753204310913 - 1.31710951034592e-8*I
Got:
    -6.22753204314086 - 1.31794770652505e-8*I
Tolerance exceeded in 2 of 2:
    -6.22753204310913 vs -6.22753204314086, tolerance 4e-11 > 1e-13
    - 1.31710951034592e-8 vs - 1.31794770652505e-8, tolerance 9e-12 > 1e-13
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 2393, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._transportable_approx
Failed example:
    M._transportable_approx( 0/1, -7/31798, 0.001) #abs tol 1e-13
Expected:
    -7.01577418382726e-9 - 7.40274138232394*I
Got:
    -7.01539626390968e-9 - 7.40274138232345*I
Tolerance exceeded in 2 of 2:
    -7.01577418382726e-9 vs -7.01539626390968e-9, tolerance 4e-13 > 1e-13
    - 7.40274138232394 vs - 7.40274138232345, tolerance 5e-13 > 1e-13
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 3310, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._evaluate_approx
Failed example:
    m._evaluate_approx(1/11,0.000001)  # abs tol 1e-13
Expected:
    9.69540669970570e-10 - 5.80486769763411e-11*I
Got:
    9.69678337625623e-10 - 5.76609870961420e-11*I
Tolerance exceeded in 2 of 2:
    9.69540669970570e-10 vs 9.69678337625623e-10, tolerance 2e-13 > 1e-13
    - 5.80486769763411e-11 vs - 5.76609870961420e-11, tolerance 4e-13 > 1e-13
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 3312, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._evaluate_approx
Failed example:
    m._evaluate_approx(1/17,0.000001) # abs tol 1e-13
Expected:
    -9.01145713605445e-10 + 7.40274134212215*I
Got:
    -9.01164337596683e-10 + 7.40274134212334*I
Tolerance exceeded in 1 of 2:
    + 7.40274134212215 vs + 7.40274134212334, tolerance 2e-12 > 1e-13
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 3320, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._evaluate_approx
Failed example:
    M._evaluate_approx(1/17,0.01) # abs tol 1e-13
Expected:
    1.08712572498569 - 0.548379313090719*I
Got:
    1.08712572498701 - 0.548379313090238*I
Tolerance exceeded in 2 of 2:
    1.08712572498569 vs 1.08712572498701, tolerance 2e-12 > 1e-13
    - 0.548379313090719 vs - 0.548379313090238, tolerance 5e-13 > 1e-13
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 3493, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._twisted_approx
Failed example:
    M.approximative_value(6/19, sign=1, prec=20, use_twist=False) # abs tol 1e-13
Expected:
    2.99999999944834
Got:
    2.99999999944752
Tolerance exceeded:
    2.99999999944834 vs 2.99999999944752, tolerance 9e-13 > 1e-13
**********************************************************************
5 items had failures:
   2 of  89 in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical.?
   3 of  13 in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._evaluate_approx
   2 of  18 in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._transportable_approx
   1 of   7 in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._twisted_approx
   3 of  11 in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical.approximative_value
    [363 tests, 11 failures, 10.55 s]
----------------------------------------------------------------------
sage -t --long src/sage/schemes/elliptic_curves/ell_rational_field.py  # 1 doctest failed
sage -t --long src/sage/schemes/elliptic_curves/mod_sym_num.pyx  # 11 doctests failed
----------------------------------------------------------------------
```



---

Comment by vbraun created at 2020-04-29 22:27:56

Changing status from positive_review to needs_work.


---

Comment by git created at 2020-05-01 09:27:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by wuthrich created at 2020-05-01 09:30:32

I changed all e-13 tolerance to e-11. The commit should solve the 32-bit problem, but I can't test that.


---

Comment by wuthrich created at 2020-05-01 09:30:32

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2020-05-01 10:20:47

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2020-05-01 10:20:47

`e-11` won't do for all of them but I see that you set `e-9` for the corresponding doctest.

One way to test on 32 bits would be to have some docker images, but I don't think there are...


---

Comment by vbraun created at 2020-05-03 22:38:54

On 32-bit:

```
**********************************************************************
File "src/sage/schemes/elliptic_curves/mod_sym_num.pyx", line 2388, in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._transportable_approx
Failed example:
    M._from_r_to_rr_approx( 0/1, -35/144, 0.001) # abs tol 1e-11
Expected:
    -6.22753204310913 - 1.31710951034592e-8*I
Got:
    -6.22753204314086 - 1.31794770652505e-8*I
Tolerance exceeded in 1 of 2:
    -6.22753204310913 vs -6.22753204314086, tolerance 4e-11 > 1e-11
**********************************************************************
1 item had failures:
   1 of  18 in sage.schemes.elliptic_curves.mod_sym_num.ModularSymbolNumerical._transportable_approx
    [363 tests, 1 failure, 10.66 s]
----------------------------------------------------------------------
sage -t --long src/sage/schemes/elliptic_curves/mod_sym_num.pyx  # 1 doctest failed
----------------------------------------------------------------------
```



---

Comment by vbraun created at 2020-05-03 22:38:54

Changing status from positive_review to needs_work.


---

Comment by mkoeppe created at 2020-05-04 00:25:37

Replying to [comment:30 vdelecroix]:
> One way to test on 32 bits would be to have some docker images, but I don't think there are...

You can test on 32 bit using `tox -e docker-ubuntu-bionic-i386-standard`, for example.


---

Comment by git created at 2020-05-06 09:13:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by wuthrich created at 2020-05-06 09:16:28

Minimal change to catch this last one. Sorry for not spotting.


---

Comment by wuthrich created at 2020-05-06 09:16:28

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2020-05-06 16:53:03

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2020-05-06 16:53:03

ok


---

Comment by vbraun created at 2020-05-26 21:44:08

Resolution: fixed
