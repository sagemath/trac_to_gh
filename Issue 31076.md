# Issue 31076: Memory leak in generalized quadrangles

Issue created by migration from https://trac.sagemath.org/ticket/31313

Original creator: vbraun

Original creation time: 2021-01-31 20:50:41

CC:  dimpase @ivo-maffei dcoudert

Keywords: generalised_quadrangle

Reproducer:

```
sage: from sage.combinat.designs.gen_quadrangles_with_spread import is_GQ_with_spread, dual_GQ_ovoid ## line 270 ##
sage: t = designs.generalised_quadrangle_hermitian_with_ovoid(3) ## line 272 ##
sage: t = dual_GQ_ovoid(*t) ## line 273 ##
sage: is_GQ_with_spread(*t, s=3, t=9) ## line 274 ##
```

For example, running the last `is_GQ_with_spread` command eats about 170MB per invocation that is never released.


---

Comment by nbruin created at 2021-02-02 07:03:53

For me,


```
from sage.combinat.designs.gen_quadrangles_with_spread import is_GQ_with_spread, dual_GQ_ovoid ## line 270 ##
t = designs.generalised_quadrangle_hermitian_with_ovoid(3) ## line 272 ##
t = dual_GQ_ovoid(*t) ## line 273 ##
for n in [1..20]:
    is_GQ_with_spread(*t, s=3, t=9) ## line 274 ##
    print(get_memory_usage())
```


does NOT show increased memory usage. Putting the other commands inside the loop doesn't create a leak either. This is on Sage 9.2.


---

Comment by @DaveWitteMorris created at 2021-02-02 07:23:46

FWIW, I see the leak. I tested nbruin's code with 9.2 and 9.3b6 on `CoCalc`, and 9.3b6 on MacOS 10.15.7. The numbers grew steadily in all cases, but the rate differed: about 170MB on `CoCalc` and about 90MB on MacOS.


---

Comment by @DaveWitteMorris created at 2021-02-02 09:54:32

I apologize if this is noise, but it appears to me that this leak has nothing to do with quadrangles. Instead, the problem seems to be that there is a memory leak in the construction of bipartite graphs:

```
sage: m = 150
....: n = 200
....: A = Matrix(ZZ, m, n)
....: for j in range(n):
....:     i = randint(0,m-2)
....:     A[i, j] = 1
....:     A[i+1, j] = 1
....: def graph(A):
....:     G = Graph(A)
....: def bipartite(A):
....:     G = BipartiteGraph(A)
....: start_mem = get_memory_usage()
....: for n in [1..10]:
....:     prev_mem = get_memory_usage()
....:     graph(A)
....:     print("graph:", get_memory_usage() - prev_mem)
....:     prev_mem = get_memory_usage()
....:     bipartite(A)
....:     print("bipartite:", get_memory_usage() - prev_mem, get_memory_usage() - start
....: _mem)
graph: 0.14453125
bipartite: 185.1640625 185.30859375
graph: 0.0
bipartite: 47.0 232.30859375
graph: 0.0
bipartite: 47.00390625 279.3125
graph: 0.0
bipartite: 48.0 327.3125
graph: 0.0
bipartite: 67.0078125 394.3203125
graph: 0.0
bipartite: 47.0 441.3203125
graph: 0.0
bipartite: 48.0 489.3203125
graph: 0.0
bipartite: 47.0 536.3203125
graph: 0.0
bipartite: 46.0 582.3203125
graph: 0.0
bipartite: 58.0 640.3203125
```

This was on MacOS. On `CoCalc`, I got a consistent bipartite leak of 93.84375.


---

Comment by nbruin created at 2021-02-02 23:07:16

As a possibly interesting data point, also for this bipartite graph example I'm not getting a leak on sage 9.2, running on CentOS Linux release 7.9.2009 (Core). Extra build info on the underlying python: Python 3.8.5 (default, Dec 15 2020, 19:39:17) [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] on linux.


---

Comment by @DaveWitteMorris created at 2021-02-02 23:20:44

The problem seems to be a small leak when accessing a row of an integer matrix. The construction of a bipartite graph involves accessing all of the entries of the matrix. If the graph is large (such as 150 x 200), then the formula `A[jj][ii]` will be evaluated tens of thousands of times, which amplifies the leak.

```
sage: A = Matrix(ZZ, 200) 
....: def here_is_a_leak(A): 
....:     for n in range(10000): 
....:         row0 = A[0] 
....:  
....: start_mem = get_memory_usage() 
....: for n in [1..5]: 
....:     prev_mem = get_memory_usage() 
....:     here_is_a_leak(A) 
....:     print("change in memory:", round(get_memory_usage() - prev_mem, 1),  
....:           "\n    total:", round(get_memory_usage() - start_mem,1))               
change in memory: 162.2 
    total: 162.2
change in memory: 15.0 
    total: 177.2
change in memory: 16.0 
    total: 193.2
change in memory: 24.0 
    total: 217.2
change in memory: 16.0 
    total: 233.2
```

This is from 9.3b6 on MacOS, but I also tested 9.2 on `CoCalc`. The leak seemed to go away (most of the time, at least) when I changed `ZZ` in the definition of `A` to `QQ` or `RR` or `GF(2^10)`.


---

Comment by @DaveWitteMorris created at 2021-02-03 00:07:30

If my diagnosis is correct, then we might be able to solve the problem on this ticket just by changing `A[jj][ii]` to `A[jj,ii]`. I'll write a patch to try that out.

If it works, we can open a different ticket about the memory leak of `A[jj]`.


---

Comment by git created at 2021-02-03 01:27:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DaveWitteMorris created at 2021-02-03 01:33:57

Changing keywords from "generalised_quadrangle" to "generalised_quadrangle, bipartite graph, memory leak".


---

Comment by @DaveWitteMorris created at 2021-02-03 01:33:57

Changing status from new to needs_review.


---

Comment by @DaveWitteMorris created at 2021-02-03 01:33:57

Yes, that simple change fixes the problem for me (and dramatically speeds up the construction of the bipartite graph).

So we should be able to remove the `# known bug` tags from #30517.


---

Comment by git created at 2021-02-03 01:48:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2021-02-03 16:29:49

EDIT: oops sorry, wrong ticket


---

Comment by dimpase created at 2021-02-04 08:16:42

Changing status from needs_review to needs_work.


---

Comment by dimpase created at 2021-02-04 08:16:42

Great catch! Please also base it on  #30517, and revert this known bug tag, here.


---

Comment by git created at 2021-02-04 09:29:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2021-02-04 09:43:11

OK, all fixed


---

Comment by dimpase created at 2021-02-04 09:43:11

Changing status from needs_work to positive_review.


---

Comment by @DaveWitteMorris created at 2021-02-04 21:15:18

Thanks! I opened #31340 for the memory leak from `A[jj]`.


---

Comment by vbraun created at 2021-02-07 22:00:51

Resolution: duplicate


---

Comment by @DaveWitteMorris created at 2021-02-07 22:47:19

`@`vbraun: This ticket (#31313) is not a duplicate. The PR here gets rid of a memory leak (and therefore removes the `# known bug` tags that were added in #30517). More work needs to be done (so there is a follow up ticket), but I think this ticket should be enough to make your buildbot run. If not, please let us know.


---

Comment by mderickx created at 2021-03-18 22:53:28

Changing status from closed to new.


---

Comment by mderickx created at 2021-03-18 22:53:28

I looked at the code here and it seems that this code will probable also be faster then the old code since it is getting entries directly from the matrix instead of creating rows. It seems that the new code is not only a workaround for the underlying bug, but that it will also be better then the existing code even after the underlying bug has been fixed. So I think it makes sense to still merge this.


---

Comment by mderickx created at 2021-03-18 22:53:28

Resolution changed from duplicate to 


---

Comment by dimpase created at 2021-03-19 12:41:16

Changing status from new to needs_review.


---

Comment by dimpase created at 2021-03-19 12:41:16

needs review? Or good to go?


---

Comment by dimpase created at 2021-03-19 12:46:48

re-checked, all good


---

Comment by dimpase created at 2021-03-19 12:46:48

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-03-20 20:55:00

Resolution: fixed


---

Comment by slelievre created at 2021-03-21 00:34:22

Thanks for fixing this and opening the follow-up ticket #31340!

Ideally, `all`, `any`, `sum`, `prod` should be
called on generators rather than lists when possible.

When coming across cases of use with list,
it's good to replace them.


```diff
-        sage: all([x in t[0] for x in t[1]])
+        sage: all(x in t[0] for x in t[1])
```


Not the point of this ticket though; will be done elsewhere.


---

Comment by @DaveWitteMorris created at 2021-03-21 00:50:59

Are you sure? I'd be happy to do it either way, but I've been told that using a list is faster.  See, for example, ticket:11606#comment:12


---

Comment by slelievre created at 2021-03-21 01:20:16

Oops, here goes my belief that using lists made things slower.

Thanks for telling me and for the reference.


---

Comment by @DaveWitteMorris created at 2021-03-21 01:34:52

Using an iterator seems much more pythonic, and must use less memory, so maybe it's better, even though it may be a bit slower, but I'm no expert and just try to do what I'm told (and often get confused about what I'm supposed to do).


---

Comment by jhpalmieri created at 2021-04-13 22:47:52

I am semi-regularly getting errors with the new doctest

```
File "src/sage/graphs/bipartite_graph.py", line 326, in sage.graphs.bipartite_graph.BipartiteGraph.__init__
Failed example:
    print(round(get_memory_usage() - start_mem))
Expected:
    0.0
Got:
    1.0
```

This is on OS X Big Sur and all recent Sage betas and rcs. I can reproduce with an interactive Sage session: if I run the loop

```
sage: for _ in range(10):
....:     make_bip_graph(A)
....:
```

it will sometimes cause an increase in memory usage.


---

Comment by dimpase created at 2021-04-14 08:10:24

Replying to [comment:29 jhpalmieri]:
> I am semi-regularly getting errors with the new doctest
> {{{
> File "src/sage/graphs/bipartite_graph.py", line 326, in sage.graphs.bipartite_graph.BipartiteGraph.__init__
> Failed example:
>     print(round(get_memory_usage() - start_mem))
> Expected:
>     0.0
> Got:
>     1.0
> }}}
> This is on OS X Big Sur and all recent Sage betas and rcs. I can reproduce with an interactive Sage session: if I run the loop
> {{{
> sage: for _ in range(10):
> ....:     make_bip_graph(A)
> ....:
> }}}
> it will sometimes cause an increase in memory usage.

Can you capture the particular A for which you get this failure, and attach it here?
Of course it might be macOS-specific...


---

Comment by jhpalmieri created at 2021-04-14 19:00:46

I have attached one example, but the following is quite repeatable for me:

- start a fresh Sage session and do this:

```
sage: A = Matrix(ZZ, 100, 125)
sage: for i in range(A.nrows()):
....:     for j in Subsets(A.ncols()).random_element():
....:         A[i, j-1] = 1
....:
sage: def make_bip_graph(A):
....:     G = BipartiteGraph(A)
....:
sage: start_mem = get_memory_usage()
```

Then I repeat these commands

```
sage: for _ in range(100):
....:     make_bip_graph(A)
....:
sage: print(round(get_memory_usage() - start_mem))
```

and the output often, but not always, increases. Every time I've started Sage, I have seen an increase: it doesn't seem to rely on a very specific value of `A`.

Further, if in the same Sage session, I redefine `A` by `A = Matrix(...)` and then use the loop `for i in ...`, then I don't see the memory leak any more, no matter how many times I iterate `make_bip_graph(A)`.


---

Attachment


---

Comment by mderickx created at 2021-04-15 06:19:09

Can it increase multiple times per session? Or is it just one time per session that this happens?

Also what happens if you do first


```
import gc
```


and then


```
gc.collect()
```


right before every call of `get_memory_usage()`


---

Comment by dimpase created at 2021-04-15 09:07:01

Replying to [comment:32 mderickx]:
> Can it increase multiple times per session? Or is it just one time per session that this happens?
> 
> Also what happens if you do first
> 
> {{{
> import gc
> }}}
> 
> and then
> 
> {{{
> gc.collect()
> }}}
> 
> right before every call of `get_memory_usage()`
> 
indeed, what John sees might be merely a bug in this doctest.
Without `gc.collect()` calls, it is not reliable, IMHO.
E.g. in `src/sage/geometry/polyhedron/base.py` on has

```
        Test that computing the face lattice does not lead to a memory leak::

            sage: import gc
            sage: _ = gc.collect()
            sage: P = polytopes.cube()
            sage: a = P.face_lattice()
            sage: n = get_memory_usage()
            sage: P = polytopes.cube()
            sage: a = P.face_lattice()
            sage: _ = gc.collect()
            sage: n == get_memory_usage()
            True
```


this is the only other memory leak test in the library which uses `get_memory_usage()` - other places merely use it for information (or just it's a useless `import` which can go).

I've opened #31671 to fix this.


---

Comment by jhpalmieri created at 2021-04-15 16:01:04

Replying to [comment:32 mderickx]:
> Can it increase multiple times per session? Or is it just one time per session that this happens?

Multiple times per session as long as I don't change the matrix `A`.
 
> Also what happens if you do first
> 
> {{{
> import gc
> }}}
> 
> and then
> 
> {{{
> gc.collect()
> }}}
> 
> right before every call of `get_memory_usage()`

Doesn't help:

```
% sage                                 
┌────────────────────────────────────────────────────────────────────┐
│ SageMath version 9.3.rc3, Release Date: 2021-04-12                 │
│ Using Python 3.9.2. Type "help()" for help.                        │
└────────────────────────────────────────────────────────────────────┘
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Warning: this is a prerelease version, and it may be unstable.     ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
sage: A = Matrix(ZZ, 100, 125)                                                                                             
sage: for i in range(A.nrows()): 
....:     for j in Subsets(A.ncols()).random_element(): 
....:         A[i, j-1] = 1 
....:                                                                                                                      
sage: def make_bip_graph(A): 
....:     G = BipartiteGraph(A) 
....:                                                                                                                      
sage: import gc                                                                                                            
sage: gc.collect()                                                                                                         
349
sage: start_mem = get_memory_usage()                                                                                       
sage: for _ in range(100):    
....:     make_bip_graph(A) 
....:                                                                                                                      
sage: gc.collect()                                                                                                         
763
sage: print(round(get_memory_usage() - start_mem))                                                                         
16.0
```



---

Comment by dimpase created at 2021-04-15 16:32:42

(un)fortunately this is platform dependent - I can't reproduce this on Linux


---

Comment by jhpalmieri created at 2021-04-15 17:01:27

What packages might affect this? I can enable/disable more homebrew packages and see if that makes a difference.


---

Comment by dimpase created at 2021-04-15 17:15:14

it doesn't use anything external, I think, it's just sagelib and cython, IMHO.


---

Comment by dcoudert created at 2021-04-15 17:51:25

on macOS 10.5.7 I observe a very small memory increase the first time we can the graph constructor. Could it be due to a lazy import or something like that ?


```
sapristi:sage dcoudert$ ./sage
┌────────────────────────────────────────────────────────────────────┐
│ SageMath version 9.3.rc3, Release Date: 2021-04-12                 │
│ Using Python 3.9.2. Type "help()" for help.                        │
└────────────────────────────────────────────────────────────────────┘
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Warning: this is a prerelease version, and it may be unstable.     ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
sage: sage: m = 150 
....: ....: n = 200 
....: ....: A = Matrix(ZZ, m, n) 
....: ....: for j in range(n): 
....: ....:     i = randint(0,m-2) 
....: ....:     A[i, j] = 1 
....: ....:     A[i+1, j] = 1 
....: ....: def graph(A): 
....: ....:     G = Graph(A) 
....: ....: def bipartite(A): 
....: ....:     G = BipartiteGraph(A) 
....: ....: start_mem = get_memory_usage() 
....: ....: for n in [1..10]: 
....: ....:     prev_mem = get_memory_usage() 
....: ....:     graph(A) 
....: ....:     print("graph:", get_memory_usage() - prev_mem) 
....: ....:     prev_mem = get_memory_usage() 
....: ....:     bipartite(A) 
....: ....:     print("bipartite:", get_memory_usage() - prev_mem, get_memory_usage() - start_mem)                                                 
graph: 0.171875
bipartite: 0.0 0.171875
graph: 0.0
bipartite: 0.0 0.171875
graph: 0.0
bipartite: 0.0 0.171875
graph: 0.0
bipartite: 0.0 0.171875
graph: 0.0
bipartite: 0.0 0.171875
graph: 0.0
bipartite: 0.0 0.171875
graph: 0.0
bipartite: 0.0 0.171875
graph: 0.0
bipartite: 0.0 0.171875
graph: 0.0
bipartite: 0.0 0.171875
graph: 0.0
bipartite: 0.0 0.171875
```



```
sapristi:sage dcoudert$ ./sage
┌────────────────────────────────────────────────────────────────────┐
│ SageMath version 9.3.rc3, Release Date: 2021-04-12                 │
│ Using Python 3.9.2. Type "help()" for help.                        │
└────────────────────────────────────────────────────────────────────┘
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Warning: this is a prerelease version, and it may be unstable.     ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
sage: sage: A = Matrix(ZZ, 100, 125)                                                                                              
....: sage: for i in range(A.nrows()):  
....: ....:     for j in Subsets(A.ncols()).random_element():  
....: ....:         A[i, j-1] = 1  
....: ....:                                                                                                                       
....: sage: def make_bip_graph(A):  
....: ....:     G = BipartiteGraph(A)  
....: ....:                                                                                                                       
....: sage: import gc                                                                                                             
....: sage: gc.collect()                                                                                                          
....:                                                                                                                                              
271
sage: sage: start_mem = get_memory_usage()                                                                                        
....: sage: for _ in range(100):     
....: ....:     make_bip_graph(A)  
....: ....:                                                                                                                       
....: sage: gc.collect()                                                                                                          
....:                                                                                                                                              
82
sage: print(round(get_memory_usage() - start_mem))                                                                                                 
0.0
```



---

Comment by dimpase created at 2021-04-18 09:26:52

Replying to [comment:38 dcoudert]:
> on macOS 10.5.7 I observe a very small memory increase the first time we can the graph constructor. Could it be due to a lazy import or something like that ?

Can you reproduce what's reported by John on macOS, or are we down to even more selective (perhaps CPU matters too?) bug in his case?


---

Comment by dcoudert created at 2021-04-18 09:54:55

When I try the branch of this ticket on macOS (10.5.7, intel CPU), I have no dockets error in `bipartite_graph.py`.

When I start a session and copy/paste the test, I have a random result:

```
sapristi:sage dcoudert$ ./sage
┌────────────────────────────────────────────────────────────────────┐
│ SageMath version 9.3.rc4, Release Date: 2021-04-18                 │
│ Using Python 3.9.2. Type "help()" for help.                        │
└────────────────────────────────────────────────────────────────────┘
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Warning: this is a prerelease version, and it may be unstable.     ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
sage: A = Matrix(ZZ, 100, 125) 
....: for i in range(A.nrows()): 
....:     for j in Subsets(A.ncols()).random_element(): 
....:         A[i, j-1] = 1 
....: def make_bip_graph(A): 
....:     G = BipartiteGraph(A) 
....: import gc 
....: gc.collect() 
....: start_mem = get_memory_usage() 
....: for _ in range(100): 
....:     make_bip_graph(A) 
....: gc.collect() 
....: print(round(get_memory_usage() - start_mem)) 
....:                                                                                                                                              
282
0
0.0
sage:                                                                                                                                              
Exiting Sage (CPU time 0m1.49s, Wall time 0m19.73s).
sapristi:sage dcoudert$ ./sage
┌────────────────────────────────────────────────────────────────────┐
│ SageMath version 9.3.rc4, Release Date: 2021-04-18                 │
│ Using Python 3.9.2. Type "help()" for help.                        │
└────────────────────────────────────────────────────────────────────┘
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Warning: this is a prerelease version, and it may be unstable.     ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
sage: A = Matrix(ZZ, 100, 125) 
....: for i in range(A.nrows()): 
....:     for j in Subsets(A.ncols()).random_element(): 
....:         A[i, j-1] = 1 
....: def make_bip_graph(A): 
....:     G = BipartiteGraph(A) 
....: import gc 
....: gc.collect() 
....: start_mem = get_memory_usage() 
....: for _ in range(100): 
....:     make_bip_graph(A) 
....: gc.collect() 
....: print(round(get_memory_usage() - start_mem)) 
....:                                                                                                                                              
282
0
1.0
```



---

Comment by jhpalmieri created at 2021-04-18 16:03:08

Replying to [comment:40 dcoudert]:
> When I try the branch of this ticket on macOS (10.5.7, intel CPU), I have no dockets error in `bipartite_graph.py`.

Can you try running the doctest several times? Does it pass 10 times in a row? Passing or failing is random for me.


---

Comment by dcoudert created at 2021-04-18 17:32:15

Passed 7 times and failed 3 times :(


---

Comment by jhpalmieri created at 2021-04-18 20:29:37

Thank you for checking. I've tried with the system Python, homebrew's Python, and Sage's, and I get failures with all three. I don't know what else to do to investigate this.


---

Comment by dimpase created at 2021-04-19 16:38:53

I presume it must be a leak in a Cython backend, but which one I don't know (not that I tried looking, though)
