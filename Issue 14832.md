# Issue 14832: Make `MonoDictEraser` and `TripleDictEraser` safe against "recursion depth exceeded"

archive/issues_014832.json:
```json
{
    "body": "CC:  @nthiery @nbruin @vbraun\n\nThe following happens both with Sage's `MonoDict` and with Python's `weakref.WeakKeyDictionary`:\n\n```\nfrom sage.structure.coerce_dict import MonoDict\nM = MonoDict(11)\n\nclass A: pass\na = A()\nprev = a\n\nfor i in range(1000):\n    newA = A()\n    M[prev] = newA\n    prev = newA\n\nlen(M)\ndel a\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x5a13788> ignored\n```\nReplace `M = MonoDict(11)` by `M = weakref.WeakKeyDictionary()`, and you get essentially the same error:\n\n```\nsage: del a\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x5f9d578> ignored\n```\n\nHowever, a `weakref.WeakValueDictionary` seems safe:\n\n```\nsage: class A: pass\nsage: M = weakref.WeakValueDictionary()\nsage: a = A()\n....: prev = a\n....: for i in range(1000):\n....:     newA = A()\n....:     M[newA] = prev\n....:     prev = newA\n....:     \nsage: len(M)\n1000\nsage: del a\nsage: len(M)\n0\n```\neven though the recursive deletion of dictionary items seems similar.\n\nAim of this ticket: Make it so that the erasers of `MonoDict` and `TripleDict` are not recursively called and thus the dreaded 'maximum recursion depth exceeded ... ignored' finally vanishes.\n\nIssue created by migration from https://trac.sagemath.org/ticket/15069\n\n",
    "closed_at": "2013-08-28T06:55:06Z",
    "created_at": "2013-08-20T20:37:57Z",
    "labels": [
        "component: performance",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.12",
    "title": "Make `MonoDictEraser` and `TripleDictEraser` safe against \"recursion depth exceeded\"",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14832",
    "user": "https://github.com/simon-king-jena"
}
```
CC:  @nthiery @nbruin @vbraun

The following happens both with Sage's `MonoDict` and with Python's `weakref.WeakKeyDictionary`:

```
from sage.structure.coerce_dict import MonoDict
M = MonoDict(11)

class A: pass
a = A()
prev = a

for i in range(1000):
    newA = A()
    M[prev] = newA
    prev = newA

len(M)
del a
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x5a13788> ignored
```
Replace `M = MonoDict(11)` by `M = weakref.WeakKeyDictionary()`, and you get essentially the same error:

```
sage: del a
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x5f9d578> ignored
```

However, a `weakref.WeakValueDictionary` seems safe:

```
sage: class A: pass
sage: M = weakref.WeakValueDictionary()
sage: a = A()
....: prev = a
....: for i in range(1000):
....:     newA = A()
....:     M[newA] = prev
....:     prev = newA
....:     
sage: len(M)
1000
sage: del a
sage: len(M)
0
```
even though the recursive deletion of dictionary items seems similar.

Aim of this ticket: Make it so that the erasers of `MonoDict` and `TripleDict` are not recursively called and thus the dreaded 'maximum recursion depth exceeded ... ignored' finally vanishes.

Issue created by migration from https://trac.sagemath.org/ticket/15069





---

archive/issue_comments_188937.json:
```json
{
    "body": "Comments 97--102 at #10963 provide some ideas how to solve the problem.\n\nActually I originally thought that the solution is easy: When the eraser of a `MonoDict` key is called, the to-be-deleted value shall be assigned to a temporary variable and thus be prevented from being deleted while the corresponding items from the bucket of the `MonoDict` are deleted; the value can only be deleted (causing a new invocation of the eraser) when the original call to the eraser is done and the temporary variable vanishes.\n\nInserting print statements shows that in unpatched Sage the eraser calls are nested, which explains the \"recursion depth exceeded\". And in fact, the trick with the temporary variable has the effect that the eraser calls are now neatly ordered and not nested. And now comes the punch-line: The \"recursion depth exceeded\" error does *not* vanish!!!\n\nThe comments at #10963 seem to show that the error behaves different if the class A in the example from the ticket description is a Python or a Cython class. But there is a recursion depth problem in either case.",
    "created_at": "2013-08-20T20:46:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188937",
    "user": "https://github.com/simon-king-jena"
}
```

Comments 97--102 at #10963 provide some ideas how to solve the problem.

Actually I originally thought that the solution is easy: When the eraser of a `MonoDict` key is called, the to-be-deleted value shall be assigned to a temporary variable and thus be prevented from being deleted while the corresponding items from the bucket of the `MonoDict` are deleted; the value can only be deleted (causing a new invocation of the eraser) when the original call to the eraser is done and the temporary variable vanishes.

Inserting print statements shows that in unpatched Sage the eraser calls are nested, which explains the "recursion depth exceeded". And in fact, the trick with the temporary variable has the effect that the eraser calls are now neatly ordered and not nested. And now comes the punch-line: The "recursion depth exceeded" error does *not* vanish!!!

The comments at #10963 seem to show that the error behaves different if the class A in the example from the ticket description is a Python or a Cython class. But there is a recursion depth problem in either case.



---

archive/issue_comments_188938.json:
```json
{
    "body": "Defining\n\n```\nclass A:                  \n    def __del__(self):\n        print \"__del__\",id(self)\n```\nand keeping track of the order in which the elements are created by\n\n```\nL = []\na = A()\nprev = a\nfor i in range(1000):\n    L.append(id(prev))\n    newA = A()\n    M[prev] = newA\n    prev = newA\ndel a\n```\nI see that the n-th element created (the first one is `a`) is the \"last but n\"-th element for which `__del__` is called. This comes as a surprise. One should think that `del a` first makes `a` disappear, which then triggers a call to the \"eraser\" callback, which then makes M[a] disappear, which triggers the next \"eraser\" callback.",
    "created_at": "2013-08-20T21:34:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188938",
    "user": "https://github.com/simon-king-jena"
}
```

Defining

```
class A:                  
    def __del__(self):
        print "__del__",id(self)
```
and keeping track of the order in which the elements are created by

```
L = []
a = A()
prev = a
for i in range(1000):
    L.append(id(prev))
    newA = A()
    M[prev] = newA
    prev = newA
del a
```
I see that the n-th element created (the first one is `a`) is the "last but n"-th element for which `__del__` is called. This comes as a surprise. One should think that `del a` first makes `a` disappear, which then triggers a call to the "eraser" callback, which then makes M[a] disappear, which triggers the next "eraser" callback.



---

archive/issue_comments_188939.json:
```json
{
    "body": "Replying to [comment:2 SimonKing]:\n> I see that the n-th element created (the first one is `a`) is the \"last but n\"-th element for which `__del__` is called. This comes as a surprise.\n\n\nOr not? The weakref module says:\n\n Weak references to an object are cleared before the object's `__del__()` is called, to ensure that the weak reference callback (if any) finds the object still alive.\n\nHm. I understand that `a.__del__()` is executed only after the callback of the weak reference to `a` has finished. But by print statements I found that the callback for `a` is done before the callback for `M[a]` is invoked! So, why is `a.__del__()` not executed directly after the first callback?",
    "created_at": "2013-08-20T21:44:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188939",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:2 SimonKing]:
> I see that the n-th element created (the first one is `a`) is the "last but n"-th element for which `__del__` is called. This comes as a surprise.


Or not? The weakref module says:

 Weak references to an object are cleared before the object's `__del__()` is called, to ensure that the weak reference callback (if any) finds the object still alive.

Hm. I understand that `a.__del__()` is executed only after the callback of the weak reference to `a` has finished. But by print statements I found that the callback for `a` is done before the callback for `M[a]` is invoked! So, why is `a.__del__()` not executed directly after the first callback?



---

archive/issue_comments_188940.json:
```json
{
    "body": "It seems that it is not enough to keep a reference to the value of the key-value pair being deleted by the eraser---but if the eraser *returns* the value, then I see the recursion depth error disappear. Hence, with this patch\n\n```diff\ndiff --git a/sage/structure/coerce_dict.pyx b/sage/structure/coerce_dict.pyx\n--- a/sage/structure/coerce_dict.pyx\n+++ b/sage/structure/coerce_dict.pyx\n@@ -187,14 +187,17 @@\n         h,offset = r.key\n         cdef list bucket = <object>PyList_GET_ITEM(buckets, (<size_t>h) % PyList_GET_SIZE(buckets))\n         cdef Py_ssize_t i\n+        cdef object val\n         for i from 0 <= i < PyList_GET_SIZE(bucket) by 3:\n             if PyInt_AsSsize_t(PyList_GET_ITEM(bucket,i))==h:\n                 if PyList_GET_ITEM(bucket,i+offset)==<void *>r:\n+                    val = <object>PyList_GET_ITEM(bucket,i+2)\n                     del bucket[i:i+3]\n                     D._size -= 1\n                     break\n                 else:\n                     break\n+        return val\n \n```\nseems to work. Doing tests now...",
    "created_at": "2013-08-20T22:07:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188940",
    "user": "https://github.com/simon-king-jena"
}
```

It seems that it is not enough to keep a reference to the value of the key-value pair being deleted by the eraser---but if the eraser *returns* the value, then I see the recursion depth error disappear. Hence, with this patch

```diff
diff --git a/sage/structure/coerce_dict.pyx b/sage/structure/coerce_dict.pyx
--- a/sage/structure/coerce_dict.pyx
+++ b/sage/structure/coerce_dict.pyx
@@ -187,14 +187,17 @@
         h,offset = r.key
         cdef list bucket = <object>PyList_GET_ITEM(buckets, (<size_t>h) % PyList_GET_SIZE(buckets))
         cdef Py_ssize_t i
+        cdef object val
         for i from 0 <= i < PyList_GET_SIZE(bucket) by 3:
             if PyInt_AsSsize_t(PyList_GET_ITEM(bucket,i))==h:
                 if PyList_GET_ITEM(bucket,i+offset)==<void *>r:
+                    val = <object>PyList_GET_ITEM(bucket,i+2)
                     del bucket[i:i+3]
                     D._size -= 1
                     break
                 else:
                     break
+        return val
 
```
seems to work. Doing tests now...



---

archive/issue_comments_188941.json:
```json
{
    "body": "Attachment [trac15069-recursion_safe_callback.patch](tarball://root/attachments/some-uuid/ticket15069/trac15069-recursion_safe_callback.patch) by @simon-king-jena created at 2013-08-20 23:48:29\n\nWith the patch that I have attached, the \"recursion depth exceeded\" problem seems to vanish. Let's see if the full test suite passes.",
    "created_at": "2013-08-20T23:48:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188941",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac15069-recursion_safe_callback.patch](tarball://root/attachments/some-uuid/ticket15069/trac15069-recursion_safe_callback.patch) by @simon-king-jena created at 2013-08-20 23:48:29

With the patch that I have attached, the "recursion depth exceeded" problem seems to vanish. Let's see if the full test suite passes.



---

archive/issue_comments_188942.json:
```json
{
    "body": "The tests pass for me. Needs review, then!",
    "created_at": "2013-08-21T07:53:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188942",
    "user": "https://github.com/simon-king-jena"
}
```

The tests pass for me. Needs review, then!



---

archive/issue_comments_188943.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-08-21T07:53:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188943",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_188944.json:
```json
{
    "body": "I don't think Python makes any guarantees that this is safe. The issue is precisely where the object is deallocated. As you noted, a local variable doesn't cut it as it gets destroyed while we are still in the \"remove' function frame. A return value apparently works, but that is just an implementation detail of CPython. A different Python version might very well destroy returned-but-discarded values while still in the function frame.\n\nIts still better than before, so if you want to run with this workaround then that is fine with me.",
    "created_at": "2013-08-21T09:41:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188944",
    "user": "https://github.com/vbraun"
}
```

I don't think Python makes any guarantees that this is safe. The issue is precisely where the object is deallocated. As you noted, a local variable doesn't cut it as it gets destroyed while we are still in the "remove' function frame. A return value apparently works, but that is just an implementation detail of CPython. A different Python version might very well destroy returned-but-discarded values while still in the function frame.

Its still better than before, so if you want to run with this workaround then that is fine with me.



---

archive/issue_comments_188945.json:
```json
{
    "body": "Replying to [comment:7 vbraun]:\n> I don't think Python makes any guarantees that this is safe. The issue is precisely where the object is deallocated. As you noted, a local variable doesn't cut it as it gets destroyed while we are still in the \"remove' function frame. A return value apparently works, but that is just an implementation detail of CPython. A different Python version might very well destroy returned-but-discarded values while still in the function frame.\n> \n> Its still better than before, so if you want to run with this workaround then that is fine with me.\n\n\nIn the worst case we will get an explicit recursion error, some\nobjects won't get deleted, and the calculation will proceed safely,\nright?\n\nIf yes, then I agree it's not yet perfect but safe enough to go\nahead. Thanks Simon!\n\nI don't feel quite qualified for the fine technical details. Volker,\nif you give me a green light, I am happy finishing the rest of the\nreview.\n\nCheers,\n                            Nicolas",
    "created_at": "2013-08-21T10:22:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188945",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:7 vbraun]:
> I don't think Python makes any guarantees that this is safe. The issue is precisely where the object is deallocated. As you noted, a local variable doesn't cut it as it gets destroyed while we are still in the "remove' function frame. A return value apparently works, but that is just an implementation detail of CPython. A different Python version might very well destroy returned-but-discarded values while still in the function frame.
> 
> Its still better than before, so if you want to run with this workaround then that is fine with me.


In the worst case we will get an explicit recursion error, some
objects won't get deleted, and the calculation will proceed safely,
right?

If yes, then I agree it's not yet perfect but safe enough to go
ahead. Thanks Simon!

I don't feel quite qualified for the fine technical details. Volker,
if you give me a green light, I am happy finishing the rest of the
review.

Cheers,
                            Nicolas



---

archive/issue_comments_188946.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-08-21T10:46:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188946",
    "user": "https://github.com/vbraun"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_188947.json:
```json
{
    "body": "At least we'll have a doctest, so if it breaks in the future we'll be notified ;-)",
    "created_at": "2013-08-21T10:46:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188947",
    "user": "https://github.com/vbraun"
}
```

At least we'll have a doctest, so if it breaks in the future we'll be notified ;-)



---

archive/issue_events_043350.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-28T06:55:06Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14832#event-43350"
}
```



---

archive/issue_comments_188948.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-08-28T06:55:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14832",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14832#issuecomment-188948",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed
