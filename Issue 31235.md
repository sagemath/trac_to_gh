# Issue 31235: Truncated inverse and system solution for polynomial matrices

Issue created by migration from https://trac.sagemath.org/ticket/31472

Original creator: @vneiger

Original creation time: 2021-03-08 10:21:00

CC:  @ke456

Keywords: polynomial matrix; truncated inverse expansion

Two functions can be added:
* `inverse_series_trunc`, similarly to what exists for polynomials: it returns a polynomial approximation at the given precision of the inverse series of this polynomial matrix (algorithm: Newton iteration; requirement: constant coefficient is a unit)
* truncated expansion of linear system solution.
For the latter, it should be decided whereas to support only the case where the constant coefficient is a unit (easier to handle), or more generally any nonsingular input matrix.


---

Comment by mkoeppe created at 2021-03-24 02:04:25

Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.


---

Comment by git created at 2021-07-31 11:31:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vneiger created at 2021-07-31 12:00:39

The truncated inverse method is complete (code, doc, tests) and ready for review. I add here that in the current state of sage and without considering the time for format conversions:
* this method is much faster than the same operation done via polynomials with matrix coefficients when the degrees are "large" and matrix dimensions are "small";
* this method is much slower than the same operation done via polynomials with matrix coefficients when the degrees are "small" and matrix dimensions are "large".

This is simply explained: with the current implementations, the "matrix of polynomials" format benefits from fast polynomial multiplication but relies on naive matrix multiplication, whereas the "polynomial with matrix coefficients" format benefits from fast linear algebra but relies on naive polynomial multiplication. *In short, sage currently lacks a fast polynomial matrix multiplication combining fast polynomial multiplication and fast matrix multiplication*, at least when working over fields where such things are not too tricky to do. But the best approach should be to incorporate this from [LinBox](https://github.com/linbox-team/linbox), [NTL/PML](https://github.com/vneiger/pml), or other efficient libraries which already implement this.

*Examples:*


```
sage: mpR.<X> = MatrixSpace(GF(9001),3,3)[]
sage: C = mpR.random_element(degree=1000)
sage: %time inv_trunc = C.inverse_series_trunc(1001)
Wall time: 1.39 s
sage: %time inv_trunc = C.inverse_series_trunc(10000)
Wall time: 31.4 s

sage: pR.<x> = GF(9001)[]
sage: M = Matrix.random(pR,3,3,degree=1000)
sage: %time inv_trunc = M.inverse_series_trunc(1001)
Wall time: 8.21 ms
sage: %time inv_trunc = M.inverse_series_trunc(1000000)
CPU times: user 5.9 s, sys: 80 ms, total: 5.98 s
Wall time: 5.98 s

sage: mpR.<X> = MatrixSpace(GF(9001),200,200)[]
sage: C = mpR.random_element(degree=10)
sage: %time inv_trunc = C.inverse_series_trunc(11)
Wall time: 271 ms
sage: M = Matrix.random(pR,200,200,degree=10)
sage: %time inv_trunc = M.inverse_series_trunc(11)
Wall time: 30.3 s
```



---

Comment by git created at 2021-07-31 12:10:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-07-31 16:31:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vneiger created at 2021-07-31 16:35:08

The second item is now handled (truncated expansion of linear system solution). It is done in full generality, supporting any matrix as input, and will either give a solution or reports that none exists. When the input matrix is square with invertible constant matrix (thus in particular ensuring the existence of a unique solution), it directly relies on Newton iteration and a Dixon-like solver; otherwise for the general case it goes through an approximant basis computation.


---

Comment by @vneiger created at 2021-07-31 16:35:40

Changing status from new to needs_review.


---

Comment by @vneiger created at 2021-07-31 16:36:10

Set assignee to @ke456.


---

Comment by @ke456 created at 2021-08-01 04:14:01

Great start, but a few comments:

1) Can this be used for solving (solve_left and solve_right) at full precision? Even if we don't do anything clever, we should give a function that computes the correct precision and calls the truncated algorithm.

2) If we are sticking with Sage's functionality for solve_left and solve_right, then we should provide support for nonsingular and non-square matrices.

3) Can the truncated inverse be used to compute the inverse at full precision?


---

Comment by @vneiger created at 2021-08-01 12:51:05

Thank you for the comments. For 2), it was indeed the properties of Sage's `solve_left` which pushed me to handle the general case. I will now look into 1) and 3) to see whether it is interesting to have these full precision procedures (interesting meaning somehow more efficient than the existing `solve_left` and `inverse` which already exist but use generic algorithms), and whether it is straightforward to add or should be part of another ticket.


---

Comment by @vneiger created at 2021-08-01 13:32:59

First experiments: `solve_left`, in the case of a *square nonsingular matrix*.

In that case, the standard approach to do `solve_left` is to do the `solve_left_series_trunc` version at precision twice the degree times the dimension (`2*m*d` in the code below), and then reconstruct the fractions via fast GCD. This seems to be *substantially faster than the existing `solve_left`* for all parameters I tried (note that below I am not timing the GCD step, but that must be negligible compared to the matrix operations).


```
sage: pR.<x> = GF(9001)[]

sage: m = 4
sage: d = 64
sage: A = Matrix.random(pR, m, m, degree=d-1)
sage: B = Matrix.random(pR, 1, m, degree=d-1)
sage: %timeit XX = A.solve_left(B)
10.9 ms ± 16.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit X = A.solve_left_series_trunc(B, 2*m*d)
2.5 ms ± 2.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

sage: m = 16
sage: A = Matrix.random(pR, m, m, degree=d-1)
sage: B = Matrix.random(pR, 1, m, degree=d-1)
sage: %timeit XX = A.solve_left(B)
5.27 s ± 15.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit X = A.solve_left_series_trunc(B, 2*m*d)
76.6 ms ± 168 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

sage: m = 4
sage: d = 512
sage: A = Matrix.random(pR, m, m, degree=d-1)
sage: B = Matrix.random(pR, 1, m, degree=d-1)
sage: %timeit XX = A.solve_left(B)
228 ms ± 295 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit X = A.solve_left_series_trunc(B, 2*m*d)
15.8 ms ± 11.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

sage: B = Matrix.random(pR, 1, m, degree=m*d-1)
sage: %timeit XX = A.solve_left(B)
247 ms ± 332 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit X = A.solve_left_series_trunc(B, 2*m*d)
18.2 ms ± 5.47 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```



---

Comment by @vneiger created at 2021-08-01 13:45:55

Now some timings for `inverse`, in the case of a *square matrix with invertible constant term*.

Again, compared against the existing `inverse`, there is a *clear advantage of using the new `inverse_series_trunc`* (Newton iteration) at precision twice the dimension times the degree, and then reconstructing the inverse entries by fast GCD.


```
pR.<x> = GF(9001)[]
sage: m = 4
sage: d = 64
sage: A = Matrix.random(pR, m, m, degree=d)
sage: %timeit C = A.inverse()
13.7 ms ± 3.15 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit B = A.inverse_series_trunc(2*m*d)
2.78 ms ± 9.35 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

sage: m = 16
sage: A = Matrix.random(pR, m, m, degree=d)
sage: %timeit C = A.inverse()
8.18 s ± 5.35 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit B = A.inverse_series_trunc(2*m*d)
447 ms ± 268 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)

sage: m = 4
sage: d = 512
sage: A = Matrix.random(pR, m, m, degree=d)
sage: %timeit C = A.inverse()
263 ms ± 548 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit B = A.inverse_series_trunc(2*m*d)
25.5 ms ± 15.8 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
```



---

Comment by @vneiger created at 2021-08-01 13:53:57

Now, to conclude, **my suggestion is to open two new tickets for improving system solve and inversion using these new functionalities**.

Indeed the above experiments show good potential, but this is only tested on a small set of parameters, and in the favorable case of square matrices with invertible constant term.
- System solve (i.e. `solve_left` and `solve_right`) can be applied much more generally, such as to rank-deficient and rectangular matrices. It should be investigated whether the approximant basis approach used in `solve_left_series_trunc` for these general cases is still interesting versus the existing `solve_left`. Another (directly related) approach for the general case, to be investigated as well, is to apply the minimal kernel basis method.
- Inversion (i.e. `inverse`) can be applied to nonsingular matrices that do not have invertible constant term, which `inverse_series_trunc` cannot do. Also, we should investigate more general inversion methods such as those based on a partial diagonalization procedure (Zhou & Labahn & Storjohann 2015).
- In all cases, more extensive benchmarking should be made to make sure that there is no loss of performance for some families of parameters.

This is too much work and changes not directly in the scope of this ticket.

Please let me know if you have comments about these comments (before I create these tickets), and also about potential other things to improve on the core of this ticket.


---

Comment by @vneiger created at 2021-08-02 08:47:44

Since this seems close to finished, I suppose we can safely revert to milestone 9.4.


---

Comment by @ke456 created at 2021-08-02 15:11:22

Yes, these tasks seem to be too broad in scope for this ticket alone. I believe the goal that was set for this ticket has been met.


---

Comment by @ke456 created at 2021-08-02 15:11:22

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2021-09-26 01:48:17

Resolution: fixed


---

Comment by mkoeppe created at 2021-09-26 01:48:17

It looks like this was merged as part of #31465.
