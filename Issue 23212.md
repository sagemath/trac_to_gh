# Issue 23212: Fast logarithm for p-adic floats

Issue created by migration from Trac.

Original creator: caruso

Original creation time: 2017-07-18 04:34:26

CC:  roed saraedum

This ticket provides a fast implementation of the computation of the logarithm for p-adic floats. It is the continuation of #23043.



---

Comment by caruso created at 2017-07-18 04:36:26

Changing keywords from "" to "sd87".


---

Comment by caruso created at 2017-07-18 04:36:26

New commits:


---

Comment by roed created at 2017-08-03 22:00:23

Xavier, what's the status of this ticket?  What still needs to be done before it's ready for review?
----
New commits:


---

Comment by caruso created at 2017-08-05 12:43:43

I have a question.

If x is a floating point number which is very close to a `p^n`-root of unity, say `x = zeta_(p^n) + h` with h very small, the log(x) has a very high valuation. In that case, what should we do? Should we compute log(x) at the relative precision specified in the parent (but this can be costly if h is very small) or should we instead compute log(x) at some reasonable precision and don't care if the returned result is not sharp?


---

Comment by kedlaya created at 2017-09-22 19:37:51

Replying to [comment:5 caruso]:
> I have a question.
> 
> If x is a floating point number which is very close to a `p^n`-root of unity, say `x = zeta_(p^n) + h` with h very small, the log(x) has a very high valuation. In that case, what should we do? Should we compute log(x) at the relative precision specified in the parent (but this can be costly if h is very small) or should we instead compute log(x) at some reasonable precision and don't care if the returned result is not sharp?

This shouldn't be an issue if we handle things right way: before computing the series expansion, first replace x by `x<sup>{p</sup>n}` for some n which is large enough to raise the valuation of x-1 above some fixed cutoff (say 1). Then divide the final answer by `p^n`.


---

Comment by caruso created at 2018-03-11 20:37:26

I'm not sure that your answer resolves my problem.

Suppose that we are working with `e*N` digits of precision (where e is the absolute ramification index) and that `h` has valuation `e*N/2`.
If `x = zeta_(p^n) + h`, then the result of `x<sup>{p</sup>n}` will be `1 + p<sup>n*h/zeta_(p</sup>n)` truncated modulo `p^N`. Therefore, the value we will get for `log(x)` is `h/zeta_(p^n)` truncated modulo `p^(N-n)`. Thus only `e*(N/2 - n)` digits will be correct. This is not sharp.

In comparison, if we just expand the series of `log(1 + h')` with `h' = zeta_(p^n) - 1 + h`, we get `e*N/2` correct digits (the first `e*N/2` digits vanish), which is a bit better (but still not sharp).

Am I mistaken?


---

Comment by roed created at 2018-07-22 20:25:42

Changing keywords from "sd87" to "sd87, padicIMA".


---

Comment by roed created at 2019-09-07 12:43:41

Changing keywords from "sd87, padicIMA" to "sd87, padicIMA, padicBordeaux".
