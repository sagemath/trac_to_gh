# Issue 17571: Preparse integers as strings

Issue created by migration from https://trac.sagemath.org/ticket/17808

Original creator: jdemeyer

Original creation time: 2015-02-19 08:31:31

Currently we have

```
sage: print preparse("100")
Integer(100)
sage: preparse("100.0")
RealNumber('100.0')
```

but the first could be changed to

```
sage: print preparse("100")
Integer('100')
```


This has two advantages:

1. it would also be a lot faster since MPIR parses large string constants faster than Python:

```
sage: s="1" + "0"*10000
sage: timeit("""eval("%s")""" % s)
625 loops, best of 3: 751 µs per loop
sage: timeit("""eval('Integer("%s")')""" % s)
625 loops, best of 3: 151 µs per loop
```


2. It solves #17807: thanks to #17413, entering `0100` will give a deprecation warning so at users should know something funny is going on when they enter `0100`.


---

Comment by jdemeyer created at 2015-02-21 20:23:21

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2015-02-21 20:23:21

New commits:


---

Comment by nbruin created at 2015-02-22 08:11:21

I would think the slow-down for small integers makes the proposed changes very unattractive. The whole idea of preparsing `100` as `Integer(100)` is that in the AST and the generated byte code, the constant `100` is already stored as a numerical one, and hence conversion is much faster.

For instance, in code like:

```
sage: %timeit L=[Integer('1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000') for i in range(10000r)]
100 loops, best of 3: 11.4 ms per loop
sage: %timeit L=[Integer(1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) for i in range(10000r)]
100 loops, best of 3: 4.66 ms per loop
```

you really start to notice this.

preparse_file mitigates issues like this a little bit by factoring out numeric constants, so that their conversion doesn't happen in inner loops.

If you want to store your numerical constants as strings in the byte code and have fast conversion, you should probably store them in hex. It's a little more work in the preparser, but the result is more compact and conversion to a numerical constant is truly linear in number of bits.


---

Comment by jdemeyer created at 2015-02-22 09:24:27

Replying to [comment:5 nbruin]:
> The whole idea of preparsing `100` as `Integer(100)` is that in the AST and the generated byte code, the constant `100` is already stored as a numerical one
Is that really important? The "timeit" example is of course a bit artificial.


---

Comment by nbruin created at 2015-02-22 18:20:36

Replying to [comment:6 jdemeyer]:
> Replying to [comment:5 nbruin]:
> > The whole idea of preparsing `100` as `Integer(100)` is that in the AST and the generated byte code, the constant `100` is already stored as a numerical one
> Is that really important? The "timeit" example is of course a bit artificial.

I think so. Storing the numerical constant as a string forces the decimal-to-binary conversion to happen at runtime. If you just write it as a python integer, the conversion happens at parsing, so by the time it's an ast and the compiler looks at it, you're already dealing with an integer. 

Unfortunately, python doesn't permit compile-time macros (perhaps if we're ever going to rewrite our preparser to properly parse, we can combine it with [MacroPy](https://pypi.python.org/pypi/MacroPy) and then we can have `Integer` object creation at compile time)

I am fairly certain that nearly all code that gets run with sage has TONS of small integer literals in it. Probably for many applications, people would get better performance writing `100r`, but of course nobody will. This ticket would deteriorate the much more common situation in favour of a small gain in the extremely rare situation that someone wants to include an incredibly large integer literal in their code (talk about artificial--I don't think having a (small) numerical literal in an inner loop is artificial at all!). And the extremely rare situation can be solved by writing quotes already (and by the time you're writing such a long string you might as well convert it to hex anyway, in which case Python and GMP are (at least asymptotically) comparable.

If you use `preparse_file` instead of `preparse`, you'll see that numerical constants get pushed outside (which has its own set of problems, see #11542), which mitigates the string-conversion-in-inner-loop.


---

Comment by jdemeyer created at 2015-02-22 19:32:01

Fine, you convinced me.


---

Comment by jdemeyer created at 2015-02-22 19:32:01

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-02-24 14:44:41

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2015-02-24 15:02:42

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2015-04-19 08:07:54

New commits:


---

Comment by jdemeyer created at 2016-05-02 13:35:48

Changing component from misc to python3.


---

Comment by git created at 2016-05-02 15:24:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2016-05-29 18:27:38

is the title still acurately describing the content of the ticket ?


---

Comment by jdemeyer created at 2016-05-29 19:12:47

Replying to [comment:17 chapoton]:
> is the title still acurately describing the content of the ticket ?

Yes.


---

Comment by jdemeyer created at 2016-05-29 19:15:04

Although the ticket does change a little bit more than that, I added a sentence to the description.


---

Comment by chapoton created at 2016-05-29 19:27:41

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2016-05-29 19:27:41

ok, looks good to me


---

Comment by vbraun created at 2016-05-31 07:29:46

Resolution: fixed
